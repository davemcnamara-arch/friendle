<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Friendle - Match Activities with Friends</title>
    <link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#667eea">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }

        .app-container {
            max-width: 400px;
            margin: 0 auto;
            background: white;
            height: 100%;
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }

        .page {
            display: none;
            padding: 20px;
            flex: 1;
            overflow-y: auto;
        }

        .page.active {
            display: block;
        }

        .page#chat.active {
            display: flex;
            flex-direction: column;
            padding: 0;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .logo {
            font-size: 2.5em;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .tagline {
            color: #666;
            font-size: 0.9em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        #activity-search {
            margin-bottom: 20px;
        }

        .btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 10px 0;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #333;
            border: 2px solid #e1e5e9;
        }

        .btn-secondary:hover {
            background: #e9ecef;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }
        
        .btn-small {
            width: auto;
            padding: 10px 20px;
            font-size: 0.9em;
            margin-top: 0;
        }

        .avatar-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .avatar-option {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid #e1e5e9;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            background: #f8f9fa;
        }

        .avatar-option:hover {
            transform: scale(1.1);
        }

        .avatar-option.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .circle-card {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            border: 2px solid transparent;
            transition: all 0.3s;
        }
        
        .circle-card .main-content {
            cursor: pointer;
        }

        .circle-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .circle-name {
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .circle-members {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .circle-code {
            background: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 0.8em;
            color: #555;
            text-align: center;
            margin-top: 10px;
        }
        
        .circle-code strong {
            letter-spacing: 2px;
            font-size: 1.1em;
            color: #667eea;
        }

        .activities-grid, .frequent-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .section-title {
            font-size: 1.1em;
            font-weight: 600;
            color: #555;
            margin: 20px 0 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid #f0f0f0;
        }

        .activity-card {
            background: white;
            border: 2px solid #e1e5e9;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .activity-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }

        .activity-card.selected {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-color: #667eea;
        }

        .activity-emoji {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .activity-name {
            font-weight: 600;
            font-size: 0.9em;
        }

        .bulk-controls {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .bulk-controls h4 {
            margin-bottom: 10px;
            color: #555;
        }

        .bulk-btn {
            display: inline-block;
            padding: 8px 12px;
            margin: 5px 5px 5px 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 20px;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .bulk-btn:hover {
            background: #667eea;
            color: white;
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .chat-header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            flex-shrink: 0;
        }

        .chat-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: white;
            color: #667eea;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 10px;
        }
        
        .scheduled-event-banner {
            padding: 10px;
            background-color: #e6f7ff;
            border-bottom: 1px solid #91d5ff;
            text-align: center;
            font-size: 0.9em;
            color: #0050b3;
            flex-shrink: 0;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #f8f9fa;
        }

        .message {
            margin: 15px 0;
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .message-actions {
    position: relative;
}

.message-actions-btn {
    background: none;
    border: none;
    color: #aaa;
    cursor: pointer;
    font-size: 1.2em;
    padding: 5px;
}

.message-actions-menu {
    position: absolute;
    bottom: 25px;
    right: 0;
    background: white;
    border: 1px solid #ddd;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    display: none;
    width: 100px;
    z-index: 10;
}

.message-actions-menu button {
    display: block;
    width: 100%;
    padding: 10px;
    background: none;
    border: none;
    text-align: left;
    cursor: pointer;
}

.message-actions-menu button:hover {
    background: #f8f9fa;
}

        .message.own {
            flex-direction: row-reverse;
        }
        
        .message.system {
            justify-content: center;
            font-size: 0.8em;
            color: #888;
            margin: 20px 0;
        }

        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #667eea;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            font-weight: bold;
            flex-shrink: 0;
        }

        .message-content {
            max-width: 80%;
        }

        .message-sender {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 4px;
            padding: 0 12px;
        }

        .message.own .message-content {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .message-bubble {
            background: white;
            padding: 12px 15px;
            border-radius: 15px;
            position: relative;
        }

        .message.own .message-bubble {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .message-photo {
            max-width: 200px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .message-photo:hover {
            transform: scale(1.05);
        }

        .message-location {
            background: #e8f4fd;
            border: 1px solid #bee5eb;
            padding: 10px;
            border-radius: 10px;
            cursor: pointer;
        }
        
        .message-actions {
            position: relative;
        }

        .message-actions-btn {
            background: none;
            border: none;
            color: #aaa;
            cursor: pointer;
            font-size: 1.2em;
            padding: 5px;
        }
        
        .message-actions-menu {
            position: absolute;
            bottom: 25px;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: none;
            width: 100px;
            z-index: 10;
        }

        .message-actions-menu button {
            display: block;
            width: 100%;
            padding: 10px;
            background: none;
            border: none;
            text-align: left;
            cursor: pointer;
        }
        .message-actions-menu button:hover {
            background: #f8f9fa;
        }

        .chat-input {
            background: white;
            padding: 15px;
            border-top: 1px solid #ddd;
            flex-shrink: 0;
        }
        
        .chat-input-top-row {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }

        .chat-input input[type="text"] {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 20px;
            outline: none;
            min-width: 50px;
        }
        
        .attachment-btn {
            background: #f8f9fa;
            border: none;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 1.2em;
        }
        
        .attachment-btn:hover {
            background: #e9ecef;
        }

        .send-btn {
            margin: 0;
        }

        .bottom-nav {
            position: relative;
            width: 100%;
            background: white;
            border-top: 1px solid #ddd;
            display: flex;
            justify-content: space-around;
            padding: 15px 0;
            flex-shrink: 0;
        }

        .nav-item {
            text-align: center;
            cursor: pointer;
            transition: color 0.2s;
            flex: 1;
            position: relative;
        }
        
        .notification-badge {
            position: absolute;
            top: -5px;
            right: calc(50% - 20px);
            width: 10px;
            height: 10px;
            background-color: #ff4d4f;
            border-radius: 50%;
            border: 2px solid white;
            display: none;
        }

        .nav-item.active {
            color: #667eea;
        }

        .nav-item .nav-icon {
            font-size: 1.2em;
            margin-bottom: 5px;
        }

        .nav-item .nav-label {
            font-size: 0.7em;
            font-weight: 600;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-content {
    	background: white;
    	padding: 25px;
    	border-radius: 15px;
    	max-width: 90%;
    	width: 350px;
    	max-height: 90vh;
    	overflow-y: auto;
    	box-shadow: 0 10px 30px rgba(0,0,0,0.2);
	}
        
        .modal-image-content {
            background: transparent;
            padding: 0;
            box-shadow: none;
        }

        .modal-image {
            width: 100%;
            height: auto;
            border-radius: 10px;
        }

        .close-modal {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 2em;
            cursor: pointer;
            z-index: 2001;
        }
        
        .modal-content .close-modal-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.5em;
            color: #aaa;
            cursor: pointer;
        }

        .modal-header {
            font-size: 1.4em;
            font-weight: 600;
            margin-bottom: 20px;
            color: #333;
        }
        
        .undo-container {
    position: fixed;
    bottom: 70px;
    left: 50%;
    transform: translateX(-50%);
    width: calc(100% - 40px);
    max-width: 360px;
    background-color: #333;
    color: white;
    padding: 15px;
    border-radius: 10px;
    display: none;
    justify-content: space-between;
    align-items: center;
    z-index: 1001; /* Higher than the save button */
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

        .undo-btn {
            background: none;
            border: none;
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
        }

.sticky-save {
    position: fixed;
    bottom: 80px;
    left: 50%;
    transform: translateX(-50%);
    width: calc(100% - 40px);
    max-width: 360px;
    z-index: 100;
    box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
}

.sticky-save:hover {
    transform: translateX(-50%) translateY(-2px);
    box-shadow: 0 3px 15px rgba(102, 126, 234, 0.4);
}

#manage-activities-grid {
    max-height: 400px;
    overflow-y: auto;
    margin-bottom: 20px;
}

.message-timestamp {
            color: #999;
            font-size: 0.7em;
            margin-left: 8px;
        }

#manage-activities-grid .activities-grid {
    display: grid !important;
    grid-template-columns: repeat(3, 1fr) !important;
    gap: 10px;
    margin-bottom: 20px;
}

#manage-activities-grid h3 {
    font-size: 1em;
    font-weight: 600;
    color: #555;
    margin: 15px 0 10px 0;
    padding-bottom: 5px;
    border-bottom: 1px solid #f0f0f0;
}

#manage-activities-grid h3:first-child {
    margin-top: 0;
}

#manage-activities-modal-overlay .modal-content {
    max-height: 80vh;
    overflow-y: auto;
}

#manage-activities-grid .activity-card {
    padding: 8px !important;
    font-size: 0.75em !important;
    min-height: 60px !important;
    max-height: 60px !important;
    width: 100% !important;
}

#manage-activities-grid .activity-emoji {
    font-size: 1.1em !important;
    margin-bottom: 4px !important;
}

#manage-activities-grid .activity-name {
    font-size: 0.75em !important;
    line-height: 1.1 !important;
    margin: 0 !important;
}

#manage-activities-modal-overlay #manage-activities-grid {
    display: block !important;
    grid-template-columns: unset !important;
}

    </style>
<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
<script>
  const SUPABASE_URL = "https://kxsewkjbhxtfqbytftbu.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt4c2V3a2piaHh0ZnFieXRmdGJ1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg4NTE4ODQsImV4cCI6MjA3NDQyNzg4NH0.-A-7VOQWOaQqYOO6NxiKxGywddfS-pmwvzHISJqz2AQ";

  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
</script>

</head>
<body>
    <div class="app-container">
        <div id="pages-container" style="flex: 1; overflow-y: auto; position: relative;">
<div id="onboarding" class="page active">
    <div class="header">
        <div class="logo">⭕ Friendle</div>
        <div class="tagline" id="onboarding-tagline">Coordinate hangouts with friends</div>
    </div>
    
    <div id="onboarding-content" style="padding: 20px;">
        <!-- Invite context (shown when invite_code exists) -->
        <div id="invite-context" style="display: none; text-align: center; margin-bottom: 30px;">
            <div style="font-size: 1.2em; font-weight: 600; margin-bottom: 10px;">
                You've been invited to join
            </div>
            <div id="invite-circle-name" style="font-size: 1.5em; font-weight: bold; color: #667eea; margin-bottom: 20px;">
                Loading...
            </div>
        </div>
        
        <!-- Generic pitch (shown when no invite_code) -->
        <div id="generic-pitch" style="margin-bottom: 30px;">
            <div style="font-size: 1.1em; line-height: 1.6; color: #555;">
                <p style="margin-bottom: 15px;">Stop coordinating plans through endless group chat messages.</p>
                <p style="margin-bottom: 15px;">With Friendle:</p>
                <ul style="list-style: none; padding-left: 0;">
    <li style="margin-bottom: 10px;">✓ Share what activities you're interested in</li>
    <li style="margin-bottom: 10px;">✓ See who else wants to do the same things and make it happen</li>
</ul>
            </div>
        </div>
        
        <button class="btn" id="onboarding-cta" onclick="showWelcomeFromOnboarding()">Get Started</button>
        <div style="text-align: center; margin-top: 15px; color: #666; font-size: 0.9em;">
            Already have an account? <a href="#" onclick="showWelcomeFromOnboarding(); return false;" style="color: #667eea; text-decoration: underline;">Sign in</a>
        </div>
    </div>
</div>
            <div id="welcome" class="page">
    <div class="header"><div class="logo">⭕ Friendle</div><div class="tagline">What do you feel like doing?</div></div>
    
    <div id="login-form">
        <div class="form-group"><label for="login-email">Email</label><input type="email" id="login-email" placeholder="Enter your email"></div>
        <div class="form-group"><label for="login-password">Password</label><input type="password" id="login-password" placeholder="Enter your password"></div>
        <button class="btn" onclick="signIn()">Sign In</button>
        <button class="btn btn-secondary" onclick="showRegister()">Create Account</button>
    </div>
    
    <div id="register-form" style="display: none;">
        <div class="form-group"><label for="register-email">Email</label><input type="email" id="register-email" placeholder="Enter your email"></div>
        <div class="form-group"><label for="register-password">Password</label><input type="password" id="register-password" placeholder="Create a password (6+ characters)"></div>
        <div class="form-group"><label for="register-name">Your Name</label><input type="text" id="register-name" placeholder="Enter your name"></div>
        <div class="form-group"><label>Choose Your Avatar</label><div class="avatar-grid">
            <div class="avatar-option" data-avatar="😊">😊</div><div class="avatar-option" data-avatar="🌟">🌟</div><div class="avatar-option" data-avatar="🦄">🦄</div><div class="avatar-option" data-avatar="🐨">🐨</div>
            <div class="avatar-option" data-avatar="🎮">🎮</div><div class="avatar-option" data-avatar="🎨">🎨</div><div class="avatar-option" data-avatar="⚡">⚡</div><div class="avatar-option" data-avatar="🌙">🌙</div>
        </div></div>
        <button class="btn" onclick="signUp()">Create Account</button>
        <div style="text-align: center; margin-top: 20px; margin-bottom: -10px; color: #666; font-size: 0.9em;">
    Already have an account?
</div>
<button class="btn btn-secondary" onclick="showLogin()">Sign In</button>
    </div>
</div>
            <div id="circles" class="page">
    <div class="header">
        <div class="logo">⭕ Circles</div>
        <div class="tagline">Who do you want to hang with?</div>
    </div>
    <div id="circles-list"></div>
    <div id="no-circles-message" style="display: none; text-align: center; padding: 40px 20px; color: #666;">
        <div style="font-size: 3em; margin-bottom: 20px;">👥</div>
        <h3 style="margin-bottom: 15px; color: #333;">No Circles Yet</h3>
        <p style="margin-bottom: 25px; line-height: 1.6;">
            Circles are your friend groups. Create one to start coordinating activities, or join an existing circle with an invite code.
        </p>
    </div>
    <button class="btn" onclick="showCreateCircle()">Create New Circle</button>
    <button class="btn btn-secondary" onclick="showJoinCircle()">Join Circle</button>
</div>
            <div id="activities" class="page">
    <div class="header">
        <div class="logo">⭕ Activities</div>
        <div class="tagline">What do you want to do?</div>
    </div>
    
    <div class="form-group">
    <label for="circle-selector">Select Circle</label>
    <select id="circle-selector" onchange="handleCircleChange()">
        <option value="">Choose a circle...</option>
    </select>
</div>

<div class="form-group">
    <input type="text" id="activity-search" placeholder="🔍 Search for an activity..." onkeyup="handleSearch(event)">
</div>
    <div style="display: flex; gap: 10px; margin-bottom: 20px;">
        <button class="btn btn-secondary btn-small" onclick="openSuggestModal()" style="flex: 1;">💡 Suggest a New Activity</button>
        <button class="btn btn-secondary btn-small" onclick="openManageActivitiesModal()" style="flex: 1;">Manage Activities</button>
    </div>
    
                <div id="frequent-section"><div class="section-title">⭐ Frequently Used</div><div class="frequent-grid" id="frequent-grid"></div></div>
                <div class="section-title">All Activities</div>
                <div class="bulk-controls"><h4>Quick Select</h4><div class="bulk-btn" onclick="selectBulk('food')">Food & Drinks</div><div class="bulk-btn" onclick="selectBulk('active')">Active</div><div class="bulk-btn" onclick="selectBulk('entertainment')">Entertainment</div><div class="bulk-btn" onclick="selectBulk('relax')">Relax & Creative</div><div class="bulk-btn" onclick="selectBulk('clear')">Clear All</div></div>
                <div class="activities-grid" id="activities-grid"></div>
                <button class="btn sticky-save" onclick="saveActivities()">Save Preferences</button>
                
            </div>
            <div id="matches" class="page">
    <div class="header">
        <div class="logo">⭕ Matches</div>
        <div class="tagline">Who else wants to do what you want to do?</div>
        <div style="margin-top: 15px;">
            <label style="display: flex; align-items: center; gap: 8px; font-size: 0.9em; color: #666;">
                <input type="checkbox" id="show-past-events" checked onchange="window.renderMatches()">
                Show past events
            </label>
        </div>
    </div>
    <div id="matches-list"></div>
</div>
            <div id="chat" class="page">
    <div class="chat-container">
        <div class="chat-header">
    <button onclick="showPage('matches')" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 0.85em; margin-right: 10px;">← Back</button>
    <div style="flex: 1;">
        <div id="event-activity-name" style="font-weight: 600; font-size: 1.1em;"></div>
        <div id="event-participants" style="font-size: 0.8em; opacity: 0.8;"></div>
    </div>
    <button onclick="leaveEvent()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 0.85em; margin-right: 8px;">Leave event</button>
    <button id="event-options-btn" onclick="openEventOptionsModal()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 0.85em;">⚙️</button>
</div>
        
        <div id="event-details" style="background: #e6f7ff; padding: 12px 15px; border-bottom: 1px solid #91d5ff; flex-shrink: 0;">
            <div id="event-date" style="font-weight: 500; margin-bottom: 4px; color: #0050b3;"></div>
            <div id="event-location" style="color: #0050b3; font-size: 14px;"></div>
            <div id="event-notes" style="color: #0050b3; font-size: 14px; margin-top: 4px;"></div>
        </div>
        
        <div class="chat-messages" id="chat-messages"></div>
        
        <div class="chat-input">
            <div class="chat-input-top-row">
                <input type="text" id="message-input" placeholder="Type a message..." onkeypress="handleMessageKeyPress(event)">
                <button class="attachment-btn" onclick="sharePhoto()">📷</button>
                <button class="attachment-btn" onclick="shareLocation()">📍</button>
                <button class="attachment-btn" onclick="findNearbyPlaces()">🔍</button>
            </div>
            <button class="btn send-btn" onclick="sendMessage()">Send</button>
        </div>
    </div>
</div>
            <div id="settings" class="page">
            <div class="header"><div class="logo">⭕ Settings</div><div class="tagline">Manage your preferences</div></div>
    <div style="text-align: center; margin: 40px 0;"><div id="profile-avatar" style="font-size: 2em; margin: 0 auto 20px;">😊</div><h2 id="profile-name">Your Name</h2></div>
    
    <div class="form-group">
        <label for="min-group-size">Minimum Group Size</label>
        <select id="min-group-size" onchange="saveMinimumGroupSize()">
            <option value="2">Any size (including 1-on-1)</option>
            <option value="3">At least 3 people</option>
            <option value="4">At least 4 people</option>
            <option value="5">At least 5 people</option>
        </select>
        <div style="font-size: 0.85em; color: #666; margin-top: 5px;">Only show matches with at least this many total participants</div>
    </div>
    
    <div class="form-group">
        <label for="new-username">Change Display Name</label>
        <input type="text" id="new-username" placeholder="Enter new name">
    </div>
    <button class="btn btn-secondary" onclick="changeUsername()">Update Name</button>
    
    <div class="form-group">
        <label for="new-password">Change Password</label>
        <input type="password" id="new-password" placeholder="New password (6+ characters)">
        <input type="password" id="confirm-password" placeholder="Confirm new password" style="margin-top: 10px;">
    </div>
    <button class="btn btn-secondary" onclick="changePassword()">Update Password</button>
    
    <button class="btn btn-secondary" onclick="signOut()">Sign Out</button>
    <button class="btn btn-secondary" onclick="exportData()">Export My Data</button>
    <button class="btn btn-secondary" onclick="resetApp()" style="background: #dc3545; color: white;">Reset App</button>
</div>
        </div>
        
        <div class="bottom-nav">
            <div class="nav-item active" onclick="showPage('circles')"><div class="nav-icon">👥</div><div class="nav-label">Circles</div></div>
            <div class="nav-item" onclick="showPage('activities')"><div class="nav-icon">🎯</div><div class="nav-label">Activities</div></div>
            <div class="nav-item" id="matches-nav-item" onclick="showPage('matches')"><div class="nav-icon">💫</div><div class="nav-label">Matches</div><span class="notification-badge"></span></div>
            <div class="nav-item" onclick="showPage('settings')"><div class="nav-icon">⚙️</div><div class="nav-label">Settings</div></div>
        </div>
        
        <div class="modal-overlay" id="image-modal-overlay"><div class="close-modal" onclick="closeImageModal()">×</div><div class="modal-content modal-image-content"><img class="modal-image" id="modal-image" src="" alt=""></div></div>
        <div class="modal-overlay" id="circle-modal-overlay"><div class="modal-content"><span class="close-modal-btn" onclick="closeCircleModal()">×</span><div id="create-circle" style="display: none;"><div class="modal-header">Create New Circle</div><div class="form-group"><label for="circle-name">Circle Name</label><input type="text" id="circle-name" placeholder="e.g., College Friends"></div><button class="btn" onclick="createCircle()">Create</button></div><div id="join-circle" style="display: none;"><div class="modal-header">Join Circle</div><div class="form-group"><label for="circle-code">Circle Code</label><input type="text" id="circle-code" placeholder="Enter 6-digit code"></div><button class="btn" onclick="joinCircle()">Join</button></div></div></div>
        <div class="modal-overlay" id="suggest-modal-overlay"><div class="modal-content"><span class="close-modal-btn" onclick="closeSuggestModal()">×</span><div class="modal-header">Suggest an Activity</div><div class="form-group"><label for="suggest-name">Activity Name</label><input type="text" id="suggest-name" placeholder="e.g., Go Karting"></div><button class="btn" onclick="suggestActivity()">Suggest</button></div></div>
        <div class="modal-overlay" id="date-modal-overlay"><div class="modal-content"><span class="close-modal-btn" onclick="closeDateModal()">×</span><div class="modal-header">Schedule Activity</div><div class="form-group"><label for="event-date">Date</label><input type="date" id="event-date"></div><button class="btn" onclick="saveEvent()">Save Event</button></div></div>
        <div class="modal-overlay" id="invite-modal-overlay"><div class="modal-content"><span class="close-modal-btn" onclick="closeInviteModal()">×</span><div class="modal-header">Share Invite Link</div><div class="form-group"><label for="invite-link">Copy this link and send it to a friend:</label><input type="text" id="invite-link" readonly></div><button class="btn" onclick="copyInviteLink()">Copy Link</button></div></div>
    
<div class="undo-container" id="undo-container">
                    <span>Selection updated.</span>
                    <button class="undo-btn" onclick="undoLastActivityChange()">Undo</button>
                </div>
<div class="modal-overlay" id="manage-activities-modal-overlay">
    <div class="modal-content">
        <span class="close-modal-btn" onclick="closeManageActivitiesModal()">×</span>
        <div class="modal-header">Manage Activities for This Circle</div>
        <div style="margin-bottom: 15px; font-size: 0.9em; color: #666;">
    Customize which activities appear in your activity selection. Core activities are shown by default - uncheck to hide them. Additional activities are available to add more variety to your options.
</div>
        <div id="manage-activities-grid" class="activities-grid"></div>
        <button class="btn" onclick="saveActivityVisibility()">Save Changes</button>
    </div>
</div>
</div>

<!-- Create Event Modal -->
<div class="modal-overlay" id="create-event-modal">
    <div class="modal-content" style="max-width: 500px;">
        <span class="close-modal-btn" onclick="closeCreateEventModal()">×</span>
        <div class="modal-header">Schedule New Event</div>
        
        <form id="create-event-form">
            <input type="hidden" id="new-event-match-id">
            
            <div class="form-group">
    <label for="new-event-date">Date *</label>
    <input type="date" id="new-event-date" required>
</div>
            
            <div class="form-group">
                <label for="new-event-location">Location</label>
                <input type="text" id="new-event-location" placeholder="Where are you meeting?">
            </div>
            
            <div class="form-group">
                <label for="new-event-notes">Notes</label>
                <textarea id="new-event-notes" rows="3" placeholder="Any additional details..."></textarea>
            </div>
            
            <button type="submit" class="btn">Create Event</button>
        </form>
    </div>
</div>

<!-- Event Options Modal -->
<div class="modal-overlay" id="event-options-modal">
    <div class="modal-content" style="max-width: 400px;">
        <span class="close-modal-btn" onclick="closeEventOptionsModal()">×</span>
        <div class="modal-header">Event Options</div>
        
        <button onclick="editCurrentEvent()" class="btn btn-secondary" style="width: 100%; text-align: left; margin: 5px 0;">
            ✏️ Edit Event Details
        </button>
        <button onclick="markEventCompleted()" class="btn btn-secondary" style="width: 100%; text-align: left; margin: 5px 0;">
            ✅ Mark as Completed
        </button>
        <button onclick="cancelEvent()" class="btn btn-secondary" style="width: 100%; text-align: left; margin: 5px 0;">
            ❌ Cancel Event
        </button>
        <button onclick="deleteEvent()" class="btn btn-secondary" style="width: 100%; text-align: left; margin: 5px 0; background: #dc3545; color: white;">
            🗑️ Delete Event
        </button>
    </div>
</div>

<!-- Edit Event Modal -->
<div class="modal-overlay" id="edit-event-modal">
    <div class="modal-content" style="max-width: 500px;">
        <span class="close-modal-btn" onclick="closeEditEventModal()">×</span>
        <div class="modal-header">Edit Event</div>
        
        <form id="edit-event-form">
            <div class="form-group">
    <label for="edit-event-date">Date *</label>
    <input type="date" id="edit-event-date" required>
</div>
            
            <div class="form-group">
                <label for="edit-event-location">Location</label>
                <input type="text" id="edit-event-location" placeholder="Where are you meeting?">
            </div>
            
            <div class="form-group">
                <label for="edit-event-notes">Notes</label>
                <textarea id="edit-event-notes" rows="3" placeholder="Any additional details..."></textarea>
            </div>
            
            <button type="submit" class="btn">Save Changes</button>
        </form>
    </div>
</div>

<!-- Location Permission Modal -->
<div class="modal-overlay" id="location-permission-modal">
    <div class="modal-content" style="max-width: 400px;">
        <span class="close-modal-btn" onclick="closeLocationPermissionModal()">×</span>
        <div class="modal-header">Location Access Needed</div>
        
        <div style="margin-bottom: 20px; color: #666; line-height: 1.6;">
            <p style="margin-bottom: 15px;">This feature requires access to your location to:</p>
            <ul style="margin: 0; padding-left: 20px;">
                <li style="margin-bottom: 8px;">Share your location with friends</li>
                <li style="margin-bottom: 8px;">Find nearby places for your activities</li>
            </ul>
        </div>
        
        <button class="btn" onclick="requestLocationPermission()">Enable Location</button>
        <button class="btn btn-secondary" onclick="closeLocationPermissionModal()">Not Now</button>
    </div>
</div>

    <script>
        // App State
        let currentUser = null, circles = [], selectedCircle = null, activities = [], lastActivitiesState = [], activityCounts = {}, matches = [], messages = {}, currentChatMatch = null, undoTimeout = null, showingArchivedMessages = false, currentMatchChat = null, matchMessageSubscription = null, allActiveSubscriptions = [], skipAutoLoad = false;


// UUID Generator
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

// Authentication functions
function showRegister() {
    document.getElementById('login-form').style.display = 'none';
    document.getElementById('register-form').style.display = 'block';
}

function showLogin() {
    document.getElementById('register-form').style.display = 'none';
    document.getElementById('login-form').style.display = 'block';
}

window.showWelcomeFromOnboarding = function() {
    document.getElementById('onboarding').classList.remove('active');
    document.getElementById('welcome').classList.add('active');
    
    // If they have an invite code, show registration form instead of login
    const inviteCode = sessionStorage.getItem('pending_invite_code');
    if (inviteCode) {
        showRegister();
    }
}

window.signUp = async function() {
    const email = document.getElementById('register-email').value.trim();
    const password = document.getElementById('register-password').value;
    const name = document.getElementById('register-name').value.trim();
    const selectedAvatar = document.querySelector('#register-form .avatar-option.selected');
    
    if (!email || !password || !name || !selectedAvatar) {
        return showNotification('Please fill in all fields and select an avatar', 'error');
    }
    
    if (password.length < 6) {
        return showNotification('Password must be at least 6 characters', 'error');
    }
    
    try {
        // Sign up with Supabase Auth
        const { data: authData, error: authError } = await supabase.auth.signUp({
            email: email,
            password: password
        });
        
        if (authError) throw authError;
        
        // Create profile with authenticated user ID
        const { data: profileData, error: profileError } = await supabase
            .from('profiles')
            .insert([{
                id: authData.user.id, // Use Supabase Auth user ID
                name: name,
                avatar: selectedAvatar.dataset.avatar
            }])
            .select()
            .single();
        
        if (profileError) throw profileError;
        
        currentUser = profileData;
	// Request notification permission
if ('Notification' in window && Notification.permission === 'default') {
    Notification.requestPermission();
}
        localStorage.setItem('friendle_user', JSON.stringify(currentUser));
        
        showNotification('Account created successfully!');
        showPage('circles');
        updateProfile();
        await processInviteCode();
        
    } catch (error) {
        console.error('Signup error:', error);
        showNotification(error.message || 'Error creating account', 'error');
    }
}

window.signIn = async function() {
    const email = document.getElementById('login-email').value.trim();
    const password = document.getElementById('login-password').value;
    
    if (!email || !password) {
        return showNotification('Please enter email and password', 'error');
    }
    
    try {
        // Sign in with Supabase Auth
        const { data: authData, error: authError } = await supabase.auth.signInWithPassword({
            email: email,
            password: password
        });
        
        if (authError) throw authError;
        
        // Load user profile
        const { data: profileData, error: profileError } = await supabase
            .from('profiles')
            .select('*')
            .eq('id', authData.user.id)
            .single();
        
        if (profileError) throw profileError;
        
        currentUser = profileData;
        localStorage.setItem('friendle_user', JSON.stringify(currentUser));
        
        showNotification('Signed in successfully!');
        showPage('circles');
        updateProfile();
        await processInviteCode();
        
    } catch (error) {
        console.error('Signin error:', error);
        showNotification(error.message || 'Error signing in', 'error');
    }
}

window.signOut = async function() {
    if (!confirm('Are you sure you want to sign out?')) return;
    
    try {
        // Clean up all active subscriptions
        allActiveSubscriptions.forEach(sub => {
            if (sub) supabase.removeChannel(sub);
        });
        allActiveSubscriptions = [];
        
        await supabase.auth.signOut();
        currentUser = null;
        localStorage.removeItem('friendle_user');
        showPage('welcome');
        showNotification('Signed out successfully');
    } catch (error) {
        console.error('Sign out error:', error);
        showNotification('Error signing out', 'error');
    }
}

async function processInviteCode() {
    const inviteCode = sessionStorage.getItem('pending_invite_code');
    if (!inviteCode || !currentUser) return;
    
    try {
        // Find circle by code
        const { data: circle, error: circleError } = await supabase
            .from('circles')
            .select('*')
            .eq('code', inviteCode)
            .single();
        
        if (circleError || !circle) {
            showNotification('Invalid invite code', 'error');
            sessionStorage.removeItem('pending_invite_code');
            return;
        }
        
        // Check if user is already a member
        const { data: existingMember } = await supabase
            .from('circle_members')
            .select('*')
            .eq('circle_id', circle.id)
            .eq('profile_id', currentUser.id)
            .single();
        
        if (existingMember) {
            showNotification('You are already a member of this circle');
            sessionStorage.removeItem('pending_invite_code');
            return;
        }
        
        // Add user to circle
        const { error: joinError } = await supabase
            .from('circle_members')
            .insert([{ circle_id: circle.id, profile_id: currentUser.id }]);
        
        if (joinError) throw joinError;
        
        showNotification('Successfully joined "' + circle.name + '"!');
        renderCircles(); // Refresh circles display
        sessionStorage.removeItem('pending_invite_code');
        
    } catch (error) {
        console.error('Error processing invite:', error);
        showNotification('Error joining circle', 'error');
        sessionStorage.removeItem('pending_invite_code');
    }
}

        // Utility Functions
        function generateCode() { return Math.floor(100000 + Math.random() * 900000).toString(); }
        function showNotification(message, type = 'success') { /* ... */ }

        // Profile Management & Avatar Selection
       window.createProfile = async function() {
  const name = document.getElementById('name').value.trim();
  const selectedAvatar = document.querySelector('.avatar-option.selected');
  if (!name || !selectedAvatar) {
    return showNotification('Please enter a name and select an avatar', 'error');
  }

  // Create profile object with UUID
  const profileData = {
    id: generateUUID(), // Use UUID instead of letting Supabase auto-generate
    name, 
    avatar: selectedAvatar.dataset.avatar
  };

  // Insert into Supabase
  const { data, error } = await supabase
    .from('profiles')
    .insert([profileData])
    .select()
    .single();

  if (error) {
    console.error(error);
    return showNotification('Could not create profile', 'error');
  }

  currentUser = data; // store the profile from DB
  localStorage.setItem('friendle_user', JSON.stringify(currentUser)); // keep local copy for session
  showPage('circles');
  updateProfile();
  processInvite();
}

        function updateProfile() { if (currentUser) { document.getElementById('profile-name').textContent = currentUser.name; document.getElementById('profile-avatar').textContent = currentUser.avatar;
loadMinimumGroupSize(); 
	}
}

async function loadMinimumGroupSize() {
    if (!currentUser) return;
    
    const select = document.getElementById('min-group-size');
    if (select) {
        select.value = currentUser.minimum_group_size || 2;
    }
}

window.saveMinimumGroupSize = async function() {
    const select = document.getElementById('min-group-size');
    const newValue = parseInt(select.value);
    
    try {
        const { error } = await supabase
            .from('profiles')
            .update({ minimum_group_size: newValue })
            .eq('id', currentUser.id);
        
        if (error) throw error;
        
        currentUser.minimum_group_size = newValue;
        localStorage.setItem('friendle_user', JSON.stringify(currentUser));
        
        showNotification('Group size preference updated!');
        
        // Just reload matches (don't call checkForMatches which re-adds you to everything)
        if (selectedCircle) {
            await loadMatches();
        }
    } catch (error) {
        console.error('Error saving minimum group size:', error);
        showNotification('Error saving preference', 'error');
    }
}

window.changeUsername = async function() {
    const newName = document.getElementById('new-username').value.trim();
    
    if (!newName) {
        return showNotification('Please enter a name', 'error');
    }
    
    try {
        const { error } = await supabase
            .from('profiles')
            .update({ name: newName })
            .eq('id', currentUser.id);
        
        if (error) throw error;
        
        currentUser.name = newName;
        localStorage.setItem('friendle_user', JSON.stringify(currentUser));
        
        updateProfile();
        document.getElementById('new-username').value = '';
        
        showNotification('Name updated successfully!');
        
    } catch (error) {
        console.error('Error changing username:', error);
        showNotification('Error updating name', 'error');
    }
}

window.changePassword = async function() {
    const newPassword = document.getElementById('new-password').value;
    const confirmPassword = document.getElementById('confirm-password').value;
    
    if (!newPassword || !confirmPassword) {
        return showNotification('Please fill in both password fields', 'error');
    }
    
    if (newPassword.length < 6) {
        return showNotification('New password must be at least 6 characters', 'error');
    }
    
    if (newPassword !== confirmPassword) {
        return showNotification('Passwords do not match', 'error');
    }
    
    try {
        const { error } = await supabase.auth.updateUser({
            password: newPassword
        });
        
        if (error) throw error;
        
        document.getElementById('new-password').value = '';
        document.getElementById('confirm-password').value = '';
        
        showNotification('Password updated successfully!');
        
    } catch (error) {
        console.error('Error changing password:', error);
        showNotification(error.message || 'Error updating password', 'error');
    }
}

        document.querySelectorAll('.avatar-option').forEach(option => {
            option.addEventListener('click', function() {
                document.querySelectorAll('.avatar-option').forEach(o => o.classList.remove('selected'));
                this.classList.add('selected');
            });
        });

        // Circle Management
        window.showCreateCircle = () => { document.getElementById('create-circle').style.display = 'block'; document.getElementById('circle-modal-overlay').style.display = 'flex'; };
        window.showJoinCircle = () => { document.getElementById('join-circle').style.display = 'block'; document.getElementById('circle-modal-overlay').style.display = 'flex'; };
        window.closeCircleModal = () => { document.getElementById('circle-modal-overlay').style.display = 'none'; document.getElementById('create-circle').style.display = 'none'; document.getElementById('join-circle').style.display = 'none'; };
        window.createCircle = async function() {
  const name = document.getElementById('circle-name').value.trim();
  if (!name) return;

  const code = generateCode();

  // Insert into circles
  const { data: circle, error } = await supabase
    .from('circles')
    .insert([{ name, code, created_by: currentUser.id }])
    .select()
    .single();

  if (error) {
    console.error(error);
    return showNotification('Could not create circle', 'error');
  }

  // Add creator as a member
  await supabase.from('circle_members').insert([{ circle_id: circle.id, profile_id: currentUser.id }]);

  circles.push(circle);
  closeCircleModal();
  renderCircles();
  showNotification(`Circle created! Share code: ${circle.code}`);
}

        
        window.joinCircle = async function() {
  const code = document.getElementById('circle-code').value.trim();
  if (!code) return;

  // Find the circle by code
  const { data: circle, error } = await supabase
    .from('circles')
    .select('*')
    .eq('code', code)
    .single();

  if (error || !circle) {
    return showNotification('Circle not found', 'error');
  }

  // Add user to circle_members
  await supabase.from('circle_members').insert([{ circle_id: circle.id, profile_id: currentUser.id }]);

  circles.push(circle);
  closeCircleModal();
  renderCircles();
  showNotification(`Joined Circle!`);
}

        async function renderCircles() {
  try {
    // Get circles with member counts
    const { data, error } = await supabase
      .from('circle_members')
      .select(`
        circle_id, 
        circles(*),
        profile_id
      `)
      .eq('profile_id', currentUser.id);

    if (error) throw error;

    circles = data.map(d => d.circles);

    // Get member counts for each circle
    const circleIds = circles.map(c => c.id);
    const { data: memberCounts, error: countError } = await supabase
      .from('circle_members')
      .select('circle_id')
      .in('circle_id', circleIds);

    if (countError) throw countError;

    // Count members per circle
    const counts = {};
    memberCounts.forEach(member => {
      counts[member.circle_id] = (counts[member.circle_id] || 0) + 1;
    });

    const list = document.getElementById('circles-list');
    list.innerHTML = circles.map(circle => {
      const memberCount = counts[circle.id] || 0;
      const memberText = memberCount === 1 ? '1 member' : `${memberCount} members`;
      
      return `
        <div class="circle-card">
          <div class="main-content" onclick='selectCircle("${circle.id}")'>
            <div class="circle-name">${circle.name}</div>
            <div class="circle-members">${memberText}</div>
            <div class="circle-code">Invite Code: <strong>${circle.code}</strong></div>
          </div>
          <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 10px;">
    <div style="display: flex; gap: 8px;">
        <button class="btn btn-small btn-secondary" onclick="event.stopPropagation(); copyCircleCode('${circle.code}')" style="flex: 1;">Copy Code</button>
        <button class="btn btn-small btn-secondary" onclick="event.stopPropagation(); inviteByEmail('${circle.name}', '${circle.code}')" style="flex: 1;">Invite</button>
    </div>
    <div style="display: flex; gap: 8px;">
        <button class="btn btn-small btn-secondary" onclick="event.stopPropagation(); renameCircle('${circle.id}')" style="flex: 1;">Rename</button>
        <button class="btn btn-small" onclick="event.stopPropagation(); leaveCircle('${circle.id}')" style="background: #dc3545; flex: 1;">Leave</button>
    </div>
</div>
        </div>`;
    }).join('');
    } catch (error) {
    console.error('Error loading circles:', error);
    circles = [];
  }
}


window.leaveCircle = async function(circleId) {
  if (!confirm("Are you sure you want to leave this circle?")) return;

  // Delete your membership row from circle_members
  const { error } = await supabase
    .from('circle_members')
    .delete()
    .eq('circle_id', circleId)
    .eq('profile_id', currentUser.id);

  if (error) {
    console.error(error);
    return showNotification("Error leaving circle", "error");
  }

  // Refresh circles list
  await renderCircles();
  showNotification("You left the circle.");
};

window.copyCircleCode = function(code) {
    navigator.clipboard.writeText(code).then(() => {
        showNotification('Circle code ' + code + ' copied to clipboard!');
    }).catch(() => {
        const textArea = document.createElement('textarea');
        textArea.value = code;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        showNotification('Circle code ' + code + ' copied to clipboard!');
    });
}

window.inviteByEmail = function(circleName, circleCode) {
    const subject = encodeURIComponent('Join my "' + circleName + '" circle on Friendle');
    const appUrl = 'https://friendle-circles.vercel.app/';
    const inviteUrl = appUrl + '?invite_code=' + circleCode;
    
    const body = encodeURIComponent(
    'Hi! I would like to invite you to join my "' + circleName + '" circle on Friendle.\n\n' +
    'Join us for coffee, hiking, and whatever else comes up.\n\n' +
    'CLICK THIS LINK TO JOIN:\n' +
    inviteUrl + '\n\n' +
    '(Copy and paste the link above into your browser if it does not appear clickable)\n\n' +
    'Or visit ' + appUrl + ' and manually enter code: ' + circleCode + '\n\n' +
    'Looking forward to planning some fun activities together!'
);
    
    const mailtoLink = 'mailto:?subject=' + subject + '&body=' + body;
    window.open(mailtoLink, '_self');
}

window.renameCircle = async function(circleId) {
    const circle = circles.find(c => c.id === circleId);
    const newName = prompt('Enter new circle name:', circle.name);
    
    if (newName && newName.trim() && newName.trim() !== circle.name) {
        try {
            const { error } = await supabase
                .from('circles')
                .update({ name: newName.trim() })
                .eq('id', circleId)
                .eq('created_by', currentUser.id); // Only creator can rename

            if (error) throw error;
            
            showNotification('Circle renamed!');
            renderCircles(); // Refresh the display
        } catch (error) {
            console.error('Error renaming circle:', error);
            showNotification('Error renaming circle', 'error');
        }
    }
}

// Save user preferences to Supabase
async function saveUserPreferences(circleId, selectedActivityIds) {
    try {

        // First, clear existing preferences for this circle
        const { error: deleteError } = await supabase
            .from('preferences')
            .delete()
            .eq('profile_id', currentUser.id)
            .eq('circle_id', circleId);

        if (deleteError) {
            console.error('Delete error:', deleteError);
            throw deleteError;
        }

        // Then insert new preferences (only if there are selections)
        if (selectedActivityIds.length > 0) {
            const preferences = selectedActivityIds.map(activityId => ({
                profile_id: currentUser.id,
                circle_id: circleId,
                activity_id: activityId.toString(),
                selected: true
            }));

            const { error: insertError } = await supabase
                .from('preferences')
                .insert(preferences);

            if (insertError) {
                console.error('Insert error:', insertError);
                throw insertError;
            }
            
            // Verify what was saved
            const { data: verifyData } = await supabase
                .from('preferences')
                .select('activity_id')
                .eq('profile_id', currentUser.id)
                .eq('circle_id', circleId);

        } else {

        }
        
        showNotification('Preferences saved!');
    } catch (error) {
        console.error('Error saving preferences:', error);
        showNotification('Error saving preferences', 'error');
    }
}

// Load user preferences from Supabase
async function loadUserPreferences(circleId) {
    try {
        
        const { data, error } = await supabase
            .from('preferences')
            .select('activity_id')
            .eq('profile_id', currentUser.id)
            .eq('circle_id', circleId)
            .eq('selected', true);

        if (error) throw error;
        
        const activityIds = data.map(pref => pref.activity_id);
        
        return activityIds;
    } catch (error) {
        console.error('Error loading preferences:', error);
        return [];
    }
}

        // In selectCircle, after filtering:
window.selectCircle = async function(circleId) {
    selectedCircle = circles.find(c => c.id === circleId);
    
    localStorage.setItem('friendle_last_circle', circleId);
    
    const savedActivityIds = await loadUserPreferences(selectedCircle.id);
    const allActivities = await loadActivities(selectedCircle.id);
    
    activities = allActivities.filter(activity => savedActivityIds.includes(activity.id));
    
        skipAutoLoad = true;
    showPage('activities');
    
    const selector = document.getElementById('circle-selector');
    if (selector) {
        selector.value = circleId;
    }
    
    renderActivities();
}

async function populateCircleSelector() {
    const selector = document.getElementById('circle-selector');
    if (!selector) return;
    
    selector.innerHTML = '<option value="">Choose a circle...</option>';
    
    circles.forEach(circle => {
        const option = document.createElement('option');
        option.value = circle.id;
        option.textContent = circle.name;
        selector.appendChild(option);
    });
    
    if (skipAutoLoad) {
        skipAutoLoad = false;
        return;
    }
    
    // Auto-select last used circle or first circle
    const lastCircleId = localStorage.getItem('friendle_last_circle');
    if (lastCircleId && circles.find(c => c.id === lastCircleId)) {
        selector.value = lastCircleId;
        await handleCircleChange(false);
    } else if (circles.length > 0) {
        selector.value = circles[0].id;
        await handleCircleChange(false);
    }
}

window.handleCircleChange = async function(shouldScroll = true) {
    const selector = document.getElementById('circle-selector');
    const circleId = selector.value;
    
    if (!circleId) {
        selectedCircle = null;
        activities = [];
        document.getElementById('activities-grid').innerHTML = '';
        document.getElementById('frequent-grid').innerHTML = '';
        document.getElementById('frequent-section').style.display = 'none';
        return;
    }
    
    localStorage.setItem('friendle_last_circle', circleId);
    
    selectedCircle = circles.find(c => c.id === circleId);
    
    const savedActivityIds = await loadUserPreferences(selectedCircle.id);
    const allActivities = await loadActivities(selectedCircle.id);
    
    activities = allActivities.filter(activity => savedActivityIds.includes(activity.id));
    
    renderActivities();
    
    if (shouldScroll) {
        document.getElementById('activity-search').scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
}

async function loadActivities(circleId) {
    try {
        const { data: customActivities, error: activitiesError } = await supabase
            .from('activities')
            .select('*')
            .eq('circle_id', circleId);
        
        if (activitiesError) throw activitiesError;
        
        const { data: circleActivities, error: visibilityError } = await supabase
            .from('circle_activities')
            .select('activity_id, is_visible')
            .eq('circle_id', circleId);
        
        if (visibilityError) throw visibilityError;
        
        const visibilityMap = {};
        circleActivities?.forEach(ca => {
            visibilityMap[ca.activity_id] = ca.is_visible;
        });
        
        const visibleDefaultActivities = defaultActivities.filter(a => {
            if (visibilityMap.hasOwnProperty(a.id)) {
                return visibilityMap[a.id];
            }
            return coreActivityIds.includes(a.id);
        });
        
        return [...visibleDefaultActivities, ...customActivities];
    } catch (error) {
        console.error('Error loading activities:', error);
        return [];
    }
}

let coreActivityIds = [];
let extendedActivityIds = [];
let defaultActivities = [];

async function loadDefaultActivities() {
    try {
        // Load all default activities from database (where circle_id is null)
        const { data, error } = await supabase
            .from('activities')
            .select('*')
            .is('circle_id', null);
        
        if (error) throw error;
        
        defaultActivities = data;
        
        // Split into core and extended based on a category or naming convention
        // For now, let's say activities with IDs < 200 are core (adjust as needed)
        coreActivityIds = data.filter(a => {
            // Define which activities are "core" - adjust these names as needed
            const coreNames = ['Coffee', 'Dinner', 'Drinks', 'Brunch', 'Pizza Night', 'Ice Cream',
                               'Hiking', 'Beach', 'Bowling', 'Walk in the Park',
                               'Movie', 'Trivia Night', 'Arcade', 'Board Games'];
            return coreNames.includes(a.name);
        }).map(a => a.id);
        
        extendedActivityIds = data.filter(a => !coreActivityIds.includes(a.id)).map(a => a.id);
        
        console.log('Loaded default activities:', defaultActivities);
        console.log('Core activity IDs:', coreActivityIds);
        
    } catch (error) {
        console.error('Error loading default activities:', error);
    }
}
        // Activity Management
        async function renderActivities(searchTerm = '') {
     		// Check if no circle is selected
    if (!selectedCircle) {
        document.getElementById('activities-grid').innerHTML = '<div style="text-align: center; padding: 40px 20px; color: #666;"><div style="font-size: 3em; margin-bottom: 20px;">🎯</div><h3 style="margin-bottom: 15px; color: #333;">Select a Circle First</h3><p>Choose a circle from the dropdown above to see available activities.</p></div>';
        document.getElementById('frequent-grid').innerHTML = '';
        document.getElementById('frequent-section').style.display = 'none';
        return;
    }

    const frequentGrid = document.getElementById('frequent-grid');
    const activitiesGrid = document.getElementById('activities-grid');
    frequentGrid.innerHTML = ''; 
    activitiesGrid.innerHTML = '';
    
    const sortedCounts = Object.entries(activityCounts).sort(([,a],[,b]) => b-a);
    const frequentIds = sortedCounts.slice(0, 4).map(([id]) => parseInt(id));
    
    // Load activities from both default + Supabase
    const allPossibleActivities = await loadActivities(selectedCircle.id);
    
    const filteredActivities = allPossibleActivities.filter(a => 
        a.name.toLowerCase().includes(searchTerm.toLowerCase())
    );

    const frequentActivities = filteredActivities.filter(a => frequentIds.includes(a.id));
    document.getElementById('frequent-section').style.display = 
        frequentActivities.length > 0 && !searchTerm ? 'block' : 'none';
    for (const activity of frequentActivities) {
    await createActivityCard(activity, frequentGrid);
}

    const nonFrequentActivities = filteredActivities.filter(a => !frequentIds.includes(a.id));
    for (const activity of nonFrequentActivities) {
    await createActivityCard(activity, activitiesGrid);
}
}
        async function createActivityCard(activity, grid) {
    const card = document.createElement('div');
    card.className = 'activity-card';
    card.dataset.activityId = activity.id;
    
    const isSelected = activities.some(a => a.id === activity.id);
    if (isSelected) card.classList.add('selected');
    
    // Check if marked as "today"
    const isToday = await isActivityAvailableToday(activity.id);
    
    card.innerHTML = `
        <div class="activity-emoji">${activity.emoji}</div>
        <div class="activity-name">${activity.name}</div>
        ${isSelected ? `
    <div style="position: absolute; top: 6px; right: 6px; display: flex; gap: 4px;">
        <div onclick="event.stopPropagation(); setActivityMode('${activity.id}', false);" style="
            background: ${!isToday ? '#667eea' : '#e0e0e0'};
            color: ${!isToday ? 'white' : '#999'};
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.65em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        ">
            ANYTIME
        </div>
        <div onclick="event.stopPropagation(); setActivityMode('${activity.id}', true);" style="
            background: ${isToday ? '#4CAF50' : '#e0e0e0'};
            color: ${isToday ? 'white' : '#999'};
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.65em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        ">
            TODAY
        </div>
    </div>
` : ''}
    `;
    
    card.onclick = (event) => {
        event.stopPropagation();
        toggleActivity(card, activity);
    };
    
    grid.appendChild(card);
}

async function isActivityAvailableToday(activityId) {
    if (!selectedCircle || !currentUser) return false;
    
    try {
        const { data, error } = await supabase
            .from('activity_availability')
            .select('available_until')
            .eq('profile_id', currentUser.id)
            .eq('circle_id', selectedCircle.id)
            .eq('activity_id', activityId.toString())
            .maybeSingle();
        
        if (error) throw error;
        
        // Check if still valid
        if (data && new Date(data.available_until) > new Date()) {
            return true;
        }
        
        // If expired, clean it up
        if (data) {
            await supabase
                .from('activity_availability')
                .delete()
                .eq('profile_id', currentUser.id)
                .eq('circle_id', selectedCircle.id)
                .eq('activity_id', activityId.toString());
        }
        
        return false;
    } catch (error) {
        console.error('Error checking activity availability:', error);
        return false;
    }
}

window.setActivityMode = async function(activityId, isToday) {
    if (!selectedCircle) return;
    
    try {
        if (isToday) {
            // Set to TODAY
            const endOfDay = new Date();
            endOfDay.setHours(23, 59, 59, 999);
            
            await supabase
                .from('activity_availability')
                .upsert({
                    profile_id: currentUser.id,
                    circle_id: selectedCircle.id,
                    activity_id: activityId.toString(),
                    available_until: endOfDay.toISOString()
                }, {
                    onConflict: 'profile_id,circle_id,activity_id'
                });
            
            showNotification('Available for this activity today!');
        } else {
            // Set to ANYTIME (remove from today)
            await supabase
                .from('activity_availability')
                .delete()
                .eq('profile_id', currentUser.id)
                .eq('circle_id', selectedCircle.id)
                .eq('activity_id', activityId.toString());
            
            showNotification('Switched to "Anytime"');
        }
        
        // Refresh the card
        await renderActivities();
        
        // Refresh matches
        await checkForMatches();
        
    } catch (error) {
        console.error('Error setting activity mode:', error);
        showNotification('Error updating availability', 'error');
    }
}

        function toggleActivity(card, activity) {
            lastActivitiesState = [...activities];
            card.classList.toggle('selected');
            const index = activities.findIndex(a => a.id === activity.id);
            if (index > -1) activities.splice(index, 1);
            else activities.push(activity);
        }
        window.handleSearch = (event) => renderActivities(event.target.value);
        window.selectBulk = function(type) {
            lastActivitiesState = [...activities];
            const all = [...defaultActivities, ...(selectedCircle.customActivities || [])];
            activities = type === 'clear' ? [] : all.filter(a => a.category === type);
            renderActivities();
        }
        window.saveActivities = async function() {
    if (!selectedCircle) return showNotification('Please select a circle first', 'error');
    
    const selectedActivityIds = activities.map(activity => activity.id);
        
    // Get previously selected activities to find what was deselected
    const previousPrefs = await loadUserPreferences(selectedCircle.id);
    const deselectedActivityIds = previousPrefs.filter(id => !selectedActivityIds.includes(id));
    
    // For each deselected activity, check if user has any events
    for (const activityId of deselectedActivityIds) {
        // Find the match for this activity
        const { data: match } = await supabase
            .from('matches')
            .select('id')
            .eq('circle_id', selectedCircle.id)
            .eq('activity_id', activityId)
            .single();
        
        if (match) {
            // Check if user has any events for this match
            const { data: userEvents } = await supabase
                .from('event_participants')
                .select('event_id, events!inner(match_id)')
                .eq('profile_id', currentUser.id)
                .eq('events.match_id', match.id);
            
            // If no events, remove user from match participants
            if (!userEvents || userEvents.length === 0) {
                await supabase
                    .from('match_participants')
                    .delete()
                    .eq('match_id', match.id)
                    .eq('profile_id', currentUser.id);
            }
        }
    }
    
    // Save new preferences
    await saveUserPreferences(selectedCircle.id, selectedActivityIds);
    
    activities.forEach(act => { 
        activityCounts[act.id] = (activityCounts[act.id] || 0) + 1; 
    });
    localStorage.setItem('friendle_activity_counts', JSON.stringify(activityCounts));
    
    await checkForMatches();
    await loadMatches(); // ADD THIS LINE - reload matches with proper isUserJoined flags
    
    showPage('matches');
}
        window.openSuggestModal = () => document.getElementById('suggest-modal-overlay').style.display = 'flex';
        window.closeSuggestModal = () => document.getElementById('suggest-modal-overlay').style.display = 'none';
        window.suggestActivity = async function() {
    const name = document.getElementById('suggest-name').value.trim();
    if (!name) { 
        return showNotification('Please provide an activity name', 'error'); 
    }

    try {
        const { data, error } = await supabase
            .from('activities')
            .insert([{
                name: name,
                emoji: '💡', // Always use lightbulb
                category: 'custom',
                circle_id: selectedCircle.id
            }])
            .select()
            .single();

        if (error) throw error;
        
        showNotification(`Activity "${name}" added!`);
        closeSuggestModal();
        
        // Reload user's actual preferences before re-rendering
        const savedActivityIds = await loadUserPreferences(selectedCircle.id);
        const allActivities = await loadActivities(selectedCircle.id);
        activities = allActivities.filter(activity => savedActivityIds.includes(activity.id));
        
        renderActivities();
    } catch (error) {
        console.error('Error adding custom activity:', error);
        showNotification('Error adding activity', 'error');
    }
}
        function showUndo() {
            const undoContainer = document.getElementById('undo-container');
            undoContainer.style.display = 'flex';
            clearTimeout(undoTimeout);
            undoTimeout = setTimeout(() => {
                undoContainer.style.display = 'none';
            }, 8000);
        }
        window.undoLastActivityChange = function() {
            activities = [...lastActivitiesState];
            renderActivities();
            document.getElementById('undo-container').style.display = 'none';
            clearTimeout(undoTimeout);
        }
// Replace your findMatches function with this version:
async function findMatches(circleId) {
    try {
        // Get current user's preferences
        const userPrefs = await loadUserPreferences(circleId);
        if (userPrefs.length === 0) {
            return [];
        }

        const groupMatches = [];

        // For each activity the user likes, find or create a group match
        for (const activityId of userPrefs) {
            
            // Check if a group match already exists for this activity in this circle
            const { data: existingMatches, error: matchError } = await supabase
                .from('matches')
                .select('id, circle_id, activity_id, created_at')
                .eq('circle_id', circleId)
                .eq('activity_id', activityId);

            if (matchError) {
                console.error('Error checking for existing match:', matchError);
                continue;
            }

            const existingMatch = existingMatches?.[0] || null;

            // If match exists, get participants
            if (existingMatch) {
                const { data: participants } = await supabase
                    .from('match_participants')
                    .select('profile_id, profiles(id, name, avatar)')
                    .eq('match_id', existingMatch.id);
                
                existingMatch.match_participants = participants || [];
            }

            let match;

            if (existingMatch) {
                // Group match exists - user will see it and can choose to join
                match = existingMatch;
            } else {
                // Create new group match AND auto-join user (they're first)
                const { data: newMatch, error: createError } = await supabase
                    .from('matches')
                    .insert([{
                        circle_id: circleId,
                        activity_id: activityId
                    }])
                    .select('*, activities(*)')
                    .single();

                if (createError) {
                    console.error('Error creating match:', createError);
                    continue;
                }

                // Auto-add user as first participant
                const { error: participantError } = await supabase
                    .from('match_participants')
                    .insert([{ match_id: newMatch.id, profile_id: currentUser.id }]);

                if (participantError) {
                    console.error('Error auto-adding to match:', participantError);
                } else {
                    console.log('✓ Auto-added as first participant to match', newMatch.id);
                }

                // Verify the insert worked by querying it back
                const { data: verifyParticipant } = await supabase
                    .from('match_participants')
                    .select('profile_id')
                    .eq('match_id', newMatch.id)
                    .eq('profile_id', currentUser.id)
                    .maybeSingle();

                console.log('Verification - participant exists:', !!verifyParticipant);

                match = { ...newMatch, match_participants: [{ profile_id: currentUser.id, profiles: currentUser }] };
            }

            // Get all participants for this match
            const { data: participants, error: participantError } = await supabase
                .from('match_participants')
                .select(`
                    profile_id,
                    profiles(id, name, avatar)
                `)
                .eq('match_id', match.id)
                .neq('profile_id', currentUser.id); // Exclude current user

            if (participantError) {
                console.error('Error loading participants:', participantError);
                continue;
            }

            // Check who marked this specific activity as "today"
            const { data: todayUsers, error: availError } = await supabase
                .from('activity_availability')
                .select('profile_id')
                .eq('circle_id', circleId)
                .eq('activity_id', activityId)
                .gte('available_until', new Date().toISOString())
                .in('profile_id', [currentUser.id, ...participants.map(p => p.profile_id)]);

            if (availError) {
                console.error('Error checking activity availability:', availError);
            }

            const todayUserIds = new Set(todayUsers?.map(a => a.profile_id) || []);
            const isCurrentUserAvailableToday = todayUserIds.has(currentUser.id);

            // Filter to only participants who marked this activity as "today"
            const todayParticipants = participants.filter(p => 
                todayUserIds.has(p.profile_id)
            );

            // Always show match if user has this activity selected (auto-joined)
            groupMatches.push({
                id: match.id,
                isGroupChat: todayParticipants.length > 1,
                circleId: circleId,
                users: todayParticipants.map(p => p.profiles),
                activity: match.activities,
                isRead: false,
                scheduledDate: match.scheduled_date ? new Date(match.scheduled_date) : null,
                isWaiting: !isCurrentUserAvailableToday && todayParticipants.length === 0
            });
        }

        return groupMatches;
    } catch (error) {
        console.error('Error finding matches:', error);
        return [];
    }
}

// Save matches to Supabase
async function saveMatchesToSupabase(matches, circleId) {
    try {
        // Clear existing matches for this user and circle
        await supabase
            .from('matches')
            .delete()
            .eq('circle_id', circleId);

        // Insert new matches
        if (matches.length > 0) {
            const matchData = matches.map(match => ({
                id: match.id,
                circle_id: circleId,
                activity_id: match.activity.id
                // Note: We'll need to modify your matches table structure to store user pairs
            }));

            const { error } = await supabase
                .from('matches')
                .insert(matchData);

            if (error) throw error;
        }
    } catch (error) {
        console.error('Error saving matches:', error);
    }
}
        // Match System
        async function checkForMatches() {
    if (!selectedCircle) return;
    
    // Find real matches based on preferences
    const foundMatches = await findMatches(selectedCircle.id);
    
    // Update global matches array
    matches = foundMatches;
    
    // Save to localStorage for now (we can migrate this later)
    localStorage.setItem('friendle_matches', JSON.stringify(matches));
    
    updateNotificationBadge();

if (matches.length > 0) {
    showNotification(`Found ${matches.length} new matches!`);
    
    // Show browser notification
showNotificationAlert(
    'New Activity Matches!',
    `You have ${matches.length} new friend${matches.length > 1 ? 's' : ''} ready to hang out`,
    null,
    true
);
} else {
    showNotification('No matches found yet. Try selecting more activities or invite more friends!');
}
}

async function loadMatches() {
    
    if (!currentUser) return;
    
    try {
        const userCircles = circles.map(c => c.id);
        
        // Get user's preferences (circle + activity pairs)
        const { data: userPrefs } = await supabase
            .from('preferences')
            .select('activity_id, circle_id')
            .eq('profile_id', currentUser.id)
            .in('circle_id', userCircles);
        
        if (!userPrefs || userPrefs.length === 0) {
            matches = [];
            await displayMatches();
            return;
        }
        
        // Create a Set of "circleId|activityId" strings for filtering
        const prefSet = new Set(userPrefs.map(p => `${p.circle_id}|${p.activity_id}`));
        
        // Get all potential matches
        const activityIds = [...new Set(userPrefs.map(p => p.activity_id))];
        const { data: allMatches, error: matchError } = await supabase
            .from('matches')
            .select('*')
            .in('activity_id', activityIds)
            .in('circle_id', userCircles);
        
        if (matchError) throw matchError;
        
        // Filter to only matches where user has that activity selected in THAT circle
        matches = (allMatches || []).filter(match => 
            prefSet.has(`${match.circle_id}|${match.activity_id}`)
        );
        
        // Get participant names for each match
        for (let match of matches) {
            // Get ALL participants for this match
            const { data: allParticipants, error: participantError } = await supabase
                .from('match_participants')
                .select(`
                    profile_id,
                    profiles(name, avatar)
                `)
                .eq('match_id', match.id);

            if (!participantError && allParticipants) {
                // Check if current user is a participant
                match.isUserJoined = allParticipants.some(p => p.profile_id === currentUser.id);
                
                // Get names of OTHER participants (for display)
                const otherParticipants = allParticipants.filter(p => p.profile_id !== currentUser.id);
                match.participant_names = otherParticipants.map(p => p.profiles.name);
                
                // Check availability logic
                const { data: todayCheck } = await supabase
                    .from('activity_availability')
                    .select('profile_id')
                    .eq('circle_id', match.circle_id)
                    .eq('activity_id', match.activity_id)
                    .eq('profile_id', currentUser.id)
                    .gte('available_until', new Date().toISOString())
                    .maybeSingle();
                
                const isCurrentUserAvailableToday = !!todayCheck;
                const otherParticipantIds = otherParticipants.map(p => p.profile_id);
                
                const { data: othersToday } = await supabase
                    .from('activity_availability')
                    .select('profile_id')
                    .eq('circle_id', match.circle_id)
                    .eq('activity_id', match.activity_id)
                    .in('profile_id', otherParticipantIds)
                    .gte('available_until', new Date().toISOString());
                
                match.isWaiting = isCurrentUserAvailableToday && (!othersToday || othersToday.length === 0);
            } else {
                match.isUserJoined = false;
                match.participant_names = [];
                match.isWaiting = false;
            }
            
            // Load activities if needed
            if (activities.length === 0 || (activities.length > 0 && activities[0].circle_id !== match.circle_id)) {
                const allActivities = await loadActivities(match.circle_id);
                activities = allActivities;
            }
        }
        
        await displayMatches();
        
    } catch (error) {
        console.error('Error loading matches:', error);
    }
}

window.renderMatches = function() {
    const list = document.getElementById('matches-list');
    const showPastEvents = document.getElementById('show-past-events')?.checked ?? true;
    const searchTerm = document.getElementById('matches-search')?.value.toLowerCase() || '';
    
    // Filter matches based on toggle and search
    let filteredMatches = matches;
    
    // This will be updated after we load events - for now just keep all matches
let matchesToShow = filteredMatches;
    
    if (searchTerm) {
        filteredMatches = filteredMatches.filter(match => {
            const userName = match.users.map(u => u.name).join(' ').toLowerCase();
            const activityName = match.activity?.name.toLowerCase() || '';
            return userName.includes(searchTerm) || activityName.includes(searchTerm);
        });
    }
    
    // Filter by minimum group size
    const minGroupSize = currentUser.minimum_group_size || 2;
    filteredMatches = filteredMatches.filter(match => {
        const totalParticipants = match.users.length + 1; // +1 for current user
        return totalParticipants >= minGroupSize;
    });
    
    if (filteredMatches.length === 0) {
        const message = searchTerm ? 
            'No matches found for your search.' :
            (showPastEvents ? 'No matches yet.' : 'No upcoming events. Check "Show past events" to see completed activities.');
        return list.innerHTML = `<div style="text-align: center; margin: 40px 0; color: #666;">${message}</div>`;
    }
    
    list.innerHTML = filteredMatches.map(match => {
        const title = match.isGroupChat ? 
            `${match.activity.name} Group` : 
            `${match.users[0].name} - ${match.activity.name}`;
        
        const members = match.isGroupChat ? 
            `${match.users.length + 1} members` : 
            'Chat ready';

        return `
        <div class="circle-card" onclick='openChat(${JSON.stringify(match)})'>
            <div style="display: flex; align-items: center; gap: 15px;">
                <div style="font-size: 1.5em;">${match.activity.emoji}</div>
                <div style="flex: 1;">
                    <div class="circle-name">${title}</div>
                    <div class="circle-members">${members}</div>
                </div>
                <div style="color: #667eea; font-size: 1.2em;">${!match.isRead ? '🔔' : (match.isGroupChat ? '👥' : '💬')}</div>
            </div>
        </div>`;
    }).join('');
}
        async function displayMatches() {
    const matchesList = document.getElementById('matches-list');
    const showPastEvents = document.getElementById('show-past-events')?.checked ?? true;
    
    if (!matches || matches.length === 0) {
        matchesList.innerHTML = '<p>No matches yet. Select some activities to get started!</p>';
        return;
    }

    if (activities.length === 0 && matches.length > 0) {
        const firstMatch = matches[0];
        const allActivities = await loadActivities(firstMatch.circle_id);
        activities = allActivities;
    }

    const todayActivityIds = new Set();
    if (currentUser && matches.length > 0) {
        const circleId = matches[0].circle_id;
        const { data: todayActivities } = await supabase
            .from('activity_availability')
            .select('activity_id')
            .eq('profile_id', currentUser.id)
            .eq('circle_id', circleId)
            .gte('available_until', new Date().toISOString());
        
        todayActivities?.forEach(a => todayActivityIds.add(a.activity_id.toString()));
}

    let matchesWithEvents = await Promise.all(
    matches.map(async (match) => {
        // Get all events for this match
        const { data: allEvents, error } = await supabase
            .from('events')
            .select(`
                *,
                event_participants(profile_id, status)
            `)
            .eq('match_id', match.id)
            .order('scheduled_date', { ascending: true });
        
        if (error) {
            console.error('Error loading events:', error);
            return { match, events: [] };
        }
        
        // Mark which events user has joined
        const events = (allEvents || []).map(event => ({
            ...event,
            isUserJoined: event.event_participants?.some(p => p.profile_id === currentUser.id)
        }));
        
        return { match, events };
    })
);

// Filter out matches with only past events if toggle is off
if (!showPastEvents) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    matchesWithEvents = matchesWithEvents.filter(({ match, events }) => {
        // Keep if no events exist
        if (!events || events.length === 0) return true;
        
        // Keep if any event is upcoming
        const hasUpcoming = events.some(e => 
            new Date(e.scheduled_date) >= today && e.status === 'scheduled'
        );
        
        return hasUpcoming;
    });
}

    // Pre-load any missing activities
    const missingActivityIds = new Set();
    matchesWithEvents.forEach(({ match }) => {
        if (!activities.find(a => a.id === match.activity_id)) {
            missingActivityIds.add(match.activity_id);
        }
    });
    
    // Fetch missing activities
    const missingActivities = [];
    if (missingActivityIds.size > 0) {
        const { data } = await supabase
            .from('activities')
            .select('*')
            .in('id', Array.from(missingActivityIds));
        if (data) missingActivities.push(...data);
    }
    
    matchesList.innerHTML = matchesWithEvents.map(({ match, events }) => {
        let activity = activities.find(a => a.id === match.activity_id);
        
        // If not in activities array, check pre-loaded missing activities
        if (!activity) {
            activity = missingActivities.find(a => a.id === match.activity_id);
        }
        
        const activityName = activity ? activity.name : 'Unknown Activity';
        const activityEmoji = activity ? activity.emoji : '🎯';
        
        // Compare dates at midnight to include events happening today
const now = new Date();
const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

const upcomingEvents = events.filter(e => 
    new Date(e.scheduled_date) >= today && e.status === 'scheduled'
);
        const pastEvents = events.filter(e => 
            new Date(e.scheduled_date) < today || e.status !== 'scheduled'
        );

        return `
    <div class="match-card" style="margin-bottom: 25px; padding: 20px; background: white; border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 20px;">
        <div style="flex: 1; padding-right: 15px;">
    <h3 style="margin: 0 0 4px 0; font-size: 20px;">${activityEmoji} ${activityName}</h3>
            <p style="margin: 8px 0 0 0; color: #666; font-size: 14px; line-height: 1.4;">
    ${match.isWaiting ? 
        '<span style="color: #ff9800;">You\'re available today! Waiting for others to join...</span>' : 
        (match.participant_names ? 
            (match.participant_names.length <= 3 ? 
                match.participant_names.join(', ') : 
                match.participant_names.slice(0, 3).join(', ') + `, and ${match.participant_names.length - 3} other${match.participant_names.length - 3 > 1 ? 's' : ''}`
            ) : 
            'Loading participants...')
    }
</p>
        </div>
        <div style="display: flex; flex-direction: column; gap: 10px; min-width: 140px; align-items: flex-end;">
    <span style="padding: 4px 10px; background: #e8e8e8; border-radius: 12px; font-size: 12px; font-weight: 500; color: #666;">
        ${circles.find(c => c.id === match.circle_id)?.name || 'Circle'}
    </span>
    ${match.isUserJoined ? `
        <div style="display: flex; gap: 8px; width: 100%;">
            <button id="today-btn-${match.id}" onclick="markActivityAsToday('${match.activity_id}', '${match.id}')" class="btn" style="font-size: 14px; padding: 8px 16px; margin: 0; background: #4CAF50; display: none; flex: 1;">
                ✓ Available Today
            </button>
            <button onclick="openCreateEventModal('${match.id}')" class="btn" style="font-size: 14px; padding: 8px 16px; margin: 0; flex: 1;">
                + Schedule
            </button>
        </div>
        <button onclick="openMatchChat('${match.id}')" class="btn btn-secondary" style="font-size: 14px; padding: 8px 16px; width: 100%; margin: 0;">
    💬 Chat
</button>
    ` : `
        <button onclick="joinMatch('${match.id}')" class="btn" style="font-size: 14px; padding: 12px 16px; width: 100%; margin: 0; background: #4CAF50;">
            ✓ Join Match
        </button>
        <p style="font-size: 12px; color: #666; margin: 0; text-align: center;">Join to chat and schedule events</p>
    `}
</div>
    </div>
                
                ${upcomingEvents.length > 0 ? `
    <div style="margin-bottom: 15px;">
    <h4 style="margin: 0 0 12px 0; font-size: 15px; color: #666; font-weight: 600;">Upcoming</h4>
        ${upcomingEvents.map(event => {
            const date = new Date(event.scheduled_date);
            const dateStr = date.toLocaleDateString('en-US', { 
                weekday: 'short', 
                month: 'short', 
                day: 'numeric'
            });
            
            const participantCount = event.event_participants?.length || 0;
            
            return `
                <div class="event-item" style="padding: 15px; margin-bottom: 10px; background: ${event.isUserJoined ? '#f5f5f5' : '#fff8e1'}; border-radius: 8px; border-left: 4px solid ${event.isUserJoined ? '#4CAF50' : '#FFA726'};">
                    <div style="display: flex; justify-content: space-between; align-items: center; gap: 10px;">
                        <div style="flex: 1;">
    <div style="font-weight: 500; margin-bottom: 6px; font-size: 15px;">📅 ${dateStr}</div>
                            ${event.location ? `<div style="color: #666; font-size: 13px;">📍 ${event.location}</div>` : ''}
                            <div style="color: #666; font-size: 12px; margin-top: 4px;">${participantCount} ${participantCount === 1 ? 'person' : 'people'} ${event.isUserJoined ? 'going' : 'interested'}</div>
                        </div>
                        ${event.isUserJoined ? `
                            <button onclick="event.stopPropagation(); openEventChat('${event.id}');" class="btn btn-secondary" style="font-size: 13px; padding: 6px 12px; width: auto; margin: 0; white-space: nowrap;">
                                💬 Event Chat
                            </button>
                        ` : `
                            <button onclick="event.stopPropagation(); joinEvent('${event.id}');" class="btn" style="font-size: 13px; padding: 6px 12px; width: auto; margin: 0; white-space: nowrap; background: #4CAF50;">
                                ✓ Join Event
                            </button>
                        `}
                    </div>
                </div>
            `;
        }).join('')}
    </div>
` : `
                    <div style="padding: 15px; background: #f9f9f9; border-radius: 6px; text-align: center; color: #666; font-size: 14px; border: 1px dashed #ddd;">
                        💬 No events scheduled yet - schedule something!
                    </div>
                `}
                
                ${pastEvents.length > 0 ? `
                    <details style="margin-top: 10px;">
                        <summary style="cursor: pointer; color: #666; font-size: 14px;">Past Events (${pastEvents.length})</summary>
                        <div style="margin-top: 8px;">
                            ${pastEvents.map(event => {
                                const date = new Date(event.scheduled_date);
                                const dateStr = date.toLocaleDateString('en-US', { 
                                    month: 'short', 
                                    day: 'numeric'
                                });
                                const statusEmoji = event.status === 'completed' ? '✅' : event.status === 'cancelled' ? '❌' : '📅';
                                
                                return `
    <div class="event-item" style="padding: 8px; margin-bottom: 4px; background: #fafafa; border-radius: 4px; opacity: 0.7; font-size: 13px; display: flex; justify-content: space-between; align-items: center;">
        <div>
            ${statusEmoji} ${dateStr}${event.location ? ` · ${event.location}` : ''}
        </div>
        <button onclick="openEventChat('${event.id}')" class="btn btn-secondary" style="font-size: 12px; padding: 4px 8px; width: auto; margin: 0; opacity: 1;">
            Chat
        </button>
    </div>
`;
                            }).join('')}
                        </div>
                    </details>
                ` : ''}
            </div>
        `;
    }).join('');

    // Around line 2016-2024, replace the button visibility logic:
matches.forEach(match => {
    const isToday = todayActivityIds.has(match.activity_id.toString());
    const button = document.getElementById(`today-btn-${match.id}`);
    if (button) {
        button.style.display = isToday ? 'none' : 'inline-block';
    }
});

    document.querySelectorAll('.event-item').forEach(item => {
        item.addEventListener('mouseenter', function() {
            this.style.background = '#e8e8e8';
        });
        item.addEventListener('mouseleave', function() {
            if (this.style.opacity === '0.7') {
                this.style.background = '#fafafa';
            } else {
                this.style.background = '#f5f5f5';
            }
        });
    });
}

window.joinMatch = async function(matchId) {
    try {
        const match = matches.find(m => m.id === matchId);
        if (!match) return;
        
        // Add user to match participants
        const { error } = await supabase
            .from('match_participants')
            .insert([{ 
                match_id: matchId, 
                profile_id: currentUser.id 
            }]);
        
        if (error) throw error;
        
        showNotification('Joined match! You can now chat and schedule events.');
        
        // Refresh matches to update UI
        await loadMatches();
        
    } catch (error) {
        console.error('Error joining match:', error);
        showNotification('Error joining match', 'error');
    }
}

window.joinEvent = async function(eventId) {
    try {
        // Add user to event participants
        const { error } = await supabase
            .from('event_participants')
            .insert([{ 
                event_id: eventId, 
                profile_id: currentUser.id,
                status: 'accepted'
            }]);
        
        if (error) throw error;
        
        showNotification('Joined event! You can now access the event chat.');
        
        // Refresh matches to update UI
        await loadMatches();
        
    } catch (error) {
        console.error('Error joining event:', error);
        showNotification('Error joining event', 'error');
    }
}

window.markActivityAsToday = async function(activityId, matchId) {
    if (!currentUser) return;
    
    try {
        // Find the circle ID from the match
        const match = matches.find(m => m.id === matchId);
        if (!match) return;
        
        // Set activity as available today
        const endOfDay = new Date();
        endOfDay.setHours(23, 59, 59, 999);
        
        await supabase
            .from('activity_availability')
            .upsert({
                profile_id: currentUser.id,
                circle_id: match.circle_id,
                activity_id: activityId.toString(),
                available_until: endOfDay.toISOString()
            }, {
                onConflict: 'profile_id,circle_id,activity_id'
            });
        
        showNotification('Marked as available today!');
        
        // Hide the button immediately
        const button = document.getElementById(`today-btn-${matchId}`);
        if (button) {
            button.style.display = 'none';
        }
        
        // Refresh matches to update participant list
        await loadMatches();
        
    } catch (error) {
        console.error('Error marking activity as today:', error);
        showNotification('Error updating availability', 'error');
    }
}
        
async function sendMessageToSupabase(matchId, content, type = 'text', extraData = {}) {
    try {
        const { data, error } = await supabase
            .from('messages')
            .insert([{
                match_id: matchId,
                sender_id: currentUser.id,
                content: content,
                type: type,
                lat: extraData.lat || null,
                lng: extraData.lng || null
            }])
            .select(`
                *,
                profiles(id, name, avatar)
            `)
            .single();

        if (error) throw error;
        return data;
    } catch (error) {
        console.error('Error sending message:', error);
        return null;
    }
}

// Load messages from Supabase for a match
async function loadMessagesFromSupabase(matchId) {
    try {
        const { data, error } = await supabase
            .from('messages')
            .select(`
                *,
                profiles(id, name, avatar)
            `)
            .eq('match_id', matchId)
            .order('created_at', { ascending: true });

        if (error) throw error;
        return data || [];
    } catch (error) {
        console.error('Error loading messages:', error);
        return [];
    }
}

        // Chat System
        window.openChat = async function(match) {
    currentChatMatch = matches.find(m => m.id === match.id);
    if(currentChatMatch) currentChatMatch.isRead = true;
    
    // Set chat header for group or individual chat
    const chatName = currentChatMatch.isGroupChat ? 
        `${currentChatMatch.activity.name} Group` : 
        currentChatMatch.users[0].name;
    
    const chatAvatar = currentChatMatch.isGroupChat ? 
        currentChatMatch.activity.emoji : 
        currentChatMatch.users[0].avatar;
    
    document.getElementById('chat-name').textContent = chatName;
    document.getElementById('chat-avatar').textContent = chatAvatar;
    
    // Update subtitle for group chats
    const subtitle = currentChatMatch.isGroupChat ? 
        `${currentChatMatch.users.length + 1} members: You, ${currentChatMatch.users.map(u => u.name).join(', ')}` :
        currentChatMatch.activity.name;
    
    document.getElementById('chat-activity').textContent = subtitle;

    // Load messages from Supabase
    const supabaseMessages = await loadMessagesFromSupabase(currentChatMatch.id);
    
    // Convert Supabase messages to your existing format
messages[currentChatMatch.id] = supabaseMessages.map(msg => ({
    id: msg.id,
    sender: msg.profiles.name,
    sender_id: msg.sender_id,  // ADD THIS LINE
    content: msg.content,
    type: msg.type,
    lat: msg.lat,
    lng: msg.lng,
    created_at: msg.created_at,
    isRead: true
}));

    renderChatMessages(); 
    showPage('chat');
    
    // Set up real-time subscription for this chat
    setupRealtimeMessages(currentChatMatch.id);
    
    localStorage.setItem('friendle_current_chat', JSON.stringify(currentChatMatch));
// Messages now loaded from Supabase, no need to cache JSON.stringify(currentChatMatch));    
updateNotificationBadge();
}

window.leaveChat = async function() {
    // Clean up real-time subscription
    cleanupRealtimeMessages();
    localStorage.removeItem('friendle_current_chat');
    
    if (!confirm('Change of plans? You can rejoin by reselecting this activity.')) {
        return;
    }
    
    try {
        // Remove user from match participants
        const { error: deleteError } = await supabase
            .from('match_participants')
            .delete()
            .eq('match_id', currentChatMatch.id)
            .eq('profile_id', currentUser.id);
        
        if (deleteError) throw deleteError;
        
        // Also remove this activity from user's preferences
        const { error: prefError } = await supabase
            .from('preferences')
            .delete()
            .eq('profile_id', currentUser.id)
            .eq('circle_id', currentChatMatch.circleId)
            .eq('activity_id', currentChatMatch.activity.id);
        
        if (prefError) throw prefError;
        
        // Update local activities array to remove this activity
        const activityIndex = activities.findIndex(a => a.id === currentChatMatch.activity.id);
        if (activityIndex > -1) {
            activities.splice(activityIndex, 1);
        }
        
        // Remove from local matches array
        const matchIndex = matches.findIndex(m => m.id === currentChatMatch.id);
        if (matchIndex > -1) {
            matches.splice(matchIndex, 1);
        }
        
        showNotification('You left the chat');
        showPage('matches');
        renderMatches();
        
    } catch (error) {
        console.error('Error leaving chat:', error);
        showNotification('Error leaving chat', 'error');
    }
}
        function renderChatMessages() {
    const chatMessages = document.getElementById('chat-messages');
    chatMessages.innerHTML = '';
    (messages[currentChatMatch.id] || []).forEach(msg => {
        const div = document.createElement('div');
        
        // Determine if this message is from current user by comparing IDs
        const isOwnMessage = msg.sender_id === currentUser.id;
        
        div.className = `message ${isOwnMessage ? 'own' : ''} ${msg.type === 'system' ? 'system' : ''}`;
        let bubble = '';
        if (msg.type === 'photo') bubble = `<img src="${msg.content}" class="message-photo" onclick="openImageModal('${msg.content}')">`;
        else if (msg.type === 'location') bubble = `<div class="message-location" onclick="openMap(${msg.lat}, ${msg.lng})">📍 Location Shared</div>`;
        else if (msg.type === 'text') bubble = `<div class="message-bubble">${msg.content}</div>`;
        else { div.textContent = msg.content; }
        
        if (msg.type !== 'system') {
            const senderName = isOwnMessage ? 'You' : msg.sender;
            const avatar = isOwnMessage ? currentUser.avatar : (currentChatMatch.users.find(u => u.name === msg.sender)?.avatar || '👤');
            
            const timestamp = msg.created_at ? 
                new Date(msg.created_at + 'Z').toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';

            div.innerHTML = `
                <div class="message-avatar">${avatar}</div>
                <div class="message-content">
                    <div class="message-sender">${senderName}${timestamp ? '<span class="message-timestamp">' + timestamp + '</span>' : ''}</div>
                    ${bubble}
                </div>`;
            
            // Add message actions using DOM manipulation for own messages
            if (isOwnMessage) {
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'message-actions';
                
                const actionsBtn = document.createElement('button');
                actionsBtn.className = 'message-actions-btn';
                actionsBtn.textContent = '...';
                actionsBtn.onclick = () => toggleMessageActions(msg.id);
                
                const actionsMenu = document.createElement('div');
                actionsMenu.className = 'message-actions-menu';
                actionsMenu.id = `menu-${msg.id}`;
                
                const editBtn = document.createElement('button');
                editBtn.textContent = 'Edit';
                editBtn.onclick = () => editMessage(msg.id);
                
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.onclick = () => deleteMessage(msg.id);
                
                actionsMenu.appendChild(editBtn);
                actionsMenu.appendChild(deleteBtn);
                actionsDiv.appendChild(actionsBtn);
                actionsDiv.appendChild(actionsMenu);
                div.appendChild(actionsDiv);
            }
        }
        chatMessages.appendChild(div);
    });
    // Force scroll after DOM updates
setTimeout(() => {
    chatMessages.scrollTop = chatMessages.scrollHeight;
}, 100);
    const banner = document.getElementById('scheduled-event-banner-container');
    banner.innerHTML = currentChatMatch.scheduledDate ? `<div class="scheduled-event-banner">🗓️ Event scheduled for ${new Date(currentChatMatch.scheduledDate).toLocaleDateString()}</div>` : '';
}
        window.sendMessage = async function() {
    const input = document.getElementById('message-input');
    if (!input.value.trim()) return;
    
    // Check if we're in match chat, event chat, or old-style match chat
    if (currentMatchChat || currentEvent) {
        // Use unified message function for both match chat and event chat
        const fakeEvent = { preventDefault: () => {} };
        await sendEventMessage(fakeEvent);
    } else if (currentChatMatch) {
        // Old match chat logic (keep for backward compatibility)
        console.log('Sending message, current user:', currentUser);
        
        const savedMessage = await sendMessageToSupabase(currentChatMatch.id, input.value.trim(), 'text');
        
        if (savedMessage) {
            const message = {
                id: savedMessage.id,
                sender: currentUser.name,
                sender_id: currentUser.id,
                content: savedMessage.content,
                type: savedMessage.type,
                lat: savedMessage.lat,
                lng: savedMessage.lng,
                created_at: savedMessage.created_at,
                isRead: true
            };
            
            if (!messages[currentChatMatch.id]) messages[currentChatMatch.id] = [];
            messages[currentChatMatch.id].push(message);
            
            const channel = supabase.channel(`match_${currentChatMatch.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'new_message',
                payload: {
                    id: savedMessage.id,
                    sender_id: currentUser.id,
                    sender_name: currentUser.name,
                    content: savedMessage.content,
                    type: savedMessage.type,
                    lat: savedMessage.lat,
                    lng: savedMessage.lng,
                    created_at: savedMessage.created_at
                }
            });

            renderChatMessages();
        }
        
        input.value = '';
    }
}
        async function addMessage(content, type, extraData = {}) {
    // Send to Supabase
    const savedMessage = await sendMessageToSupabase(currentChatMatch.id, content, type, extraData);
    
    if (savedMessage) {
        // Add to local messages for immediate display
        const message = {
            id: savedMessage.id,
            sender: currentUser.name,
            content: savedMessage.content,
            type: savedMessage.type,
            lat: savedMessage.lat,
            lng: savedMessage.lng,
            isRead: true
        };
        
        if (!messages[currentChatMatch.id]) messages[currentChatMatch.id] = [];
        messages[currentChatMatch.id].push(message);
        
        renderChatMessages();
    }
}
        
        window.handleMessageKeyPress = e => { if (e.key === 'Enter') sendMessage(); };
        window.openDateModal = () => document.getElementById('date-modal-overlay').style.display = 'flex';
        window.closeDateModal = () => document.getElementById('date-modal-overlay').style.display = 'none';
        window.saveEvent = async function() {
    const date = document.getElementById('event-date').value;
    if (!date) return;
    const eventDate = new Date(date.replace(/-/g, '/'));
    
    try {
        // Save to Supabase
        const { error } = await supabase
            .from('matches')
            .update({ scheduled_date: eventDate.toISOString() })
            .eq('id', currentChatMatch.id);

        if (error) throw error;

        // Update local data
        currentChatMatch.scheduledDate = eventDate;
        const matchIndex = matches.findIndex(m => m.id === currentChatMatch.id);
        if (matchIndex > -1) {
            matches[matchIndex].scheduledDate = eventDate;
        }
        
        addMessage(`📅 ${currentUser.name} scheduled this for ${eventDate.toLocaleDateString()}`, 'system');
        closeDateModal();
    } catch (error) {
        console.error('Error saving event:', error);
        showNotification('Error saving event', 'error');
    }
}
        window.toggleMessageActions = function(msgId) {
            const menu = document.getElementById(`menu-${msgId}`);
            menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
        }
window.toggleEventMessageActions = function(msgId) {
    const menu = document.getElementById(`event-menu-${msgId}`);
    if (menu) {
        menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
    }
    
    // Close other open menus
    document.querySelectorAll('.message-actions-menu').forEach(m => {
        if (m.id !== `event-menu-${msgId}`) {
            m.style.display = 'none';
        }
    });
}

window.editEventMessage = async function(msgId, currentContent) {
    // Close the menu
    const menu = document.getElementById(`event-menu-${msgId}`);
    if (menu) menu.style.display = 'none';
    
    // Check if this is a special message type (photo, location, search link)
    if (currentContent.includes('<img') || currentContent.includes('<a')) {
        showNotification('Photos and links cannot be edited, only deleted', 'error');
        return;
    }
    
    const newContent = prompt('Edit your message:', currentContent);
    
    if (!newContent || newContent.trim() === currentContent.trim()) return;
    
    try {
        if (currentMatchChat) {
            const { error } = await supabase
                .from('match_messages')
                .update({ content: newContent.trim() })
                .eq('id', msgId)
                .eq('sender_id', currentUser.id);
            
            if (error) throw error;
            
            const channel = supabase.channel(`match_chat_${currentMatchChat.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'message_edited',
                payload: {
                    id: msgId,
                    content: newContent.trim()
                }
            });
            
            await loadMatchMessages(currentMatchChat.id);
        } else if (currentEvent) {
            const { error } = await supabase
                .from('event_messages')
                .update({ content: newContent.trim() })
                .eq('id', msgId)
                .eq('sender_id', currentUser.id);
            
            if (error) throw error;
            
            const channel = supabase.channel(`event_${currentEvent.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'message_edited',
                payload: {
                    id: msgId,
                    content: newContent.trim()
                }
            });
            
            await loadEventMessages(currentEvent.id, currentEvent.created_at);
        }
        
        showNotification('Message updated');
        
    } catch (error) {
        console.error('Error editing message:', error);
        showNotification('Failed to edit message', 'error');
    }
}

window.deleteEventMessage = async function(msgId) {
    const menu = document.getElementById(`event-menu-${msgId}`);
    if (menu) menu.style.display = 'none';
    
    if (!confirm('Delete this message?')) return;
    
    try {
        if (currentMatchChat) {
            const { error } = await supabase
                .from('match_messages')
                .delete()
                .eq('id', msgId)
                .eq('sender_id', currentUser.id);
            
            if (error) throw error;
            
            const channel = supabase.channel(`match_chat_${currentMatchChat.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'message_deleted',
                payload: {
                    id: msgId
                }
            });
            
            await loadMatchMessages(currentMatchChat.id);
        } else if (currentEvent) {
            const { error } = await supabase
                .from('event_messages')
                .delete()
                .eq('id', msgId)
                .eq('sender_id', currentUser.id);
            
            if (error) throw error;
            
            const channel = supabase.channel(`event_${currentEvent.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'message_deleted',
                payload: {
                    id: msgId
                }
            });
            
            await loadEventMessages(currentEvent.id, currentEvent.created_at);
        }
        
        showNotification('Message deleted');
        
    } catch (error) {
        console.error('Error deleting message:', error);
        showNotification('Failed to delete message', 'error');
    }
}
        window.editMessage = async function(msgId) {
    const message = messages[currentChatMatch.id].find(m => m.id === msgId);
    const newContent = prompt('Edit your message:', message.content);
    if (newContent) {
        try {
            const { error } = await supabase
                .from('messages')
                .update({ content: newContent })
                .eq('id', msgId)
                .eq('sender_id', currentUser.id); // Only allow editing own messages

            if (error) throw error;

            // Update local message
            message.content = newContent;
            localStorage.setItem('friendle_messages', JSON.stringify(messages));
            renderChatMessages();
        } catch (error) {
            console.error('Error editing message:', error);
            showNotification('Error editing message', 'error');
        }
    }
}
        window.deleteMessage = async function(msgId) {
    if (!confirm('Delete this message?')) return;
    
    try {
        const { error } = await supabase
            .from('messages')
            .delete()
            .eq('id', msgId)
            .eq('sender_id', currentUser.id); // Only allow deleting own messages

        if (error) throw error;

        // Remove from local messages
        const index = messages[currentChatMatch.id].findIndex(m => m.id === msgId);
        if (index > -1) {
            messages[currentChatMatch.id].splice(index, 1);
            localStorage.setItem('friendle_messages', JSON.stringify(messages));
            renderChatMessages();
        }
    } catch (error) {
        console.error('Error deleting message:', error);
        showNotification('Error deleting message', 'error');
    }
}

// Global variable to track current event
let currentEvent = null;
let eventMessageSubscription = null;

// Open modal to create new event
function openCreateEventModal(matchId) {
    const match = matches.find(m => m.id === matchId);
    if (!match) return;
    
    document.getElementById('new-event-match-id').value = matchId;
    document.getElementById('create-event-form').reset();
    
    // Set min date to today
    const today = new Date();
    document.getElementById('new-event-date').min = today.toISOString().slice(0, 10);
    
    document.getElementById('create-event-modal').style.display = 'flex';
}

function closeCreateEventModal() {
    document.getElementById('create-event-modal').style.display = 'none';
}

// Create new event
async function createEvent(e) {
    e.preventDefault();
    
    const matchId = document.getElementById('new-event-match-id').value;
    const match = matches.find(m => m.id === matchId);
    
    try {
        // Create the event
        const { data: newEvent, error: eventError } = await supabase
            .from('events')
            .insert({
                match_id: matchId,
                activity_id: match.activity_id,
                circle_id: match.circle_id,
                scheduled_date: document.getElementById('new-event-date').value,
                location: document.getElementById('new-event-location').value || null,
                notes: document.getElementById('new-event-notes').value || null,
                created_by: currentUser.id,
                status: 'scheduled'
            })
            .select()
            .single();
        
        if (eventError) throw eventError;
        
        // Only add the event creator
        const { error: insertError } = await supabase
            .from('event_participants')
            .insert([{
                event_id: newEvent.id,
                profile_id: currentUser.id,
                status: 'accepted'
            }]);
        
        if (insertError) throw insertError;
        
        closeCreateEventModal();
        
        // Refresh matches to show new event
        await loadMatches();
        
        // Open the new event chat
        openEventChat(newEvent.id);
        
    } catch (error) {
        console.error('Error creating event:', error);
        alert('Failed to create event. Please try again.');
    }
}

// Auto-add new users to upcoming events when they join a match
async function autoAddToUpcomingEvents(matchId, newUserId) {
    try {
        // Check auth status
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        console.log('=== AUTH CHECK ===');
        console.log('Auth error:', authError);
        console.log('Authenticated user ID:', user?.id);
        console.log('Target user ID:', newUserId);
        console.log('Match?', user?.id === newUserId);
        
        if (!user) {
            console.error('No authenticated user - RLS will block all queries');
            return;
        }
        
        console.log('=== AUTO-ADD TO UPCOMING EVENTS ===');
        console.log('Match ID:', matchId);
        console.log('New User ID:', newUserId);
        
        // Find all upcoming events for this match
// Use current date in UTC for comparison
const now = new Date();
const todayUTC = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));

console.log('Querying with match_id:', matchId);
console.log('Querying with date >=', todayUTC.toISOString());

// Try the simplest possible query first
const { data: testQuery, error: testError } = await supabase
    .from('events')
    .select('*')
    .eq('match_id', matchId);

console.log('TEST - Simple query for all events in match:');
console.log('Error:', testError);
console.log('Result:', testQuery);

// Now try with filters
const { data: upcomingEvents, error: eventsError } = await supabase
    .from('events')
    .select('id, scheduled_date, location, status')
    .eq('match_id', matchId)
    .eq('status', 'scheduled')
    .gte('scheduled_date', todayUTC.toISOString());

console.log('Query error:', eventsError);
console.log('Query result:', upcomingEvents);

if (eventsError) throw eventsError;

console.log('Comparison date (today UTC):', todayUTC.toISOString());
console.log('Found upcoming events:', upcomingEvents?.length || 0);

// Also check ALL events for this match to see what exists
const { data: allEvents } = await supabase
    .from('events')
    .select('id, scheduled_date, status')
    .eq('match_id', matchId);

console.log('All events for this match:', allEvents);        
        if (upcomingEvents && upcomingEvents.length > 0) {
            // Add user to all upcoming events
            const participantRecords = upcomingEvents.map(event => ({
                event_id: event.id,
                profile_id: newUserId,
                status: 'accepted'
            }));
            
            const { error: insertError } = await supabase
                .from('event_participants')
                .insert(participantRecords);
            
            if (insertError && insertError.code !== '23505') { // Ignore duplicate key errors
                throw insertError;
            }
            
            console.log(`✓ Added user to ${upcomingEvents.length} upcoming event(s)`);
            
            // Notify user they were added to events
            if (upcomingEvents.length === 1) {
                showNotification(`You've been added to an upcoming event!`);
            } else {
                showNotification(`You've been added to ${upcomingEvents.length} upcoming events!`);
            }
        }
    } catch (error) {
        console.error('Error auto-adding to upcoming events:', error);
    }
}

// Open event chat
async function openEventChat(eventId) {
    try {
        // Cleanup previous subscription
        if (eventMessageSubscription) {
            await supabase.removeChannel(eventMessageSubscription);
            eventMessageSubscription = null;
        }
        
        // Load event details
        const { data: event, error: eventError } = await supabase
            .from('events')
            .select(`
                *,
                event_participants(
                    profile_id,
                    status,
                    profiles(id, name, avatar)
                )
            `)
            .eq('id', eventId)
            .single();
        
        if (eventError) throw eventError;
        
// Check if user has joined this event
        const isUserInEvent = event.event_participants?.some(p => p.profile_id === currentUser.id);
        if (!isUserInEvent) {
            showNotification('Please join the event first', 'error');
            return;
        }

        currentEvent = event;
        
        // Get activity details
        const activity = activities.find(a => a.id === event.activity_id);
        
        // Update header
        document.getElementById('event-activity-name').textContent = 
            `${activity ? activity.emoji : '🎯'} ${activity ? activity.name : 'Unknown Activity'}`;
        
        const participantNames = event.event_participants
            .map(p => p.profiles.name)
            .join(', ');
        document.getElementById('event-participants').textContent = participantNames;
        
        // Format and display event details
const eventDate = new Date(event.scheduled_date);
const dateStr = eventDate.toLocaleDateString('en-US', { 
    weekday: 'long',
    month: 'long', 
    day: 'numeric',
    year: 'numeric'
});
        
        document.getElementById('event-date').textContent = `📅 ${dateStr}`;
        document.getElementById('event-location').textContent = 
            event.location ? `📍 ${event.location}` : '';
        document.getElementById('event-notes').textContent = 
            event.notes ? `📝 ${event.notes}` : '';
        
        // Load messages (with archive support)
await loadEventMessages(eventId, event.created_at);
        
        // Set up broadcast subscription for new messages
eventMessageSubscription = supabase
    .channel(`event_${eventId}`)
    .on('broadcast', { event: 'new_message' }, (payload) => {
        console.log('📩 Broadcast message received:', payload);
        
        // Don't duplicate messages we sent ourselves
        if (payload.payload.sender_id === currentUser.id) {
            console.log('⏭️ Skipping own message');
            return;
        }
        
        console.log('🔥 Processing message from another user');
        
        // Create message object with sender info from broadcast
        const message = {
            id: payload.payload.id,
            sender_id: payload.payload.sender_id,
            content: payload.payload.content,
            created_at: payload.payload.created_at,
            sender: {
                id: payload.payload.sender_id,
                name: payload.payload.sender_name,
                avatar: payload.payload.sender_avatar
            }
        };
        
        console.log('Appending message to chat:', message);
        appendMessage(message);
    })
    .on('broadcast', { event: 'message_edited' }, (payload) => {
        console.log('✏️ Message edited:', payload);
        loadEventMessages(currentEvent.id, currentEvent.created_at);
    })
    .on('broadcast', { event: 'message_deleted' }, (payload) => {
        console.log('🗑️ Message deleted:', payload);
        loadEventMessages(currentEvent.id, currentEvent.created_at);
    })
    .subscribe((status) => {
        console.log('Event chat subscription status:', status);
    });

allActiveSubscriptions.push(eventMessageSubscription);
        
        showPage('chat');
        
    } catch (error) {
        console.error('Error loading event chat:', error);
        alert('Failed to load event chat');
    }
}

// Load messages for current event
async function loadEventMessages(eventId, eventCreatedAt) {
    try {
        const { data: messages, error } = await supabase
    .from('event_messages')
    .select(`
        *,
        sender:profiles(id, name, avatar)
    `)
    .eq('event_id', eventId)
    .order('created_at', { ascending: false })
    .limit(50);

// Reverse to show oldest first
if (messages) messages.reverse();
        
        if (error) throw error;
        
        const messagesContainer = document.getElementById('chat-messages');
        messagesContainer.innerHTML = '';
        
        // Split messages into archived (before event) and current (after event)
        const eventCreatedDate = new Date(eventCreatedAt);
        const archivedMessages = messages.filter(m => new Date(m.created_at) < eventCreatedDate);
        const currentMessages = messages.filter(m => new Date(m.created_at) >= eventCreatedDate);
        
        // Show archived messages toggle if any exist
        if (archivedMessages.length > 0) {
            const archiveToggle = document.createElement('div');
            archiveToggle.style.cssText = `
                padding: 10px;
                background: #f0f0f0;
                border-radius: 8px;
                text-align: center;
                margin-bottom: 15px;
                cursor: pointer;
                color: #666;
                font-size: 14px;
                user-select: none;
            `;
            archiveToggle.innerHTML = `
                <span id="archive-toggle-text">📜 Show ${archivedMessages.length} older message${archivedMessages.length > 1 ? 's' : ''} (before event was created)</span>
            `;
            archiveToggle.onclick = () => toggleArchivedMessages(eventId, eventCreatedAt);
            messagesContainer.appendChild(archiveToggle);
            
            // Container for archived messages (hidden by default)
            const archivedContainer = document.createElement('div');
            archivedContainer.id = 'archived-messages';
            archivedContainer.style.display = 'none';
            archivedContainer.style.cssText = `
                border-left: 3px solid #ddd;
                padding-left: 10px;
                margin-bottom: 20px;
                opacity: 0.7;
            `;
            messagesContainer.appendChild(archivedContainer);
            
            // Add archived messages to container
            archivedMessages.forEach(message => {
                appendMessageToContainer(message, archivedContainer);
            });
            
            // Divider
            const divider = document.createElement('div');
            divider.style.cssText = `
                border-top: 2px solid #ddd;
                margin: 20px 0;
                padding-top: 10px;
                text-align: center;
                color: #999;
                font-size: 13px;
            `;
            divider.innerHTML = '📅 Event Created';
            archivedContainer.appendChild(divider);
        }
        
        // Show current messages
        if (currentMessages.length === 0 && archivedMessages.length === 0) {
            messagesContainer.innerHTML += '<p style="text-align: center; color: #999; padding: 20px;">No messages yet. Start the conversation!</p>';
        } else if (currentMessages.length === 0) {
            const placeholder = document.createElement('p');
            placeholder.style.cssText = 'text-align: center; color: #999; padding: 20px;';
            placeholder.textContent = 'No messages since event was created. Say something!';
            messagesContainer.appendChild(placeholder);
        } else {
            currentMessages.forEach(message => appendMessage(message));
        }
        
        // Scroll to bottom
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        
    } catch (error) {
        console.error('Error loading messages:', error);
    }
}

function toggleArchivedMessages(eventId, eventCreatedAt) {
    const archivedContainer = document.getElementById('archived-messages');
    const toggleText = document.getElementById('archive-toggle-text');
    
    showingArchivedMessages = !showingArchivedMessages;
    
    if (showingArchivedMessages) {
        archivedContainer.style.display = 'block';
        toggleText.textContent = '🔼 Hide older messages';
    } else {
        archivedContainer.style.display = 'none';
        const archivedCount = archivedContainer.querySelectorAll('.message').length - 1; // -1 for divider
        toggleText.textContent = `📜 Show ${archivedCount} older message${archivedCount > 1 ? 's' : ''} (before event was created)`;
    }
}

// Helper to append message to specific container
function appendMessageToContainer(message, container) {
    const isOwnMessage = message.sender_id === currentUser.id;
    const messageTime = new Date(message.created_at).toLocaleTimeString('en-US', { 
        hour: 'numeric', 
        minute: '2-digit' 
    });
    
    const messageDiv = document.createElement('div');
    messageDiv.className = 'message';
    messageDiv.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: ${isOwnMessage ? 'flex-end' : 'flex-start'};
        margin-bottom: 15px;
    `;
    
    let onClick = '';
    let content = message.content;
    
    messageDiv.innerHTML = `
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; ${isOwnMessage ? 'flex-direction: row-reverse;' : ''}">
            <div style="width: 32px; height: 32px; border-radius: 50%; background: #e0e0e0; display: flex; align-items: center; justify-content: center; font-size: 18px;">
                ${message.sender.avatar || '👤'}
            </div>
            <span style="font-size: 13px; color: #666; font-weight: 500;">
                ${isOwnMessage ? 'You' : message.sender.name}
            </span>
            <span style="font-size: 11px; color: #999;">
                ${messageTime}
            </span>
        </div>
        <div style="display: flex; gap: 8px; align-items: flex-start; ${isOwnMessage ? 'flex-direction: row-reverse;' : ''}">
            <div ${onClick} style="
    background: ${isOwnMessage ? '#4CAF50' : '#f0f0f0'};
    color: ${isOwnMessage ? 'white' : 'black'};
    padding: 10px 14px;
    border-radius: 12px;
    max-width: 70%;
    word-wrap: break-word;
    overflow-wrap: break-word;
    word-break: normal;
    min-width: fit-content;
">
                ${content}
            </div>
        </div>
    `;
    
    // Add edit/delete for own messages (archived messages are read-only for simplicity)
    
    container.appendChild(messageDiv);
}

function appendMessage(message) {
    const messagesContainer = document.getElementById('chat-messages');
    
    if (messagesContainer.querySelector('p')) {
        messagesContainer.innerHTML = '';
    }
    
    const isOwnMessage = message.sender_id === currentUser.id;
    const messageTime = new Date(message.created_at).toLocaleTimeString('en-US', { 
        hour: 'numeric', 
        minute: '2-digit' 
    });
    
    const messageDiv = document.createElement('div');
    messageDiv.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: ${isOwnMessage ? 'flex-end' : 'flex-start'};
        margin-bottom: 15px;
    `;
    
    messageDiv.innerHTML = `
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; ${isOwnMessage ? 'flex-direction: row-reverse;' : ''}">
            <div style="width: 32px; height: 32px; border-radius: 50%; background: #e0e0e0; display: flex; align-items: center; justify-content: center; font-size: 18px;">
                ${message.sender.avatar || '👤'}
            </div>
            <span style="font-size: 13px; color: #666; font-weight: 500;">
                ${isOwnMessage ? 'You' : message.sender.name}
            </span>
            <span style="font-size: 11px; color: #999;">
                ${messageTime}
            </span>
        </div>
        <div style="display: flex; gap: 8px; align-items: flex-start; ${isOwnMessage ? 'flex-direction: row-reverse;' : ''}">
            <div style="
    background: ${isOwnMessage ? '#4CAF50' : '#f0f0f0'};
    color: ${isOwnMessage ? 'white' : 'black'};
    padding: 10px 14px;
    border-radius: 12px;
    max-width: 70%;
    word-wrap: break-word;
    overflow-wrap: break-word;
    word-break: normal;
    min-width: fit-content;
">
    ${message.content}
</div>
            ${isOwnMessage ? `
    <div class="message-actions" style="position: relative;">
        <button onclick="toggleEventMessageActions('${message.id}')" style="background: none; border: none; color: #aaa; cursor: pointer; font-size: 1.2em; padding: 5px;">⋯</button>
        <div id="event-menu-${message.id}" class="message-actions-menu" style="position: absolute; bottom: 25px; right: 0; background: white; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); display: none; width: 100px; z-index: 10;">
            ${!message.content.includes('<img') && !message.content.includes('<a') ? `<button onclick="editEventMessage('${message.id}', \`${message.content.replace(/`/g, '\\`').replace(/\$/g, '\\$')}\`)" style="display: block; width: 100%; padding: 10px; background: none; border: none; text-align: left; cursor: pointer;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='none'">Edit</button>` : ''}
            <button onclick="deleteEventMessage('${message.id}')" style="display: block; width: 100%; padding: 10px; background: none; border: none; text-align: left; cursor: pointer;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='none'">Delete</button>
        </div>
    </div>
` : ''}
        </div>
    `;
    
    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

// Send message
async function sendEventMessage(e) {
    e.preventDefault();
    
    const input = document.getElementById('message-input');
    const content = input.value.trim();
    
    if (!content) return;
    
    try {
        // Check if we're in match chat or event chat
        if (currentMatchChat) {
            // Match chat
            const { data, error } = await supabase
                .from('match_messages')
                .insert({
                    match_id: currentMatchChat.id,
                    sender_id: currentUser.id,
                    content: content
                })
                .select(`
                    *,
                    sender:profiles(id, name, avatar)
                `)
                .single();
            
            if (error) throw error;
            
            appendMessage(data);
            
            const channel = supabase.channel(`match_chat_${currentMatchChat.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'new_message',
                payload: {
                    id: data.id,
                    sender_id: currentUser.id,
                    sender_name: currentUser.name,
                    sender_avatar: currentUser.avatar,
                    content: data.content,
                    created_at: data.created_at
                }
            });
            
        } else if (currentEvent) {
            // Event chat
            const { data, error } = await supabase
                .from('event_messages')
                .insert({
                    event_id: currentEvent.id,
                    sender_id: currentUser.id,
                    content: content
                })
                .select(`
                    *,
                    sender:profiles(id, name, avatar)
                `)
                .single();
            
            if (error) throw error;
            
            appendMessage(data);
            
            const channel = supabase.channel(`event_${currentEvent.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'new_message',
                payload: {
                    id: data.id,
                    sender_id: currentUser.id,
                    sender_name: currentUser.name,
                    sender_avatar: currentUser.avatar,
                    content: data.content,
                    created_at: data.created_at
                }
            });
        }
        
        input.value = '';
        
    } catch (error) {
        console.error('Error sending message:', error);
        showNotification('Failed to send message', 'error');
    }
}

// Event options functions
function openEventOptionsModal() {
    document.getElementById('event-options-modal').style.display = 'flex';
}

function closeEventOptionsModal() {
    document.getElementById('event-options-modal').style.display = 'none';
}

function editCurrentEvent() {
    closeEventOptionsModal();
    
    // Populate edit form
    const date = new Date(currentEvent.scheduled_date);
    document.getElementById('edit-event-date').value = date.toISOString().slice(0, 10);
    document.getElementById('edit-event-location').value = currentEvent.location || '';
    document.getElementById('edit-event-notes').value = currentEvent.notes || '';
    
    document.getElementById('edit-event-modal').style.display = 'flex';
}

function closeEditEventModal() {
    document.getElementById('edit-event-modal').style.display = 'none';
}

async function saveEventEdits(e) {
    e.preventDefault();
    
    try {
        const { error } = await supabase
            .from('events')
            .update({
                scheduled_date: document.getElementById('edit-event-date').value,
                location: document.getElementById('edit-event-location').value || null,
                notes: document.getElementById('edit-event-notes').value || null
            })
            .eq('id', currentEvent.id);
        
        if (error) throw error;
        
        closeEditEventModal();
        
        // Reload the event
        openEventChat(currentEvent.id);
        
    } catch (error) {
        console.error('Error updating event:', error);
        alert('Failed to update event');
    }
}

async function markEventCompleted() {
    if (!confirm('Mark this event as completed?')) return;
    
    try {
        const { error } = await supabase
            .from('events')
            .update({ status: 'completed' })
            .eq('id', currentEvent.id);
        
        if (error) throw error;
        
        closeEventOptionsModal();
        showPage('matches');
        await loadMatches();
        
    } catch (error) {
        console.error('Error marking event as completed:', error);
        alert('Failed to mark event as completed');
    }
}

async function cancelEvent() {
    if (!confirm('Cancel this event? This will notify all participants.')) return;
    
    try {
        const { error } = await supabase
            .from('events')
            .update({ status: 'cancelled' })
            .eq('id', currentEvent.id);
        
        if (error) throw error;
        
        // Send a system message
        await supabase
            .from('event_messages')
            .insert({
                event_id: currentEvent.id,
                sender_id: currentUser.id,
                content: '❌ This event has been cancelled'
            });
        
        closeEventOptionsModal();
        showPage('matches');
        await loadMatches();
        
    } catch (error) {
        console.error('Error cancelling event:', error);
        alert('Failed to cancel event');
    }
}

async function leaveEvent() {
    if (!confirm('Leave this event? You won\'t receive any more messages.')) return;
    
    try {
        const { error } = await supabase
            .from('event_participants')
            .delete()
            .eq('event_id', currentEvent.id)
            .eq('profile_id', currentUser.id);
        
        if (error) throw error;
        
        closeEventOptionsModal();
        showPage('matches');
        await loadMatches();
        
    } catch (error) {
        console.error('Error leaving event:', error);
        alert('Failed to leave event');
    }
}

async function deleteEvent() {
    if (!confirm('Delete this event permanently? This will remove it for all participants and cannot be undone.')) return;
    
    // Only event creator can delete
    if (currentEvent.created_by !== currentUser.id) {
        alert('Only the event creator can delete this event');
        return;
    }
    
    try {
        const { error } = await supabase
            .from('events')
            .delete()
            .eq('id', currentEvent.id);
        
        if (error) throw error;
        
        closeEventOptionsModal();
        showPage('matches');
        await loadMatches();
        
    } catch (error) {
        console.error('Error deleting event:', error);
        alert('Failed to delete event');
    }
}

// Match Chat Functions
window.openMatchChat = async function(matchId) {
    try {
        // Cleanup previous subscription
        if (matchMessageSubscription) {
            await supabase.removeChannel(matchMessageSubscription);
            matchMessageSubscription = null;
        }
        
        // Find the match
        const match = matches.find(m => m.id === matchId);
        if (!match) {
            showNotification('Match not found', 'error');
            return;
        }
        
// Check if user has joined this match
        if (!match.isUserJoined) {
            showNotification('Please join the match first', 'error');
            return;
        }
        
        currentMatchChat = match;
        
        // Get activity details from database (handles custom activities)
        let activity = activities.find(a => a.id === match.activity_id);
        
        // If not in current activities array, load from database
        if (!activity) {
            const { data: activityData, error: activityError } = await supabase
                .from('activities')
                .select('*')
                .eq('id', match.activity_id)
                .single();
            
            activity = activityData;
        }
        
        // Get all participants
        const { data: participants, error: participantsError } = await supabase
            .from('match_participants')
            .select('profile_id, profiles(id, name, avatar)')
            .eq('match_id', matchId);
        
        if (participantsError) throw participantsError;
        
        // Update header
        const headerText = `${activity ? activity.emoji : '🎯'} ${activity ? activity.name : 'Unknown Activity'}`;
        document.getElementById('event-activity-name').textContent = headerText;
        
        const participantNames = participants
            .map(p => p.profiles.name)
            .join(', ');
        document.getElementById('event-participants').textContent = participantNames;
        
        // Hide event details section for match chat
        document.getElementById('event-details').style.display = 'none';
        
        // Hide event details section for match chat
        document.getElementById('event-details').style.display = 'none';
        
        // Load messages
        await loadMatchMessages(matchId);
        
        // Set up broadcast subscription
        matchMessageSubscription = supabase
            .channel(`match_chat_${matchId}`)
            .on('broadcast', { event: 'new_message' }, (payload) => {
                if (payload.payload.sender_id === currentUser.id) return;
                
                const message = {
                    id: payload.payload.id,
                    sender_id: payload.payload.sender_id,
                    content: payload.payload.content,
                    created_at: payload.payload.created_at,
                    sender: {
                        id: payload.payload.sender_id,
                        name: payload.payload.sender_name,
                        avatar: payload.payload.sender_avatar
                    }
                };
                
                appendMessage(message);
            })
            .on('broadcast', { event: 'message_edited' }, (payload) => {
                loadMatchMessages(currentMatchChat.id);
            })
            .on('broadcast', { event: 'message_deleted' }, (payload) => {
                loadMatchMessages(currentMatchChat.id);
            })
            .subscribe();
    
    allActiveSubscriptions.push(matchMessageSubscription);

    showPage('chat');
        
    } catch (error) {
        console.error('Error loading match chat:', error);
        showNotification('Failed to load chat', 'error');
    }
}

async function loadMatchMessages(matchId) {
    try {
        const { data: messages, error } = await supabase
    .from('match_messages')
    .select(`
        *,
        sender:profiles(id, name, avatar)
    `)
    .eq('match_id', matchId)
    .order('created_at', { ascending: false })
    .limit(50);

// Reverse to show oldest first
if (messages) messages.reverse();
        
        if (error) throw error;
        
        const messagesContainer = document.getElementById('chat-messages');
        messagesContainer.innerHTML = '';
        
        if (messages.length === 0) {
            messagesContainer.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">No messages yet. Start planning your activity!</p>';
        } else {
            messages.forEach(message => appendMessage(message));
        }
        
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        
    } catch (error) {
        console.error('Error loading match messages:', error);
    }
}
        
        // Attachments & Modals
        window.sharePhoto = function() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.capture = 'environment'; // Rear camera
    
    input.onchange = async function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        // Validate file size (max 5MB)
        if (file.size > 5 * 1024 * 1024) {
            return showNotification('Photo too large. Maximum size is 5MB.', 'error');
        }
        
        showNotification('Uploading photo...');
        
        try {
            // Generate unique filename
            const fileExt = file.name.split('.').pop();
            const fileName = `${currentUser.id}/${Date.now()}.${fileExt}`;
            
            // Upload to Supabase Storage
            const { data, error } = await supabase.storage
                .from('chat-photos')
                .upload(fileName, file, {
                    cacheControl: '3600',
                    upsert: false
                });
            
            if (error) throw error;
            
            // Get public URL
            const { data: urlData } = supabase.storage
                .from('chat-photos')
                .getPublicUrl(fileName);
            
            const photoUrl = urlData.publicUrl;
            
            // Send photo message based on chat type
            if (currentMatchChat) {
                // Match chat
                const { data: messageData, error: messageError } = await supabase
                    .from('match_messages')
                    .insert({
                        match_id: currentMatchChat.id,
                        sender_id: currentUser.id,
                        content: `<img src="${photoUrl}" style="max-width: 200px; border-radius: 10px; cursor: pointer;" onclick="openImageModal('${photoUrl}')">`
                    })
                    .select(`
                        *,
                        sender:profiles(id, name, avatar)
                    `)
                    .single();
                
                if (messageError) throw messageError;
                
                appendMessage(messageData);
                
                const channel = supabase.channel(`match_chat_${currentMatchChat.id}`);
                await channel.send({
                    type: 'broadcast',
                    event: 'new_message',
                    payload: {
                        id: messageData.id,
                        sender_id: currentUser.id,
                        sender_name: currentUser.name,
                        sender_avatar: currentUser.avatar,
                        content: messageData.content,
                        created_at: messageData.created_at
                    }
                });
                
            } else if (currentEvent) {
                // Event chat system
                const { data: messageData, error: messageError } = await supabase
                    .from('event_messages')
                    .insert({
                        event_id: currentEvent.id,
                        sender_id: currentUser.id,
                        content: `<img src="${photoUrl}" style="max-width: 200px; border-radius: 10px; cursor: pointer;" onclick="openImageModal('${photoUrl}')">`
                    })
                    .select(`
                        *,
                        sender:profiles(id, name, avatar)
                    `)
                    .single();
                
                if (messageError) throw messageError;
                
                // Append to UI
                appendMessage(messageData);
                
                // Broadcast to other users
                const channel = supabase.channel(`event_${currentEvent.id}`);
                await channel.send({
                    type: 'broadcast',
                    event: 'new_message',
                    payload: {
                        id: messageData.id,
                        sender_id: currentUser.id,
                        sender_name: currentUser.name,
                        sender_avatar: currentUser.avatar,
                        content: messageData.content,
                        created_at: messageData.created_at
                    }
                });
                
            } else if (currentChatMatch) {
                // Old match chat system
                addMessage(photoUrl, 'photo');
            }
            
            showNotification('Photo shared!');
            
        } catch (error) {
            console.error('Error uploading photo:', error);
            showNotification('Failed to upload photo. Please try again.', 'error');
        }
    };
    
    input.click();
}

function openLocationPermissionModal() {
    document.getElementById('location-permission-modal').style.display = 'flex';
}

function closeLocationPermissionModal() {
    document.getElementById('location-permission-modal').style.display = 'none';
}

async function requestLocationPermission() {
    closeLocationPermissionModal();
    
    // Request permission by attempting to get location
    navigator.geolocation.getCurrentPosition(
        (position) => {
            showNotification('Location access enabled!');
            // Store that we have permission
            localStorage.setItem('location_permission_granted', 'true');
        },
        (error) => {
            if (error.code === error.PERMISSION_DENIED) {
                alert('Location access was denied. Please enable it in your browser settings:\n\n1. Click the lock/info icon in the address bar\n2. Find "Location" permissions\n3. Change to "Allow"');
            } else {
                showNotification('Could not access location. Please try again.', 'error');
            }
        }
    );
}

async function checkLocationPermission() {
    // Check if browser supports permissions API
    if (!navigator.permissions) {
        // Fallback: just check if geolocation exists
        return navigator.geolocation ? 'prompt' : 'unsupported';
    }
    
    try {
        const result = await navigator.permissions.query({ name: 'geolocation' });
        return result.state; // 'granted', 'denied', or 'prompt'
    } catch (error) {
        // Safari doesn't support permissions.query for geolocation
        return 'prompt';
    }
}

        window.shareLocation = async function() {
    if (!navigator.geolocation) {
        return showNotification('Geolocation not supported on this device', 'error');
    }
    
    // Check permission first
    const permission = await checkLocationPermission();
    
    if (permission === 'denied') {
        alert('Location access is blocked. Please enable it in your browser settings:\n\n1. Click the lock/info icon in the address bar\n2. Find "Location" permissions\n3. Change to "Allow"\n4. Reload the page');
        return;
    }
    
    if (permission === 'prompt') {
        openLocationPermissionModal();
        return;
    }
    
    // Permission already granted, proceed
    navigator.geolocation.getCurrentPosition(
        async (pos) => {
            const lat = pos.coords.latitude;
            const lng = pos.coords.longitude;
            
            const mapsUrl = `https://www.google.com/maps?q=${lat},${lng}`;
            
            try {
                // Check if we're in match chat, event chat, or old match chat
                if (currentMatchChat) {
                    // Match chat
                    const { data, error } = await supabase
                        .from('match_messages')
                        .insert({
                            match_id: currentMatchChat.id,
                            sender_id: currentUser.id,
                            content: `📍 <a href="${mapsUrl}" target="_blank" rel="noopener noreferrer" style="color: #1e90ff; text-decoration: underline; font-weight: 500;">View Location on Map</a>`
                        })
                        .select(`
                            *,
                            sender:profiles(id, name, avatar)
                        `)
                        .single();
                    
                    if (error) throw error;
                    
                    appendMessage(data);
                    
                    const channel = supabase.channel(`match_chat_${currentMatchChat.id}`);
                    await channel.send({
                        type: 'broadcast',
                        event: 'new_message',
                        payload: {
                            id: data.id,
                            sender_id: currentUser.id,
                            sender_name: currentUser.name,
                            sender_avatar: currentUser.avatar,
                            content: data.content,
                            created_at: data.created_at
                        }
                    });
                    
                    showNotification('Location shared!');
                    
                } else if (currentEvent) {
                    // Event chat system
                    const { data, error } = await supabase
                        .from('event_messages')
                        .insert({
                            event_id: currentEvent.id,
                            sender_id: currentUser.id,
                            content: `📍 <a href="${mapsUrl}" target="_blank" rel="noopener noreferrer" style="color: #1e90ff; text-decoration: underline; font-weight: 500;">View Location on Map</a>`
                        })
                        .select(`
                            *,
                            sender:profiles(id, name, avatar)
                        `)
                        .single();
                    
                    if (error) throw error;
                    
                    appendMessage(data);
                    
                    const channel = supabase.channel(`event_${currentEvent.id}`);
                    await channel.send({
                        type: 'broadcast',
                        event: 'new_message',
                        payload: {
                            id: data.id,
                            sender_id: currentUser.id,
                            sender_name: currentUser.name,
                            sender_avatar: currentUser.avatar,
                            content: data.content,
                            created_at: data.created_at
                        }
                    });
                    
                    showNotification('Location shared!');
                    
                } else if (currentChatMatch) {
                    // Old match chat system
                    addMessage('Location Shared', 'location', { lat, lng });
                    showNotification('Location shared!');
                }
                
            } catch (error) {
                console.error('Error sharing location:', error);
                showNotification('Failed to share location. Please try again.', 'error');
            }
        },
        () => showNotification('Could not get location', 'error')
    );
}
        window.openImageModal = src => { document.getElementById('modal-image').src = src; document.getElementById('image-modal-overlay').style.display = 'flex'; };
        window.closeImageModal = () => document.getElementById('image-modal-overlay').style.display = 'none';
        window.openMap = (lat, lng) => window.open(`https://www.google.com/maps?q=${lat},${lng}`, '_blank');
window.findNearbyPlaces = async function() {
            if (!navigator.geolocation) {
                return showNotification('Geolocation not supported on this device', 'error');
            }
            
            if (!currentEvent && !currentMatchChat) {
                return showNotification('This feature is only available in chats', 'error');
            }
            
            // Check permission first
            const permission = await checkLocationPermission();
            
            if (permission === 'denied') {
                alert('Location access is blocked. Please enable it in your browser settings:\n\n1. Click the lock/info icon in the address bar\n2. Find "Location" permissions\n3. Change to "Allow"\n4. Reload the page');
                return;
            }
            
            if (permission === 'prompt') {
                openLocationPermissionModal();
                return;
            }
            
            // Permission already granted, proceed
            showNotification('Finding nearby places...');
            
            navigator.geolocation.getCurrentPosition(
                async (pos) => {
                    const lat = pos.coords.latitude;
                    const lng = pos.coords.longitude;
                    
                    const activity = activities.find(a => a.id === (currentEvent?.activity_id || currentMatchChat?.activity_id));
                    const activityName = activity ? activity.name : 'restaurants';
                    
                    const searchUrl = `https://www.google.com/maps/search/${encodeURIComponent(activityName)}/@${lat},${lng},15z`;
                    
                    try {
    if (currentMatchChat) {
        const { data, error } = await supabase
            .from('match_messages')
            .insert({
                match_id: currentMatchChat.id,
                sender_id: currentUser.id,
                content: `🔍 <a href="${searchUrl}" target="_blank" rel="noopener noreferrer" style="color: #667eea; text-decoration: underline; font-weight: 500;">Find nearby ${activityName} spots</a>`
            })
            .select(`*, sender:profiles(id, name, avatar)`)
            .single();
        
        if (error) throw error;
        
        appendMessage(data);
        
        const channel = supabase.channel(`match_chat_${currentMatchChat.id}`);
        await channel.send({
            type: 'broadcast',
            event: 'new_message',
            payload: {
                id: data.id,
                sender_id: currentUser.id,
                sender_name: currentUser.name,
                sender_avatar: currentUser.avatar,
                content: data.content,
                created_at: data.created_at
            }
        });
        
        showNotification('Search link shared!');
        
    } else if (currentEvent) {
        const { data, error } = await supabase
            .from('event_messages')
            .insert({
                event_id: currentEvent.id,
                sender_id: currentUser.id,
                content: `🔍 <a href="${searchUrl}" target="_blank" rel="noopener noreferrer" style="color: #667eea; text-decoration: underline; font-weight: 500;">Find nearby ${activityName} spots</a>`
            })
            .select(`*, sender:profiles(id, name, avatar)`)
            .single();
        
        if (error) throw error;
        
        appendMessage(data);
        
        const channel = supabase.channel(`event_${currentEvent.id}`);
        await channel.send({
            type: 'broadcast',
            event: 'new_message',
            payload: {
                id: data.id,
                sender_id: currentUser.id,
                sender_name: currentUser.name,
                sender_avatar: currentUser.avatar,
                content: data.content,
                created_at: data.created_at
            }
        });
        
        showNotification('Search link shared!');
    }
} catch (error) {
                        console.error('Error sharing nearby places:', error);
                        showNotification('Failed to share search. Please try again.', 'error');
                    }
                },
                (error) => {
                    let errorMessage = 'Could not get location';
                    if (error.code === error.PERMISSION_DENIED) {
                        errorMessage = 'Location permission denied. Please enable location access in your browser settings.';
                    } else if (error.code === error.POSITION_UNAVAILABLE) {
                        errorMessage = 'Location information unavailable. Please try again.';
                    } else if (error.code === error.TIMEOUT) {
                        errorMessage = 'Location request timed out. Please try again.';
                    }
                    showNotification(errorMessage, 'error');
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        }
        function updateNotificationBadge() {
            const hasUnread = matches.some(m => !m.isRead) || Object.values(messages).flat().some(msg => !msg.isRead && msg.sender !== currentUser.name);
            document.querySelector('#matches-nav-item .notification-badge').style.display = hasUnread ? 'block' : 'none';
        }
        window.showPage = async function(pageId) {
    // Clean up subscriptions when leaving chat
if (pageId !== 'chat') {
    if (eventMessageSubscription) {
        supabase.removeChannel(eventMessageSubscription);
        const index1 = allActiveSubscriptions.indexOf(eventMessageSubscription);
        if (index1 > -1) allActiveSubscriptions.splice(index1, 1);
        eventMessageSubscription = null;
        currentEvent = null;
    }
    if (matchMessageSubscription) {
        supabase.removeChannel(matchMessageSubscription);
        const index2 = allActiveSubscriptions.indexOf(matchMessageSubscription);
        if (index2 > -1) allActiveSubscriptions.splice(index2, 1);
        matchMessageSubscription = null;
        currentMatchChat = null;
    }
    document.getElementById('event-details').style.display = 'block';
}
    
    // Clear current chat match when leaving chat page
    if (pageId !== 'chat') {
        currentChatMatch = null;
        localStorage.removeItem('friendle_current_chat');
    }
    
    localStorage.setItem('friendle_current_page', pageId);
    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
    document.getElementById(pageId).classList.add('active');
    document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
    document.querySelector(`.nav-item[onclick="showPage('${pageId}')"]`)?.classList.add('active');
    
    if (pageId === 'circles') renderCircles();
if (pageId === 'activities') {
    await populateCircleSelector();
}
if (pageId === 'matches') {
    await loadMatches();
}
}
        window.resetApp = () => { if (confirm('Are you sure?')) { localStorage.clear(); location.reload(); } };
        
        // Invite System
        window.showInviteModal = function(circleId) {
            const baseUrl = window.location.href.split('?')[0];
            const inviteToken = `invite_${circleId}_${Date.now()}`;
            const inviteLink = `${baseUrl}?invite_token=${inviteToken}`;
            document.getElementById('invite-link').value = inviteLink;
            document.getElementById('invite-modal-overlay').style.display = 'flex';
        }
        window.closeInviteModal = () => document.getElementById('invite-modal-overlay').style.display = 'none';
        window.copyInviteLink = function() {
            const linkInput = document.getElementById('invite-link');
            linkInput.select();
            document.execCommand('copy');
            showNotification('Link copied to clipboard!');
        }
        function processInvite() {
            const token = sessionStorage.getItem('pending_invite');
            if (token && currentUser) {
                const allCircles = JSON.parse(localStorage.getItem('friendle_circles') || '[]');
                const circleId = parseInt(token.split('_')[1]);
                const circle = allCircles.find(c => c.id === circleId);
                if (circle && !circle.members.some(m => m.id === currentUser.id)) {
                    circle.members.push(currentUser);
                    localStorage.setItem('friendle_circles', JSON.stringify(allCircles));
                    circles = allCircles; // Make sure our in-memory list is updated
                    showNotification(`Invite accepted! You've joined "${circle.name}".`);
                }
                sessionStorage.removeItem('pending_invite');
                renderCircles(); // Re-render to show the new circle membership
            }
}

        async function initApp() {
    await loadDefaultActivities();
    const urlParams = new URLSearchParams(window.location.search);
    const inviteCode = urlParams.get('invite_code');
    
    // Store invite code for after authentication
    if (inviteCode) {
        sessionStorage.setItem('pending_invite_code', inviteCode);
        // Clean up URL
        window.history.replaceState({}, document.title, window.location.pathname);
    }

    // Check for existing Supabase auth session
    const { data: { session } } = await supabase.auth.getSession();
    
    if (session) {
        // User is authenticated, load their profile
        try {
            const { data: profileData, error } = await supabase
                .from('profiles')
                .select('*')
                .eq('id', session.user.id)
                .single();
            
            if (error) throw error;
            
            currentUser = profileData;
            
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
            
            localStorage.setItem('friendle_user', JSON.stringify(currentUser));
            
            await renderCircles();
            await loadMatches();
            
            const lastPage = localStorage.getItem('friendle_current_page') || 'circles';

            if (lastPage === 'chat') {
                const savedChat = localStorage.getItem('friendle_current_chat');
                if (savedChat) {
                    try {
                        const chatMatch = JSON.parse(savedChat);
                        const foundMatch = matches.find(m => m.id === chatMatch.id);
                        if (foundMatch) {
                            await openChat(foundMatch);
                        } else {
                            showPage('circles');
                        }
                    } catch (e) {
                        console.error('Error restoring chat:', e);
                        showPage('circles');
                    }
                } else {
                    showPage('circles');
                }
            } else if (lastPage === 'activities' && !selectedCircle) {
                showPage('circles');
            } else {
                showPage(lastPage);
            }
            
            updateProfile();
            await processInviteCode();
            
        } catch (error) {
            console.error('Error loading profile:', error);
            await supabase.auth.signOut();
            showOnboarding();
        }
    } else {
        // No authenticated session, show onboarding
        currentUser = null;
        localStorage.removeItem('friendle_user');
        showOnboarding();
    }
}

async function showOnboarding() {
    // Check if there's a pending invite
    const inviteCode = sessionStorage.getItem('pending_invite_code');
    
    if (inviteCode) {
        // Show invite context
        document.getElementById('invite-context').style.display = 'block';
        document.getElementById('generic-pitch').style.display = 'none';
        document.getElementById('onboarding-cta').textContent = 'Join Circle';
        
        // Try to load circle name
        try {
            const { data: circle, error } = await supabase
                .from('circles')
                .select('name')
                .eq('code', inviteCode)
                .single();
            
            if (circle) {
                document.getElementById('invite-circle-name').textContent = `"${circle.name}"`;
            } else {
                document.getElementById('invite-circle-name').textContent = 'this circle';
            }
        } catch (error) {
            console.error('Error loading circle name:', error);
            document.getElementById('invite-circle-name').textContent = 'this circle';
        }
    } else {
        // Show generic pitch
        document.getElementById('invite-context').style.display = 'none';
        document.getElementById('generic-pitch').style.display = 'block';
        document.getElementById('onboarding-cta').textContent = 'Get Started';
    }
    
    showPage('onboarding');
}

// ✅ Run after DOM is ready
document.addEventListener("DOMContentLoaded", () => {
  console.log("DOM ready, attaching avatar clicks...");

  const avatars = document.querySelectorAll(".avatar-option");
  console.log("Found avatars:", avatars.length);

    avatars.forEach(option => {
    option.addEventListener("click", () => {
      console.log("Avatar clicked:", option.dataset.avatar);
      avatars.forEach(o => o.classList.remove("selected"));
      option.classList.add("selected");
    });
  });

const toggle = document.getElementById('show-past-events');
  if (toggle) {
    toggle.addEventListener('change', function() {
      renderMatches();
    });
  }

// Create event form submission
document.getElementById('create-event-form').addEventListener('submit', createEvent);

// Edit event form submission
document.getElementById('edit-event-form').addEventListener('submit', saveEventEdits);

window.openManageActivitiesModal = async function() {
    if (!selectedCircle) return;
    
    try {
        // Get circle-level visibility settings
const { data: circleActivities, error: visibilityError } = await supabase
    .from('circle_activities')
    .select('activity_id, is_visible')
    .eq('circle_id', selectedCircle.id);

if (visibilityError) throw visibilityError;

// Build visibility map - activities not in map use defaults (core=visible, extended=hidden)
const visibilityMap = {};
circleActivities?.forEach(ca => {
    visibilityMap[ca.activity_id] = ca.is_visible;
});
        
        const grid = document.getElementById('manage-activities-grid');
        
        // Create sections for core and extended activities
        grid.innerHTML = `
    <div style="margin-bottom: 30px;">
        <h3 style="margin-bottom: 15px; color: #555; font-size: 1.1em; font-weight: 600; border-bottom: 1px solid #f0f0f0; padding-bottom: 5px;">Core Activities</h3>
        <div class="activities-grid" id="core-activities-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;"></div>
    </div>
    <div>
        <h3 style="margin-bottom: 15px; color: #555; font-size: 1.1em; font-weight: 600; border-bottom: 1px solid #f0f0f0; padding-bottom: 5px;">Additional Activities</h3>
        <div class="activities-grid" id="extended-activities-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;"></div>
    </div>
`;
        
        const coreGrid = document.getElementById('core-activities-grid');
const extendedGrid = document.getElementById('extended-activities-grid');

// Get core activities from defaultActivities array
const coreActivitiesArray = defaultActivities.filter(a => coreActivityIds.includes(a.id));

// Populate core activities
// Populate core activities
coreActivitiesArray.forEach(activity => {
    const card = document.createElement('div');
    // Core activities visible by default unless explicitly set otherwise
    const isVisible = visibilityMap.hasOwnProperty(activity.id) 
        ? visibilityMap[activity.id] 
        : true;
    card.className = `activity-card ${isVisible ? 'selected' : ''}`;
    card.onclick = () => toggleActivityVisibility(card, activity.id);
    card.dataset.activityId = activity.id;
    card.innerHTML = `
        <div class="activity-emoji">${activity.emoji}</div>
        <div class="activity-name">${activity.name}</div>
    `;
    coreGrid.appendChild(card);
});

// Get extended activities from defaultActivities array
const extendedActivitiesArray = defaultActivities.filter(a => extendedActivityIds.includes(a.id));

// Populate extended activities
extendedActivitiesArray.forEach(activity => {
    const card = document.createElement('div');
    // Extended activities hidden by default unless explicitly set otherwise
    const isVisible = visibilityMap.hasOwnProperty(activity.id) 
        ? visibilityMap[activity.id] 
        : false;
    card.className = `activity-card ${isVisible ? 'selected' : ''}`;
    card.onclick = () => toggleActivityVisibility(card, activity.id);
    card.dataset.activityId = activity.id;
    card.innerHTML = `
        <div class="activity-emoji">${activity.emoji}</div>
        <div class="activity-name">${activity.name}</div>
    `;
    extendedGrid.appendChild(card);
});
        
        document.getElementById('manage-activities-modal-overlay').style.display = 'flex';
        
    } catch (error) {
        console.error('Error loading manage activities modal:', error);
    }
}

window.closeManageActivitiesModal = () => {
    document.getElementById('manage-activities-modal-overlay').style.display = 'none';
}

window.toggleActivityVisibility = function(card, activityId) {
    card.classList.toggle('selected');
}

window.saveActivityVisibility = async function() {
    try {
        // Get selected activities from modal
        const selectedCards = document.querySelectorAll('#manage-activities-grid .activity-card.selected');
        const selectedIds = Array.from(selectedCards).map(card => card.dataset.activityId);
        
        // Get all activity IDs
        const allActivityIds = [...coreActivityIds, ...extendedActivityIds];
        
        // Prepare upsert data for all activities
        const visibilityData = allActivityIds.map(activityId => ({
            circle_id: selectedCircle.id,
            activity_id: activityId,
            is_visible: selectedIds.includes(activityId)
        }));
        
        // Upsert to circle_activities table
        const { error } = await supabase
            .from('circle_activities')
            .upsert(visibilityData, { 
                onConflict: 'circle_id,activity_id'
            });
        
        if (error) throw error;
        
        showNotification('Activity preferences updated for all circle members!');
        closeManageActivitiesModal();
        renderActivities();
    } catch (error) {
        console.error('Error saving activity visibility:', error);
        showNotification('Error saving changes', 'error');
    }
}
  initApp(); // start the app
});   // ✅ only one of these, closes document.addEventListener

function showNotificationAlert(title, body) {
        
    if (!('Notification' in window)) {

        return;
    }
    
    if (Notification.permission !== 'granted') {
        return;
    }
    
    try {
        const notification = new Notification(title, {
            body: body,
            tag: 'friendle-message', // Prevents duplicate notifications
            requireInteraction: false,
            silent: false
        });
        
        // Handle notification click
        notification.onclick = function() {
            window.focus();
            notification.close();
        };
        
    } catch (error) {
        console.error('Error creating notification:', error);
    }
}

// Real-time messaging subscription
let messageSubscription = null;

function setupRealtimeMessages(matchId) {
    
    // Clean up existing subscription
    if (messageSubscription) {
        supabase.removeChannel(messageSubscription);
        const index = allActiveSubscriptions.indexOf(messageSubscription);
        if (index > -1) allActiveSubscriptions.splice(index, 1);
    }
    
    // Use Realtime Presence/Broadcast instead of postgres_changes
    messageSubscription = supabase
        .channel(`match_${matchId}`)
        .on('broadcast', { event: 'new_message' }, (payload) => {
            
            // Don't duplicate messages we sent ourselves
            if (payload.payload.sender_id === currentUser.id) {
                return;
            }
            
            // Add to local messages array
            const newMessage = {
                id: payload.payload.id,
                sender: payload.payload.sender_name,
                sender_id: payload.payload.sender_id,
                content: payload.payload.content,
                type: payload.payload.type,
                lat: payload.payload.lat,
                lng: payload.payload.lng,
                created_at: payload.payload.created_at,
                isRead: true
            };
            
            if (!messages[matchId]) messages[matchId] = [];
            messages[matchId].push(newMessage);
            
            // Always attempt notification for new messages
            showNotificationAlert(
                `New message from ${newMessage.sender}`,
                newMessage.content
            );
            
            // Update UI if we're viewing this chat
            if (currentChatMatch && currentChatMatch.id === matchId) {
                renderChatMessages();
            }
          
        })
        .subscribe((status) => {
        });
    
    allActiveSubscriptions.push(messageSubscription);
}

function cleanupRealtimeMessages() {
    if (messageSubscription) {
        supabase.removeChannel(messageSubscription);
        messageSubscription = null;
        console.log('Unsubscribed from messages');
    }
}

// Register service worker for PWA
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/service-worker.js')
      .then(registration => {
        console.log('ServiceWorker registered:', registration);
      })
      .catch(error => {
        console.log('ServiceWorker registration failed:', error);
      });
  });
}

</script>
</body>
</html>