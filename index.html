<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Friendle - Who's in?</title>
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#5b4fc7">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Light Mode Colors */
            --primary-gradient-start: #5b4fc7;
            --primary-gradient-end: #6d3a9f;
            --primary-color: #5b4fc7;
            --primary-hover: #4d41a8;
            --bg-color: #ffffff;
            --bg-secondary: #f8f9fb;
            --text-primary: #1a1a1a;
            --text-secondary: #666666;
            --text-tertiary: #999999;
            --border-color: #e5e7eb;
            --border-hover: #d1d5db;
            --card-bg: #ffffff;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 20px;
            --transition-speed: 0.2s;
        }

        body.dark-mode {
            --primary-gradient-start: #6d5acf;
            --primary-gradient-end: #7d4aaf;
            --primary-color: #7866d9;
            --primary-hover: #8a7ae3;
            --bg-color: #0f0f11;
            --bg-secondary: #1a1a1e;
            --text-primary: #e5e5e7;
            --text-secondary: #a8a8aa;
            --text-tertiary: #6e6e70;
            --border-color: #2a2a2e;
            --border-hover: #3a3a3e;
            --card-bg: #1a1a1e;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.6);
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, var(--primary-gradient-start) 0%, var(--primary-gradient-end) 100%);
            color: var(--text-primary);
            transition: background var(--transition-speed) ease, color var(--transition-speed) ease;
        }

        .app-container {
            max-width: 400px;
            margin: 0 auto;
            background: var(--bg-color);
            height: 100%;
            position: relative;
            box-shadow: var(--shadow-xl);
            display: flex;
            flex-direction: column;
            transition: background var(--transition-speed) ease;
        }

        .page {
            display: none;
            padding: 20px;
            flex: 1;
            overflow-y: auto;
        }

        .page.active {
            display: block;
        }

        .page#chat.active {
            display: flex;
            flex-direction: column;
            padding: 0;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .logo {
            font-size: 2.5em;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary-gradient-start), var(--primary-gradient-end));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }

        .tagline {
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-primary);
        }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 12px 14px;
            border: 2px solid var(--border-color);
            border-radius: var(--radius-md);
            font-size: 16px;
            font-family: inherit;
            background: var(--bg-color);
            color: var(--text-primary);
            transition: border-color var(--transition-speed), box-shadow var(--transition-speed);
        }

        .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(91, 79, 199, 0.1);
        }
        
        #activity-search {
            margin-bottom: 20px;
        }

        .btn {
            width: 100%;
            padding: 14px 20px;
            background: linear-gradient(135deg, var(--primary-gradient-start), var(--primary-gradient-end));
            color: white;
            border: none;
            border-radius: var(--radius-md);
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform var(--transition-speed), box-shadow var(--transition-speed), filter var(--transition-speed);
            margin: 10px 0;
            font-family: inherit;
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
            filter: brightness(1.05);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--border-hover);
            box-shadow: var(--shadow-md);
            filter: none;
        }
        
        .btn-small {
            width: auto;
            padding: 10px 20px;
            font-size: 0.9em;
            margin-top: 0;
        }

        .avatar-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .avatar-option {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid var(--border-color);
            cursor: pointer;
            transition: all var(--transition-speed);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            background: var(--bg-secondary);
        }

        .avatar-option:hover {
            transform: scale(1.08);
            border-color: var(--primary-color);
        }

        .avatar-option.selected {
            border-color: var(--primary-color);
            background: linear-gradient(135deg, var(--primary-gradient-start), var(--primary-gradient-end));
            color: white;
            box-shadow: var(--shadow-md);
        }

        .profile-picture-container {
            position: relative;
            width: 120px;
            height: 120px;
            margin: 0 auto 20px;
            cursor: pointer;
        }

        .profile-picture {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            object-fit: cover;
            border: 4px solid var(--border-color);
            background: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            transition: all var(--transition-speed);
        }

        .profile-picture:hover {
            border-color: var(--primary-color);
            transform: scale(1.05);
        }

        .profile-picture-overlay {
            position: absolute;
            bottom: 0;
            right: 0;
            background: var(--primary-color);
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            border: 3px solid var(--bg-color);
            transition: all var(--transition-speed);
        }

        .profile-picture-overlay:hover {
            background: var(--primary-hover);
            transform: scale(1.1);
        }

        .avatar-display {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }

        .avatar-display.emoji {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            background: var(--bg-secondary);
        }

        .circle-card {
            background: var(--card-bg);
            border-radius: var(--radius-lg);
            padding: 20px;
            margin: 15px 0;
            border: 2px solid var(--border-color);
            transition: all var(--transition-speed);
            box-shadow: var(--shadow-sm);
        }

        .circle-card.unread {
            border: 2px solid #14b8a6;
            background: #ccfbf1;
        }

        body.dark-mode .circle-card.unread {
            background: #134e4a;
        }

        .circle-card .main-content {
            cursor: pointer;
        }

        .circle-card:hover {
            border-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .circle-name {
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--text-primary);
        }

        .circle-members {
            color: var(--text-secondary);
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .circle-code {
            background: var(--bg-secondary);
            padding: 10px;
            border-radius: var(--radius-sm);
            font-size: 0.8em;
            color: var(--text-secondary);
            text-align: center;
            margin-top: 10px;
            border: 1px solid var(--border-color);
        }

        .circle-code strong {
            letter-spacing: 2px;
            font-size: 1.1em;
            color: var(--primary-color);
            font-weight: 600;
        }

        .activities-grid, .frequent-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .section-title {
            font-size: 1.1em;
            font-weight: 600;
            color: var(--text-primary);
            margin: 20px 0 10px;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--border-color);
        }

        .activity-card {
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all var(--transition-speed);
            position: relative;
            box-shadow: var(--shadow-sm);
        }

        .activity-card:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-lg);
            border-color: var(--primary-color);
        }

        .activity-card.selected {
            background: linear-gradient(135deg, var(--primary-gradient-start), var(--primary-gradient-end));
            color: white;
            border-color: var(--primary-color);
            box-shadow: var(--shadow-md);
        }

        body.dark-mode .activity-card {
            background: #1a1a1e !important;
            border-color: #2a2a2e !important;
        }

        body.dark-mode .activity-card:hover {
            border-color: var(--primary-color) !important;
            box-shadow: var(--shadow-lg) !important;
        }

        body.dark-mode .activity-card.selected {
            background: linear-gradient(135deg, var(--primary-gradient-start), var(--primary-gradient-end)) !important;
        }

        .activity-emoji {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .activity-name {
            font-weight: 600;
            font-size: 0.9em;
            color: var(--text-primary);
        }

        /* Match Cards */
        .match-card {
            margin-bottom: 25px;
            padding: 20px;
            background: var(--card-bg);
            border-radius: 12px;
            box-shadow: var(--shadow-sm);
            position: relative;
            border: 1px solid var(--border-color);
        }

        .match-card.unread {
            background: #ccfbf1;
            border: 2px solid #14b8a6;
        }

        body.dark-mode .match-card.unread {
            background: #134e4a;
            border: 2px solid #14b8a6;
        }

        .match-card h3 {
            margin: 0 0 4px 0;
            font-size: 20px;
            color: var(--text-primary);
        }

        .match-card p {
            color: var(--text-secondary);
        }

        .match-info-box {
            background: var(--bg-secondary);
            border: 2px solid var(--primary-color);
            border-radius: 10px;
            padding: 12px;
            text-align: center;
        }

        .match-info-box.warning {
            background: #fff1f0;
            border-color: #ff4d4f;
        }

        body.dark-mode .match-info-box.warning {
            background: #2a1a1a;
            border-color: #ff4d4f;
        }

        .match-info-box p {
            color: var(--text-primary);
        }

        .event-item {
            padding: 15px;
            margin-bottom: 10px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
            position: relative;
        }

        .event-item.pending {
            background: #fff8e1;
            border-left-color: #FFA726;
        }

        body.dark-mode .event-item.pending {
            background: #2a2415;
        }

        .event-item.unread {
            background: #ccfbf1;
            border: 2px solid #14b8a6;
        }

        body.dark-mode .event-item.unread {
            background: #134e4a;
        }

        /* Dark mode styles for upcoming events section */
        body.dark-mode #upcoming-events-section {
            background: var(--bg-secondary) !important;
        }

        body.dark-mode #upcoming-events-section h4 {
            color: var(--text-secondary) !important;
        }

        /* Dark mode styles for event cards */
        body.dark-mode #upcoming-events-section > div[style*="padding: 12px"] {
            background: var(--card-bg) !important;
            border-left-color: var(--primary-color) !important;
        }

        /* Dark mode - joined event cards (blue background becomes darker with primary accent) */
        body.dark-mode #upcoming-events-section > div[style*="rgb(240, 249, 255)"] {
            background: #1a1a2e !important;
            border-left-color: var(--primary-color) !important;
        }

        /* Dark mode - non-joined event cards (yellow background becomes darker neutral) */
        body.dark-mode #upcoming-events-section > div[style*="rgb(255, 248, 225)"] {
            background: var(--card-bg) !important;
            border-left-color: #ff9800 !important;
        }

        /* Dark mode - past event cards */
        body.dark-mode details[style*="background: #f8f9fa"] > div > div[style*="padding: 12px"] {
            background: #1a1a1a !important;
            border-left-color: #4a4a4a !important;
        }

        /* Dark mode - past events section */
        body.dark-mode details[style*="background: #f8f9fa"] {
            background: var(--bg-secondary) !important;
        }

        body.dark-mode details[style*="background: #f8f9fa"] summary {
            color: var(--text-secondary) !important;
        }

        /* Dark mode - event card text colors */
        body.dark-mode #upcoming-events-section div[style*="color: #666"] {
            color: var(--text-secondary) !important;
        }

        body.dark-mode #upcoming-events-section div[style*="font-weight: 600"] {
            color: var(--text-primary) !important;
        }

        /* Dark mode - past event card text colors */
        body.dark-mode details div[style*="color: #666"] {
            color: var(--text-tertiary) !important;
        }

        .event-item div {
            color: var(--text-primary);
        }

        .event-item .event-meta {
            color: var(--text-secondary);
        }

        .circle-tag {
            padding: 4px 10px;
            background: var(--bg-secondary);
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .empty-event-placeholder {
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: 6px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 14px;
            border: 1px dashed var(--border-color);
        }

        .bulk-controls {
            background: var(--bg-secondary);
            padding: 15px;
            border-radius: var(--radius-md);
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }

        .bulk-controls h4 {
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        .bulk-btn {
            display: inline-block;
            padding: 8px 14px;
            margin: 5px 5px 5px 0;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-xl);
            font-size: 0.85em;
            cursor: pointer;
            transition: all var(--transition-speed);
            color: var(--text-primary);
        }

        .bulk-btn:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            transform: translateY(-1px);
        }

        /* Modern Toggle Switch */
        .toggle-container {
            margin-bottom: 20px;
            padding: 16px;
            background: var(--card-bg);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
            transition: all var(--transition-speed);
        }

        .toggle-container:hover {
            border-color: var(--border-hover);
            box-shadow: var(--shadow-sm);
        }

        .toggle-label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
        }

        .toggle-text {
            flex: 1;
        }

        .toggle-title {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .toggle-description {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .toggle-switch {
            position: relative;
            width: 48px;
            height: 28px;
            flex-shrink: 0;
            margin-left: 16px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--border-color);
            transition: 0.3s;
            border-radius: 28px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .toggle-switch input:checked + .toggle-slider {
            background: linear-gradient(135deg, var(--primary-gradient-start), var(--primary-gradient-end));
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        .toggle-switch input:focus + .toggle-slider {
            box-shadow: 0 0 0 3px rgba(91, 79, 199, 0.1);
        }

        /* Empty States */
        .empty-state {
            text-align: center;
            padding: 60px 30px;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-state-title {
            font-size: 1.2em;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .empty-state-description {
            font-size: 0.95em;
            line-height: 1.5;
            color: var(--text-secondary);
        }

        /* Loading Spinner */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        /* Mobile Optimizations */
        @media (max-width: 480px) {
            .btn, .btn-secondary {
                padding: 16px 20px;
                font-size: 16px;
                min-height: 48px; /* Better touch targets */
            }

            .activity-card {
                padding: 24px;
                min-height: 120px;
            }

            .toggle-switch {
                width: 52px;
                height: 32px;
            }

            .toggle-slider:before {
                height: 24px;
                width: 24px;
            }

            .toggle-switch input:checked + .toggle-slider:before {
                transform: translateX(20px);
            }

            .nav-item {
                padding: 8px 0;
            }

            .nav-icon {
                font-size: 1.4em !important;
            }
        }

        /* Smooth scrolling */
        * {
            -webkit-overflow-scrolling: touch;
        }

        /* Prevent text selection on double-tap */
        .activity-card, .circle-card, .nav-item, .btn, .bulk-btn {
            -webkit-tap-highlight-color: rgba(91, 79, 199, 0.1);
            -webkit-touch-callout: none;
            user-select: none;
        }

        /* Allow text selection in inputs and textareas */
        input, textarea, .message-bubble {
            -webkit-touch-callout: default;
            user-select: text;
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .chat-header {
            background: linear-gradient(135deg, var(--primary-gradient-start), var(--primary-gradient-end));
            color: white;
            padding: 15px;
            flex-shrink: 0;
        }

        .chat-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: white;
            color: var(--primary-color);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 10px;
        }
        
        .scheduled-event-banner {
            padding: 10px;
            background-color: #e6f7ff;
            border-bottom: 1px solid #91d5ff;
            text-align: center;
            font-size: 0.9em;
            color: #0050b3;
            flex-shrink: 0;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: var(--bg-secondary);
        }

        .message {
            margin: 15px 0;
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .message-actions {
    position: relative;
}

.message-actions-btn {
    background: none;
    border: none;
    color: #aaa;
    cursor: pointer;
    font-size: 1.2em;
    padding: 5px;
}

.message-actions-menu {
    position: absolute;
    bottom: 25px;
    right: 0;
    background: var(--card-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    display: none;
    width: 100px;
    z-index: 10;
}

.message-actions-menu button {
    display: block;
    width: 100%;
    padding: 10px;
    background: none;
    border: none;
    text-align: left;
    cursor: pointer;
    color: var(--text-primary);
}

.message-actions-menu button:hover {
    background: var(--border-hover);
}

/* Delete button in menu - red color with good contrast */
.message-actions-menu button.delete-btn {
    color: #ef4444;
}

.message-actions-menu button.delete-btn:hover {
    background: rgba(239, 68, 68, 0.1);
}

        .message.own {
            flex-direction: row-reverse;
        }
        
        .message.system {
            justify-content: center;
            font-size: 0.8em;
            color: #888;
            margin: 20px 0;
        }

        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            font-weight: bold;
            flex-shrink: 0;
        }

        .message-content {
            max-width: 80%;
        }

        .message-sender {
            font-size: 0.8em;
            color: var(--text-tertiary);
            margin-bottom: 4px;
            padding: 0 12px;
        }

        .message.own .message-content {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .message-bubble {
            background: var(--card-bg);
            padding: 12px 15px;
            border-radius: var(--radius-lg);
            position: relative;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-color);
        }

        .message.own .message-bubble {
            background: linear-gradient(135deg, var(--primary-gradient-start), var(--primary-gradient-end));
            color: white;
            border-color: transparent;
        }

        .message-photo {
            max-width: 200px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .message-photo:hover {
            transform: scale(1.05);
        }

        .message-location {
            background: #e8f4fd;
            border: 1px solid #bee5eb;
            padding: 10px;
            border-radius: 10px;
            cursor: pointer;
        }
        
        .message-actions {
            position: relative;
        }

        .message-actions-btn {
            background: none;
            border: none;
            color: #aaa;
            cursor: pointer;
            font-size: 1.2em;
            padding: 5px;
        }
        
        .message-actions-menu {
            position: absolute;
            bottom: 25px;
            right: 0;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: none;
            width: 100px;
            z-index: 10;
        }

        .message-actions-menu button {
            display: block;
            width: 100%;
            padding: 10px;
            background: none;
            border: none;
            text-align: left;
            cursor: pointer;
            color: var(--text-primary);
        }
        .message-actions-menu button:hover {
            background: var(--border-hover);
        }

        .chat-input {
            background: white;
            padding: 15px;
            border-top: 1px solid #ddd;
            flex-shrink: 0;
        }
        
        .chat-input-top-row {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }

        .chat-input input[type="text"] {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 20px;
            outline: none;
            min-width: 50px;
        }
        
        .attachment-btn {
            background: #f8f9fa;
            border: none;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 1.2em;
        }
        
        .attachment-btn:hover {
            background: #e9ecef;
        }

        body.dark-mode .chat-input {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
        }

        body.dark-mode .chat-input input[type="text"] {
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        body.dark-mode .attachment-btn {
            background: var(--bg-color);
        }

        body.dark-mode .attachment-btn:hover {
            background: var(--border-color);
        }

        .send-btn {
            margin: 0;
        }

        .bottom-nav {
            position: relative;
            width: 100%;
            background: var(--card-bg);
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            padding: 15px 0;
            flex-shrink: 0;
            transition: background var(--transition-speed);
        }

        .nav-item {
            text-align: center;
            cursor: pointer;
            transition: all var(--transition-speed);
            flex: 1;
            position: relative;
            color: var(--text-secondary);
        }

        .nav-item:hover {
            transform: translateY(-2px);
        }
        
        .notification-badge {
    position: absolute;
    top: -5px;
    right: calc(50% - 20px);
    min-width: 18px;
    height: 18px;
    background-color: #14b8a6;
    border-radius: 10px;
    border: 2px solid white;
    display: none;
    align-items: center;
    justify-content: center;
    font-size: 11px;
    font-weight: bold;
    color: white;
    padding: 0 4px;
}

.notification-badge.has-count {
    display: flex;
}

        .nav-item.active {
            color: var(--primary-color);
            background: rgba(91, 79, 199, 0.1);
            border-radius: 12px;
            margin: 0 4px;
        }

        .nav-item .nav-icon {
            font-size: 1.2em;
            margin-bottom: 5px;
        }

        .nav-item .nav-label {
            font-size: 0.7em;
            font-weight: 600;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(4px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-content {
    	background: var(--bg-color);
    	padding: 25px;
    	border-radius: var(--radius-lg);
    	max-width: 90%;
    	width: 350px;
    	max-height: 90vh;
    	overflow-y: auto;
    	box-shadow: var(--shadow-xl);
    	border: 1px solid var(--border-color);
	}

        /* PWA Install Banner */
        .pwa-install-banner {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, var(--primary-gradient-start) 0%, var(--primary-gradient-end) 100%);
            color: white;
            padding: 16px 20px;
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1500;
            transform: translateY(100%);
            transition: transform 0.3s ease-in-out;
            max-width: 400px;
            margin: 0 auto;
        }

        .pwa-install-banner.show {
            transform: translateY(0);
        }

        .pwa-banner-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .pwa-banner-icon {
            font-size: 32px;
            flex-shrink: 0;
        }

        .pwa-banner-text {
            flex: 1;
        }

        .pwa-banner-title {
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 4px;
        }

        .pwa-banner-subtitle {
            font-size: 13px;
            opacity: 0.9;
            line-height: 1.3;
        }

        .pwa-banner-buttons {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .pwa-banner-btn {
            flex: 1;
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pwa-banner-btn-primary {
            background: white;
            color: var(--primary-color);
        }

        .pwa-banner-btn-primary:hover {
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(255, 255, 255, 0.3);
        }

        .pwa-banner-btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            backdrop-filter: blur(10px);
        }

        .pwa-banner-btn-secondary:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .pwa-banner-close {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            opacity: 0.7;
            padding: 4px;
            line-height: 1;
        }

        .pwa-banner-close:hover {
            opacity: 1;
        }

        /* iOS specific styles */
        .pwa-ios-instructions {
            background: var(--card-bg);
            color: var(--text-primary);
            padding: 20px;
            border-radius: var(--radius-lg);
            margin-top: 12px;
            font-size: 13px;
            line-height: 1.6;
            border: 1px solid var(--border-color);
        }

        .pwa-ios-step {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .pwa-ios-step-number {
            background: var(--primary-color);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 12px;
            flex-shrink: 0;
        }
        
        .modal-image-content {
            background: transparent;
            padding: 0;
            box-shadow: none;
        }

        .modal-image {
            width: 100%;
            height: auto;
            border-radius: 10px;
        }

        .close-modal {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 2em;
            cursor: pointer;
            z-index: 2001;
        }
        
        .modal-content .close-modal-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.5em;
            color: var(--text-tertiary);
            cursor: pointer;
            transition: color var(--transition-speed);
        }

        .modal-content .close-modal-btn:hover {
            color: var(--text-primary);
        }

        .modal-header {
            font-size: 1.4em;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--text-primary);
        }
        
        .undo-container {
    position: fixed;
    bottom: 70px;
    left: 50%;
    transform: translateX(-50%);
    width: calc(100% - 40px);
    max-width: 360px;
    background-color: #333;
    color: white;
    padding: 15px;
    border-radius: 10px;
    display: none;
    justify-content: space-between;
    align-items: center;
    z-index: 1001; /* Higher than the save button */
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

        .undo-btn {
            background: none;
            border: none;
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
        }

.sticky-save {
    position: fixed;
    bottom: 80px;
    left: 50%;
    transform: translateX(-50%);
    width: calc(100% - 40px);
    max-width: 360px;
    z-index: 100;
    box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
}

.sticky-save:hover {
    transform: translateX(-50%) translateY(-2px);
    box-shadow: 0 3px 15px rgba(102, 126, 234, 0.4);
}

#manage-activities-grid {
    max-height: 400px;
    overflow-y: auto;
    margin-bottom: 20px;
}

.message-timestamp {
            color: #999;
            font-size: 0.7em;
            margin-left: 8px;
        }

#manage-activities-grid .activities-grid {
    display: grid !important;
    grid-template-columns: repeat(3, 1fr) !important;
    gap: 10px;
    margin-bottom: 20px;
}

#manage-activities-grid h3 {
    font-size: 1em;
    font-weight: 600;
    color: #555;
    margin: 15px 0 10px 0;
    padding-bottom: 5px;
    border-bottom: 1px solid #f0f0f0;
}

#manage-activities-grid h3:first-child {
    margin-top: 0;
}

#manage-activities-modal-overlay .modal-content {
    max-height: 80vh;
    overflow-y: auto;
}

#manage-activities-grid .activity-card {
    padding: 8px !important;
    font-size: 0.75em !important;
    min-height: 60px !important;
    max-height: 60px !important;
    width: 100% !important;
}

#manage-activities-grid .activity-emoji {
    font-size: 1.1em !important;
    margin-bottom: 4px !important;
}

#manage-activities-grid .activity-name {
    font-size: 0.75em !important;
    line-height: 1.1 !important;
    margin: 0 !important;
}

#manage-activities-modal-overlay #manage-activities-grid {
    display: block !important;
    grid-template-columns: unset !important;
}

    </style>
<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
<script>
  const SUPABASE_URL = "https://kxsewkjbhxtfqbytftbu.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt4c2V3a2piaHh0ZnFieXRmdGJ1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg4NTE4ODQsImV4cCI6MjA3NDQyNzg4NH0.-A-7VOQWOaQqYOO6NxiKxGywddfS-pmwvzHISJqz2AQ";

  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
  
  // Add global Supabase error handler
  supabase.auth.onAuthStateChange((event, session) => {
    console.log('Auth state changed:', event);

    if (event === 'SIGNED_OUT') {
      console.log('User signed out');
    } else if (event === 'TOKEN_REFRESHED') {
      console.log('Token refreshed');
    } else if (event === 'USER_UPDATED') {
      console.log('User updated');
    } else if (event === 'PASSWORD_RECOVERY') {
      console.log('Password recovery detected - showing reset form');
      // Ensure we show the password reset form regardless of app state
      // Use setTimeout to ensure DOM is ready and avoid race conditions
      setTimeout(() => {
        showPasswordResetModal();
      }, 100);
    }
  });
</script>

<script src="https://cdn.onesignal.com/sdks/web/v16/OneSignalSDK.page.js" defer></script>
<script>
  window.OneSignalDeferred = window.OneSignalDeferred || [];
  OneSignalDeferred.push(async function(OneSignal) {
    try {
      await OneSignal.init({
        appId: "67c70940-dc92-4d95-9072-503b2f5d84c8", // TODO: Verify this is your correct OneSignal App ID from dashboard
        allowLocalhostAsSecureOrigin: true,
        serviceWorkerParam: { scope: '/' },
        serviceWorkerPath: '/OneSignalSDKWorker.js'
      });
      console.log('✅ OneSignal initialized successfully');

      // Save player ID immediately if user is logged in
      try {
        const { data: { session } } = await supabase.auth.getSession();
        const playerId = OneSignal.User.PushSubscription.id;

        if (session?.user?.id && playerId) {
          console.log('💾 Saving initial OneSignal player ID:', playerId);

          const { error } = await supabase
            .from('profiles')
            .update({ onesignal_player_id: playerId })
            .eq('id', session.user.id);

          if (error) throw error;

          console.log('✅ Initial OneSignal Player ID saved successfully');
        }
      } catch (error) {
        console.error('❌ Error saving initial Player ID:', error);
      }
    } catch (error) {
      console.error('❌ OneSignal initialization error:', error);
    }

    // NOTE: We do NOT add a foregroundWillDisplay listener because:
    // 1. It intercepts notifications but Web SDK v16 has no display() method
    // 2. The service worker handles all notification display automatically
    // 3. Having this listener prevents notifications from showing

    // Handle notification clicks - mostly handled by service worker
    // This fires when app is in foreground
    // Must not be async to avoid blocking OneSignal's internal message passing
    OneSignal.Notifications.addEventListener('click', (event) => {
      console.log('🔔 Page: Notification clicked (foreground handler)', event);
      console.log('📦 Page: Notification data:', event.notification);
      console.log('📦 Page: Additional data:', event.notification.additionalData);

      const data = event.notification.additionalData || event.notification.data || {};
      console.log('📦 Page: Extracted data:', data);

      // Handle navigation asynchronously without blocking the event handler
      // This prevents "message channel closed" errors in OneSignal's internal messaging
      (async () => {
        // When app is in foreground, navigate directly in-app
        if (window.currentUser && data && data.chatType && data.chatId) {
          console.log('✅ Page: User authenticated, navigating in-app to:', data.chatType, data.chatId);

          try {
            // Wait for app to be ready before navigating (critical for iOS)
            console.log('⏳ Page: Waiting for app to be ready before navigation...');
            await window.waitForAppReady(15000); // 15 second timeout
            console.log('✅ Page: App is ready, proceeding with navigation');

            // Navigate directly to the chat
            if (data.chatType === 'match') {
              await openMatchChatThreaded(data.chatId);
            } else if (data.chatType === 'event') {
              await openEventChat(data.chatId);
            } else if (data.chatType === 'circle') {
              await openCircleChat(data.chatId);
            }
            console.log('✅ Page: Successfully navigated to chat in-app');
          } catch (error) {
            console.error('❌ Page: Error navigating to chat:', error);
            console.error('❌ Page: Error stack:', error.stack);
            console.error('❌ Page: App state at error:', window.appState);
            // Fallback to showing matches page
            showPage('matches');
            showNotification('Unable to open chat. Please try again.', 'error');
          }
        } else {
          console.log('⚠️ Page: User not authenticated or no chat data, service worker will handle');
          // Service worker will handle the navigation via URL parameters
        }
      })();
    });
    
    // Save Player ID to database when user is logged in
    OneSignal.User.PushSubscription.addEventListener('change', async function(event) {
      const playerId = event.current.id;

      if (!playerId) {
        console.log('⚠️ No player ID in subscription change event');
        return;
      }

      console.log('🔔 OneSignal subscription changed, player ID:', playerId);

      try {
        // Get current session from Supabase
        const { data: { session } } = await supabase.auth.getSession();

        if (!session?.user?.id) {
          console.log('⚠️ No active session, cannot save player ID');
          return;
        }

        console.log('💾 Saving OneSignal player ID to database for user:', session.user.id);

        // Update database with player ID
        const { error } = await supabase
          .from('profiles')
          .update({ onesignal_player_id: playerId })
          .eq('id', session.user.id);

        if (error) throw error;

        console.log('✅ OneSignal Player ID saved successfully:', playerId);

        // Update in-memory user object if it exists
        if (window.currentUser) {
          window.currentUser.onesignal_player_id = playerId;
        }
      } catch (error) {
        console.error('❌ Error saving Player ID:', error);
      }
    });
  });
</script>
</head>
<body>
    <div class="app-container">
        <div id="pages-container" style="flex: 1; overflow-y: auto; position: relative;">
<div id="onboarding" class="page active">
    <div class="header">
        <div class="logo">⭕ Friendle</div>
        <div class="tagline" id="onboarding-tagline">Who's in?</div>
    </div>
    
    <div id="onboarding-content" style="padding: 20px;">
        <!-- Invite context (shown when invite_code exists) -->
        <div id="invite-context" style="display: none; text-align: center; margin-bottom: 30px;">
            <div style="font-size: 1.2em; font-weight: 600; margin-bottom: 10px;">
                You've been invited to join
            </div>
            <div id="invite-circle-name" style="font-size: 1.5em; font-weight: bold; color: #667eea; margin-bottom: 20px;">
                Loading...
            </div>
        </div>
        
        <!-- Generic pitch (shown when no invite_code) -->
        <div id="generic-pitch" style="margin-bottom: 30px;">
            <div style="font-size: 1.1em; line-height: 1.6; color: #555;">
                <p style="margin-bottom: 15px;">Stop coordinating plans through endless group chat messages.</p>
                <p style="margin-bottom: 15px;">With Friendle:</p>
                <ul style="list-style: none; padding-left: 0;">
    <li style="margin-bottom: 10px;">✓ Share what activities you're interested in</li>
    <li style="margin-bottom: 10px;">✓ See who else wants to do the same things and make it happen</li>
</ul>
            </div>
        </div>
        
        <button class="btn" id="onboarding-cta" onclick="showWelcomeFromOnboarding()">Get Started</button>
        <div style="text-align: center; margin-top: 15px; color: #666; font-size: 0.9em;">
            Already have an account? <a href="#" onclick="showWelcomeFromOnboarding(); return false;" style="color: #667eea; text-decoration: underline;">Sign in</a>
        </div>
    </div>
</div>
            <div id="welcome" class="page">
    <div class="header"><div class="logo">⭕ Friendle</div><div class="tagline">What do you feel like doing?</div></div>
    
    <form id="login-form" onsubmit="event.preventDefault(); signIn();">
        <div class="form-group"><label for="login-email">Email</label><input type="email" id="login-email" placeholder="Enter your email" autocomplete="email" inputmode="email"></div>
        <div class="form-group"><label for="login-password">Password</label><input type="password" id="login-password" placeholder="Enter your password" autocomplete="current-password"></div>
        <button type="submit" class="btn">Sign In</button>
        <button type="button" class="btn btn-secondary" onclick="showRegister()">Create Account</button>
        <div style="text-align: center; margin-top: 15px;">
            <a href="#" onclick="showForgotPassword(); return false;" style="color: #667eea; text-decoration: underline; font-size: 0.9em;">Forgot password?</a>
        </div>
    </form>
    
    <form id="register-form" style="display: none;" onsubmit="event.preventDefault(); signUp();">
        <div class="form-group"><label for="register-email">Email</label><input type="email" id="register-email" placeholder="Enter your email" autocomplete="email" inputmode="email"></div>
        <div class="form-group"><label for="register-name">Your Name</label><input type="text" id="register-name" placeholder="Enter your name" autocomplete="given-name"></div>
        <div class="form-group"><label for="register-password">Password</label><input type="password" id="register-password" placeholder="Create a password (6+ characters)" autocomplete="new-password"></div>
        <div class="form-group">
            <label>Profile Picture</label>
            <div style="text-align: center; margin: 20px 0;">
                <div style="position: relative; width: 100px; height: 100px; margin: 0 auto 15px;">
                    <div id="register-profile-preview" style="width: 100%; height: 100%; border-radius: 50%; border: 3px solid var(--border-color); display: flex; align-items: center; justify-content: center; font-size: 50px; background: var(--card-bg); overflow: hidden; cursor: pointer;" onclick="showRegisterPhotoMenu(event)">
                        <span id="register-avatar-display">😊</span>
                    </div>
                    <div style="position: absolute; bottom: 0; right: 0; width: 32px; height: 32px; border-radius: 50%; background: var(--primary-color); display: flex; align-items: center; justify-content: center; cursor: pointer; border: 2px solid var(--card-bg);" onclick="showRegisterPhotoMenu(event)" title="Change photo">📷</div>
                </div>
                <input type="file" id="register-photo-input" accept="image/*" style="display: none;" onchange="handleRegisterPhotoUpload(event)">
            </div>
            <div style="text-align: center; margin-bottom: 10px; color: var(--text-secondary); font-size: 0.9em;">or choose an emoji avatar:</div>
            <div class="avatar-grid">
                <div class="avatar-option" data-avatar="😊">😊</div><div class="avatar-option" data-avatar="🌟">🌟</div><div class="avatar-option" data-avatar="🦄">🦄</div><div class="avatar-option" data-avatar="🐨">🐨</div>
                <div class="avatar-option" data-avatar="🎮">🎮</div><div class="avatar-option" data-avatar="🎨">🎨</div><div class="avatar-option" data-avatar="⚡">⚡</div><div class="avatar-option" data-avatar="🌙">🌙</div>
            </div>
        </div>
        <button type="submit" class="btn">Create Account</button>
        <div style="text-align: center; margin-top: 20px; margin-bottom: -10px; color: #666; font-size: 0.9em;">
    Already have an account?
</div>
<button type="button" class="btn btn-secondary" onclick="showLogin()">Sign In</button>
    </form>
    
    <form id="forgot-password-form" style="display: none;" onsubmit="event.preventDefault(); sendPasswordReset();">
        <div class="form-group"><label for="reset-email">Email</label><input type="email" id="reset-email" placeholder="Enter your email" autocomplete="email" inputmode="email"></div>
        <button type="submit" class="btn">Send Reset Link</button>
        <button type="button" class="btn btn-secondary" onclick="showLogin()">Back to Sign In</button>
    </form>

    <form id="password-reset-form" style="display: none;" onsubmit="event.preventDefault(); submitPasswordReset();">
        <h2 style="text-align: center; margin-bottom: 20px;">🔒 Reset Your Password</h2>
        <p style="text-align: center; color: #666; margin-bottom: 20px;">Welcome! Your password reset link worked. Enter your new password below to complete the process.</p>
        <div class="form-group"><label for="new-reset-password">New Password</label><input type="password" id="new-reset-password" placeholder="Enter new password (6+ characters)" autocomplete="new-password"></div>
        <div class="form-group"><label for="confirm-reset-password">Confirm Password</label><input type="password" id="confirm-reset-password" placeholder="Confirm new password" autocomplete="new-password"></div>
        <button type="submit" class="btn">Reset Password</button>
    </form>
</div>
            <div id="circles" class="page">
    <div class="header">
        <div class="logo">⭕ Circles</div>
        <div class="tagline">Who do you want to hang with?</div>
    </div>
    <div id="circles-list"></div>
    <div id="no-circles-message" style="display: none; text-align: center; padding: 40px 20px; color: #666;">
        <div style="font-size: 3em; margin-bottom: 20px;">👥</div>
        <h3 style="margin-bottom: 15px; color: #333;">No Circles Yet</h3>
        <p style="margin-bottom: 25px; line-height: 1.6;">
            Circles are your friend groups. Create one to start coordinating activities, or join an existing circle with an invite code.
        </p>
    </div>
    <button class="btn" onclick="showCreateCircle()">Create New Circle</button>
    <button class="btn btn-secondary" onclick="showJoinCircle()">Join Circle</button>
</div>
            <div id="activities" class="page">
    <div class="header">
        <div class="logo">⭕ Activities</div>
        <div class="tagline">What do you want to do?</div>
    </div>
    
    <div class="form-group">
    <label for="circle-selector">Select Circle</label>
    <select id="circle-selector" onchange="handleCircleChange()">
        <option value="">Choose a circle...</option>
    </select>
</div>
    <div style="display: flex; gap: 10px; margin-bottom: 20px;">
    <button class="btn btn-secondary btn-small" onclick="openSuggestModal()" style="flex: 1;">💡 Suggest a New Activity</button>
    <button class="btn btn-secondary btn-small" onclick="openManageActivitiesModal()" style="flex: 1;">Manage Activities</button>
</div>

<div style="display: flex; gap: 10px; margin-bottom: 20px; justify-content: center;">
    <button id="grid-view-btn" class="btn btn-secondary btn-small" onclick="switchToGridView()">📋 Grid View</button>
    <button id="swipe-view-btn" class="btn btn-secondary btn-small" onclick="switchToSwipeView()" style="background: #667eea; color: white;">👆 Swipe View</button>
</div>
    
                <!-- Swipe View Container -->
<div id="swipe-view-container" style="display: block;">
    <div id="swipe-container" style="position: relative; height: 500px; display: flex; align-items: center; justify-content: center;">
        <div id="card-stack" style="position: relative; width: 100%; max-width: 350px; height: 450px;"></div>
    </div>
    
    <div style="text-align: center; margin: 20px 0;">
        <span id="swipe-progress" style="font-size: 0.9em; color: #666;">0 of 0</span>
    </div>
    
    <div style="display: flex; gap: 15px; justify-content: center; margin: 20px 0;">
    <button onclick="swipeLeft()" class="btn btn-secondary" style="width: 80px; padding: 15px;">👎</button>
    <button onclick="undoSwipe()" class="btn btn-secondary" style="width: 80px; padding: 15px;">↩️</button>
    <button onclick="swipeRight()" class="btn btn-secondary" style="width: 80px; padding: 15px;">👍</button>
</div>
</div>

<!-- Grid View Container (existing) -->
<div id="grid-view-container" style="display: none;">
    <div id="frequent-section"><div class="section-title">⭐ Frequently Used</div><div class="frequent-grid" id="frequent-grid"></div></div>
    <div class="section-title">All Activities</div>
    <div class="activities-grid" id="activities-grid"></div>
</div>
                <button id="grid-save-button" class="btn sticky-save" onclick="saveActivities()" style="display: none;">Save Preferences</button>
                
            </div>
            <div id="matches" class="page">
    <div class="header">
        <div class="logo">⭕ Matches</div>
        <div class="tagline">Who else wants to do what you want to do?</div>
    </div>
    <div id="matches-list"></div>
</div>
            <div id="chat" class="page">
    <div class="chat-container">
        <div class="chat-header">
    <div style="display: flex; align-items: center; margin-bottom: 8px;">
        <button onclick="showPage('matches')" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 0.85em; margin-right: 10px;">← Back</button>
        <div style="flex: 1;">
            <div id="event-activity-name" style="font-weight: 600; font-size: 1.1em;"></div>
            <div id="event-participants" style="font-size: 0.8em; opacity: 0.8;"></div>
        </div>
    </div>
    <div style="display: flex; gap: 8px; justify-content: flex-end;">
        <button id="open-general-chat-btn" onclick="openGeneralChatFromEvent()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 0.85em; display: none;">💬 General Chat</button>
        <button id="add-to-calendar-btn" onclick="addToCalendarFromHeader()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 0.85em; display: none;">📅 Add to Calendar</button>
        <button id="leave-event-btn" onclick="leaveEvent()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 0.85em; display: none;">Leave event</button>
	<button id="mute-chat-btn" class="btn btn-secondary btn-small" onclick="toggleMuteChat()" style="display: none;">
    <span id="mute-btn-text">🔔 Mute</span>
</button>
        <button id="event-options-btn" onclick="openEventOptionsModal()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 0.85em; display: none;">⚙️</button>
    </div>
</div>
        
        <div id="event-details" style="background: #e6f7ff; padding: 12px 15px; border-bottom: 1px solid #91d5ff; flex-shrink: 0;">
            <div id="event-date" style="font-weight: 500; margin-bottom: 4px; color: #0050b3;"></div>
            <div id="event-location" style="color: #0050b3; font-size: 14px;"></div>
            <div id="event-notes" style="color: #0050b3; font-size: 14px; margin-top: 4px;"></div>
        </div>
        
        <div class="chat-messages" id="chat-messages"></div>
        
        <div class="chat-input">
            <div class="chat-input-top-row">
                <input type="text" id="message-input" placeholder="Type a message..." onkeypress="handleMessageKeyPress(event)">
                <button class="attachment-btn" onclick="sharePhoto()">📷</button>
                <button class="attachment-btn" onclick="shareLocation()">📍</button>
                <button class="attachment-btn" onclick="findNearbyPlaces()">🔍</button>
            </div>
            <button class="btn send-btn" onclick="sendMessage()">Send</button>
        </div>
    </div>
</div>
            <div id="settings" class="page">
            <div class="header"><div class="logo">⚙️ Settings</div><div class="tagline">Manage your preferences</div></div>
    <div style="text-align: center; margin: 40px 0;">
        <div class="profile-picture-container" onclick="showSettingsPhotoMenu(event)">
            <div class="profile-picture">
                <div id="profile-avatar" class="avatar-display emoji">😊</div>
            </div>
            <div class="profile-picture-overlay" title="Change profile picture">📷</div>
        </div>
        <input type="file" id="profile-picture-input" accept="image/*" style="display: none;" onchange="uploadProfilePicture(event)">
        <h2 id="profile-name" style="color: var(--text-primary);">Your Name</h2>
    </div>

    <div class="form-group">
        <label for="new-username">Display Name</label>
        <input type="text" id="new-username" placeholder="Enter new name">
    </div>
    <button class="btn btn-secondary" onclick="changeUsername()">Update Name</button>

    <div class="toggle-container">
        <label class="toggle-label" for="event-reminders-toggle">
            <div class="toggle-text">
                <div class="toggle-title">Event Reminders</div>
                <div class="toggle-description">Get notified at 9 AM on the day of your events</div>
            </div>
            <div class="toggle-switch">
                <input type="checkbox" id="event-reminders-toggle" onchange="toggleEventReminders()">
                <span class="toggle-slider"></span>
            </div>
        </label>
    </div>

    <div style="margin: 0 0 20px 0;">
        <label for="timezone-select" style="display: block; font-size: 0.9em; color: var(--text-secondary); margin-bottom: 8px;">Your Timezone</label>
        <select id="timezone-select" onchange="updateTimezone()" style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-primary); font-size: 1em;">
            <option value="America/New_York">Eastern Time (ET)</option>
            <option value="America/Chicago">Central Time (CT)</option>
            <option value="America/Denver">Mountain Time (MT)</option>
            <option value="America/Los_Angeles">Pacific Time (PT)</option>
            <option value="America/Anchorage">Alaska Time (AKT)</option>
            <option value="Pacific/Honolulu">Hawaii Time (HT)</option>
            <option value="Europe/London">London (GMT/BST)</option>
            <option value="Europe/Paris">Central European (CET)</option>
            <option value="Europe/Athens">Eastern European (EET)</option>
            <option value="Asia/Dubai">Dubai (GST)</option>
            <option value="Asia/Kolkata">India (IST)</option>
            <option value="Asia/Shanghai">China (CST)</option>
            <option value="Asia/Tokyo">Japan (JST)</option>
            <option value="Australia/Sydney">Sydney (AEDT)</option>
            <option value="Pacific/Auckland">New Zealand (NZDT)</option>
        </select>
        <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">Reminders will be sent at 9 AM in your timezone</div>
    </div>

    <div style="margin: 20px 0; padding: 15px; background: var(--card-bg); border-radius: 8px;">
        <h3 style="margin: 0 0 10px 0; font-size: 1em; color: var(--text-primary);">Push Notifications</h3>
        <p style="margin: 0 0 15px 0; font-size: 0.85em; color: var(--text-secondary);">Control which push notifications you receive</p>

        <div class="toggle-container">
            <label class="toggle-label" for="new-match-toggle">
                <div class="toggle-text">
                    <div class="toggle-title">New Matches</div>
                    <div class="toggle-description">Get notified when someone joins your activity</div>
                </div>
                <div class="toggle-switch">
                    <input type="checkbox" id="new-match-toggle" onchange="toggleNewMatches()">
                    <span class="toggle-slider"></span>
                </div>
            </label>
        </div>

        <div class="toggle-container">
            <label class="toggle-label" for="event-join-toggle">
                <div class="toggle-text">
                    <div class="toggle-title">Event Joins</div>
                    <div class="toggle-description">Get notified when someone joins your event</div>
                </div>
                <div class="toggle-switch">
                    <input type="checkbox" id="event-join-toggle" onchange="toggleEventJoins()">
                    <span class="toggle-slider"></span>
                </div>
            </label>
        </div>

        <div class="toggle-container">
            <label class="toggle-label" for="chat-messages-toggle">
                <div class="toggle-text">
                    <div class="toggle-title">Chat Messages</div>
                    <div class="toggle-description">Get notified about new chat messages</div>
                </div>
                <div class="toggle-switch">
                    <input type="checkbox" id="chat-messages-toggle" onchange="toggleChatMessages()">
                    <span class="toggle-slider"></span>
                </div>
            </label>
        </div>

        <div class="toggle-container">
            <label class="toggle-label" for="inactivity-warnings-toggle">
                <div class="toggle-text">
                    <div class="toggle-title">Inactivity Warnings</div>
                    <div class="toggle-description">Get notified before you're marked inactive</div>
                </div>
                <div class="toggle-switch">
                    <input type="checkbox" id="inactivity-warnings-toggle" onchange="toggleInactivityWarnings()">
                    <span class="toggle-slider"></span>
                </div>
            </label>
        </div>
    </div>

    <div class="toggle-container">
        <label class="toggle-label" for="dark-mode-toggle">
            <div class="toggle-text">
                <div class="toggle-title">🌙 Dark Mode</div>
                <div class="toggle-description">Switch between light and dark theme</div>
            </div>
            <div class="toggle-switch">
                <input type="checkbox" id="dark-mode-toggle" onchange="toggleDarkMode()">
                <span class="toggle-slider"></span>
            </div>
        </label>
    </div>

    <!-- Provide Feedback Section -->
    <div style="margin: 20px 0; padding: 15px; background: var(--card-bg); border-radius: 8px; border-left: 3px solid #28a745;">
        <h3 style="margin: 0 0 10px 0; font-size: 1em; color: var(--text-primary);">💬 Provide Feedback</h3>
        <p style="margin: 0 0 15px 0; font-size: 0.85em; color: var(--text-secondary); line-height: 1.4;">
            Help us improve Friendle! Share your thoughts, suggestions, or report issues.
        </p>
        <a href="https://docs.google.com/forms/d/e/1FAIpQLSdGqNR1X-Xe0jHEIbrpABegJBgrAid-xYUkUSGHMW4JbIsxcg/viewform?usp=header" target="_blank" rel="noopener noreferrer" style="text-decoration: none;">
            <button class="btn btn-secondary" style="width: 100%;">Share Your Feedback</button>
        </a>
    </div>

    <button class="btn btn-secondary" onclick="signOut()">Sign Out</button>

    <!-- Advanced Settings Section (Collapsible) -->
    <div style="margin: 30px 0 20px 0; background: var(--card-bg); border-radius: 8px; border: 1px solid var(--border-color); overflow: hidden;">
        <div onclick="toggleAdvancedSettings()" style="padding: 20px; cursor: pointer; user-select: none; display: flex; justify-content: space-between; align-items: center;">
            <h3 style="margin: 0; font-size: 1.1em; color: var(--text-primary);">⚙️ Advanced Settings</h3>
            <span id="advanced-settings-arrow" style="font-size: 1.2em; color: var(--text-secondary); transition: transform 0.3s ease;">▼</span>
        </div>

        <div id="advanced-settings-content" style="max-height: 0; overflow: hidden; transition: max-height 0.3s ease;">
            <div style="padding: 0 20px 20px 20px;">
                <div style="margin-bottom: 20px; padding: 15px; background: var(--bg-primary); border-radius: 6px; border-left: 3px solid #0066cc;">
                    <h4 style="margin: 0 0 8px 0; font-size: 0.95em; color: var(--text-primary);">📥 Export My Data</h4>
                    <p style="margin: 0 0 12px 0; font-size: 0.85em; color: var(--text-secondary); line-height: 1.4;">
                        Download all your personal data including circles, activities, matches, and preferences as a JSON file. Required for GDPR compliance.
                    </p>
                    <button class="btn btn-secondary" onclick="exportData()" style="width: 100%;">Export My Data</button>
                </div>

                <div style="margin-bottom: 0; padding: 15px; background: var(--bg-primary); border-radius: 6px; border-left: 3px solid #dc3545;">
                    <h4 style="margin: 0 0 8px 0; font-size: 0.95em; color: #dc3545;">⚠️ Delete All My Data</h4>
                    <p style="margin: 0 0 12px 0; font-size: 0.85em; color: var(--text-secondary); line-height: 1.4;">
                        Permanently delete all your data including circles, activities, matches, preferences, and profile. This action cannot be undone. Consider exporting your data first.
                    </p>
                    <button class="btn btn-secondary" onclick="resetApp()" style="width: 100%; background: #dc3545; color: white; font-weight: 600;">Delete All My Data</button>
                </div>
            </div>
        </div>
    </div>
</div>
        </div>
        
<!-- Pull to Refresh Indicator -->
        <div id="pull-refresh-indicator" style="
            position: fixed;
            top: -60px;
            left: 0;
            right: 0;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            transition: top 0.3s ease;
            z-index: 9998;
        ">
            <div style="text-align: center;">
                <div id="pull-refresh-icon" style="font-size: 1.5em; margin-bottom: 5px;">↓</div>
                <div id="pull-refresh-text" style="font-size: 0.85em; color: #666;">Pull to refresh</div>
            </div>
        </div>

        <div class="bottom-nav">
            <div class="nav-item" onclick="showPage('circles')"><div class="nav-icon">👥</div><div class="nav-label">Circles</div></div>
            <div class="nav-item active" onclick="showPage('activities')"><div class="nav-icon">🎯</div><div class="nav-label">Activities</div></div>
            <div class="nav-item" id="matches-nav-item" onclick="showPage('matches')">
    <div class="nav-icon">💫</div>
    <div class="nav-label">Matches</div>
</div>
            <div class="nav-item" onclick="showPage('settings')"><div class="nav-icon">⚙️</div><div class="nav-label">Settings</div></div>
        </div>
        
        <div class="modal-overlay" id="image-modal-overlay"><div class="close-modal" onclick="closeImageModal()">×</div><div class="modal-content modal-image-content"><img class="modal-image" id="modal-image" src="" alt=""></div></div>
        <div class="modal-overlay" id="circle-modal-overlay"><div class="modal-content"><span class="close-modal-btn" onclick="closeCircleModal()">×</span><div id="create-circle" style="display: none;">
    <!-- Step 1: Name -->
    <div id="circle-step-1">
        <div class="modal-header">Create New Circle</div>
        <div class="form-group">
            <label for="circle-name">Circle Name</label>
            <input type="text" id="circle-name" placeholder="e.g., College Friends">
        </div>
        <button class="btn" onclick="goToCircleStep2()">Next</button>
        <button class="btn btn-secondary" onclick="closeCircleModal()">Cancel</button>
    </div>
    
    <!-- Step 2: Activities -->
    <div id="circle-step-2" style="display: none;">
        <div class="modal-header">What activities interest this group?</div>

        <!-- Activity grid -->
        <div class="activities-grid" id="circle-creation-activities-grid" style="max-height: 300px; overflow-y: auto; margin-bottom: 15px;"></div>
        
        <div style="text-align: center; margin: 15px 0;">
            <button class="btn btn-secondary btn-small" onclick="openSuggestModal()">
                💡 Suggest a different activity
            </button>
        </div>
        
        <div style="text-align: center; color: #666; font-size: 0.9em; margin-bottom: 15px;">
            <span id="circle-selected-count">0</span> activities selected
            <div id="circle-min-warning" style="color: #dc3545; font-size: 0.85em; margin-top: 5px; display: none;">
                Select at least 4 activities to continue
            </div>
        </div>
        
        <button class="btn" id="circle-create-btn" onclick="finalizeCircleCreation()" disabled style="opacity: 0.5; cursor: not-allowed;">Create Circle</button>
        <button class="btn btn-secondary" onclick="goBackToCircleStep1()">← Back</button>
    </div>
</div><div id="join-circle" style="display: none;"><div class="modal-header">Join Circle</div><div class="form-group"><label for="circle-code">Circle Code</label><input type="text" id="circle-code" placeholder="Enter 6-digit code"></div><button class="btn" onclick="joinCircle()">Join</button></div></div></div>
        <div class="modal-overlay" id="suggest-modal-overlay"><div class="modal-content"><span class="close-modal-btn" onclick="closeSuggestModal()">×</span><div class="modal-header">Suggest an Activity</div><div class="form-group"><label for="suggest-name">Activity Name</label><input type="text" id="suggest-name" placeholder="e.g., Go Karting"></div><button class="btn" onclick="suggestActivity()">Suggest</button></div></div>
        <div class="modal-overlay" id="invite-modal-overlay"><div class="modal-content"><span class="close-modal-btn" onclick="closeInviteModal()">×</span><div class="modal-header">Share Invite Link</div><div class="form-group"><label for="invite-link">Copy this link and send it to a friend:</label><input type="text" id="invite-link" readonly></div><button class="btn" onclick="copyInviteLink()">Copy Link</button></div></div>
    
<div class="undo-container" id="undo-container">
                    <span>Selection updated.</span>
                    <button class="undo-btn" onclick="undoLastActivityChange()">Undo</button>
                </div>
<div class="modal-overlay" id="manage-activities-modal-overlay">
    <div class="modal-content">
        <span class="close-modal-btn" onclick="closeManageActivitiesModal()">×</span>
        <div class="modal-header">Manage Activities for This Circle</div>
        <div style="margin-bottom: 15px; font-size: 0.9em; color: #666;">
    Customize which activities appear in your activity selection. Core activities are shown by default - uncheck to hide them. Additional activities are available to add more variety to your options.
</div>
        <div id="manage-activities-grid" class="activities-grid"></div>
        <button class="btn" onclick="saveActivityVisibility()">Save Changes</button>
    </div>
</div>
</div>

<!-- Create Event Modal -->
<div class="modal-overlay" id="create-event-modal">
    <div class="modal-content" style="max-width: 500px;">
        <span class="close-modal-btn" onclick="closeCreateEventModal()">×</span>
        <div class="modal-header">Schedule New Event</div>
        
        <form id="create-event-form">
            <input type="hidden" id="new-event-match-id">
            
            <div class="form-group">
    <label for="new-event-date">Date *</label>
    <input type="date" id="new-event-date" required>
</div>
            
            <div class="form-group">
                <label for="new-event-location">Location</label>
                <input type="text" id="new-event-location" placeholder="Where are you meeting?">
            </div>
            
            <div class="form-group">
                <label for="new-event-notes">Notes</label>
                <textarea id="new-event-notes" rows="3" placeholder="Any additional details..."></textarea>
            </div>
            
            <button type="submit" class="btn">Create Event</button>
        </form>
    </div>
</div>

<!-- Event Options Modal -->
<div class="modal-overlay" id="event-options-modal">
    <div class="modal-content" style="max-width: 400px;">
        <span class="close-modal-btn" onclick="closeEventOptionsModal()">×</span>
        <div class="modal-header">Event Options</div>
        
        <button onclick="editCurrentEvent()" class="btn btn-secondary" style="width: 100%; text-align: left; margin: 5px 0;">
            ✏️ Edit Event Details
        </button>
        <button onclick="cancelEvent()" class="btn btn-secondary" style="width: 100%; text-align: left; margin: 5px 0;">
            ❌ Cancel Event
        </button>
        <button onclick="deleteEvent()" class="btn btn-secondary" style="width: 100%; text-align: left; margin: 5px 0; background: #dc3545; color: white;">
            🗑️ Delete Event
        </button>
    </div>
</div>

<!-- Edit Event Modal -->
<div class="modal-overlay" id="edit-event-modal">
    <div class="modal-content" style="max-width: 500px;">
        <span class="close-modal-btn" onclick="closeEditEventModal()">×</span>
        <div class="modal-header">Edit Event</div>
        
        <form id="edit-event-form">
            <div class="form-group">
    <label for="edit-event-date">Date *</label>
    <input type="date" id="edit-event-date" required>
</div>
            
            <div class="form-group">
                <label for="edit-event-location">Location</label>
                <input type="text" id="edit-event-location" placeholder="Where are you meeting?">
            </div>
            
            <div class="form-group">
                <label for="edit-event-notes">Notes</label>
                <textarea id="edit-event-notes" rows="3" placeholder="Any additional details..."></textarea>
            </div>
            
            <button type="submit" class="btn">Save Changes</button>
        </form>
    </div>
</div>

<!-- Location Permission Modal -->
<div class="modal-overlay" id="location-permission-modal">
    <div class="modal-content" style="max-width: 400px;">
        <span class="close-modal-btn" onclick="closeLocationPermissionModal()">×</span>
        <div class="modal-header">Location Access Needed</div>
        
        <div style="margin-bottom: 20px; color: #666; line-height: 1.6;">
            <p style="margin-bottom: 15px;">This feature requires access to your location to:</p>
            <ul style="margin: 0; padding-left: 20px;">
                <li style="margin-bottom: 8px;">Share your location with friends</li>
                <li style="margin-bottom: 8px;">Find nearby places for your activities</li>
            </ul>
        </div>
        
        <button class="btn" onclick="requestLocationPermission()">Enable Location</button>
        <button class="btn btn-secondary" onclick="closeLocationPermissionModal()">Not Now</button>
    </div>
</div>

<!-- Match Notification Modal -->
<div class="modal-overlay" id="match-notification-modal" style="z-index: 10000;">
    <div class="modal-content" style="max-width: 350px; text-align: center; animation: slideUp 0.3s ease-out;">
        <div style="font-size: 4em; margin-bottom: 15px; animation: bounce 0.6s ease-in-out;">🎉</div>
        <div style="font-size: 1.5em; font-weight: 700; color: #667eea; margin-bottom: 10px;">It's a Match!</div>
        <div id="match-notification-activity" style="font-size: 2em; margin-bottom: 15px;">🎯</div>
        <div id="match-notification-text" style="color: #666; margin-bottom: 20px; line-height: 1.6;"></div>
        <button class="btn" onclick="joinMatchFromNotification()" style="margin-bottom: 10px; background: #4CAF50;">✓ Join Match</button>
        <button class="btn btn-secondary" onclick="closeMatchNotification()">Keep Swiping</button>
    </div>
</div>

<style>
@keyframes slideUp {
    from {
        transform: translateY(50px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

@keyframes bounce {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
}
</style>

    <script>

        // App State
        let currentUser = null, circles = [], selectedCircle = null, activities = [], lastActivitiesState = [], activityCounts = {}, matches = [], undoTimeout = null, showingArchivedMessages = false, currentMatchChat = null, currentCircleChat = null, matchMessageSubscription = null, allActiveSubscriptions = [], skipAutoLoad = false, currentMatchId = null;

        // Message Pagination State
        const MESSAGE_PAGE_SIZE = 50;
        let messagePagination = {
            match: { loadedCount: 0, hasMore: true, loading: false },
            event: { loadedCount: 0, hasMore: true, loading: false },
            circle: { loadedCount: 0, hasMore: true, loading: false }
        };

        // App Initialization State Tracker (for iOS notification handling)
        window.appState = {
            initialized: false,
            dataLoaded: false,
            matchesLoaded: false,
            circlesLoaded: false,
            timestamp: Date.now()
        };

        // SECURITY: Secure Storage Helper
        // Minimizes sensitive data in localStorage to reduce XSS attack surface
        // Only stores user ID persistently; uses sessionStorage for non-critical data
        const SecureStorage = {
            // Only store user ID persistently (needed for auto-login check)
            setUserId(userId) {
                if (userId) {
                    localStorage.setItem('friendle_user_id', userId);
                }
            },

            getUserId() {
                return localStorage.getItem('friendle_user_id');
            },

            // Store minimal UI data in sessionStorage (clears on tab close)
            setSessionData(data) {
                if (!data) return;
                sessionStorage.setItem('friendle_session', JSON.stringify({
                    name: data.name || '',
                    avatar: data.avatar || ''
                }));
            },

            getSessionData() {
                const data = sessionStorage.getItem('friendle_session');
                return data ? JSON.parse(data) : null;
            },

            // Clear all stored data on logout
            clearAll() {
                localStorage.removeItem('friendle_user_id');
                localStorage.removeItem('friendle_user'); // Legacy - clean up old storage
                sessionStorage.removeItem('friendle_session');
            }
        };

        // SECURITY: Rate Limiter
        // Prevents abuse by limiting actions per time window
        // Uses sliding window algorithm for accurate rate limiting
        const RateLimiter = {
            limits: new Map(), // operation -> array of timestamps

            /**
             * Check if an operation is allowed based on rate limit
             * @param {string} operation - Name of the operation (e.g., 'file_upload', 'send_message')
             * @param {number} maxRequests - Maximum requests allowed
             * @param {number} windowMs - Time window in milliseconds
             * @returns {boolean} - True if allowed, false if rate limited
             */
            checkLimit(operation, maxRequests, windowMs) {
                const now = Date.now();
                const operationKey = `${operation}_${currentUser?.id || 'anonymous'}`;

                // Get existing timestamps for this operation
                if (!this.limits.has(operationKey)) {
                    this.limits.set(operationKey, []);
                }

                const timestamps = this.limits.get(operationKey);

                // Remove timestamps outside the current window
                const validTimestamps = timestamps.filter(ts => now - ts < windowMs);
                this.limits.set(operationKey, validTimestamps);

                // Check if under limit
                if (validTimestamps.length >= maxRequests) {
                    const oldestTimestamp = Math.min(...validTimestamps);
                    const waitTimeMs = windowMs - (now - oldestTimestamp);
                    const waitTimeSec = Math.ceil(waitTimeMs / 1000);
                    console.warn(`Rate limit exceeded for ${operation}. Wait ${waitTimeSec}s`);
                    return false;
                }

                // Add current timestamp
                validTimestamps.push(now);
                this.limits.set(operationKey, validTimestamps);
                return true;
            },

            /**
             * Get remaining requests for an operation
             * @param {string} operation - Name of the operation
             * @param {number} maxRequests - Maximum requests allowed
             * @param {number} windowMs - Time window in milliseconds
             * @returns {number} - Number of requests remaining
             */
            getRemaining(operation, maxRequests, windowMs) {
                const now = Date.now();
                const operationKey = `${operation}_${currentUser?.id || 'anonymous'}`;

                if (!this.limits.has(operationKey)) {
                    return maxRequests;
                }

                const timestamps = this.limits.get(operationKey);
                const validTimestamps = timestamps.filter(ts => now - ts < windowMs);
                return Math.max(0, maxRequests - validTimestamps.length);
            }
        };

        /**
         * Waits for the app to be fully initialized and data to be loaded
         * Critical for iOS devices where notification clicks may happen during app load
         * @param {number} timeoutMs - Maximum time to wait in milliseconds
         * @returns {Promise<void>}
         */
        window.waitForAppReady = async function(timeoutMs = 30000) {
            const startTime = Date.now();
            const checkInterval = 100; // Check every 100ms

            console.log('🔍 waitForAppReady: Starting to wait for app readiness...');
            console.log('📊 Initial state:', JSON.stringify(window.appState));

            return new Promise((resolve, reject) => {
                const checkReady = () => {
                    const elapsed = Date.now() - startTime;

                    // Check if app is fully ready
                    const isReady = window.appState.initialized &&
                                  window.appState.dataLoaded &&
                                  window.currentUser !== null;

                    console.log(`🔍 waitForAppReady check (${elapsed}ms elapsed):`, {
                        initialized: window.appState.initialized,
                        dataLoaded: window.appState.dataLoaded,
                        hasUser: window.currentUser !== null,
                        matchesLoaded: window.appState.matchesLoaded,
                        circlesLoaded: window.appState.circlesLoaded,
                        isReady: isReady
                    });

                    if (isReady) {
                        console.log('✅ waitForAppReady: App is ready!');
                        resolve();
                        return;
                    }

                    // Check for timeout
                    if (elapsed >= timeoutMs) {
                        console.error('❌ waitForAppReady: Timeout after', elapsed, 'ms');
                        console.error('❌ Final state:', JSON.stringify(window.appState));
                        reject(new Error(`App not ready after ${timeoutMs}ms timeout`));
                        return;
                    }

                    // Continue checking
                    setTimeout(checkReady, checkInterval);
                };

                // Start checking
                checkReady();
            });
        };

// ========== CHAT CONTEXT MANAGEMENT ==========
// These helpers ensure only ONE chat context is active at a time

function clearAllChatContexts() {
    console.log('🧹 Clearing all chat contexts');
    currentEvent = null;
    currentMatchChat = null;
    currentCircleChat = null;
    currentMatchId = null;
}

function setEventContext(event) {
    console.log('📍 Setting event context:', event.id);
    clearAllChatContexts();
    currentEvent = event;
}

function setMatchContext(match) {
    console.log('📍 Setting match context:', match.id);
    clearAllChatContexts();
    currentMatchChat = match;
    currentMatchId = match.id; // Keep for backwards compatibility during refactor
}

function setCircleChatContext(circle) {
    console.log('📍 Setting circle chat context:', circle.id);
    clearAllChatContexts();
    currentCircleChat = circle;
}

function getCurrentChatContext() {
    if (currentEvent) {
        return { type: 'event', id: currentEvent.id, data: currentEvent };
    } else if (currentMatchChat) {
        return { type: 'match', id: currentMatchChat.id, data: currentMatchChat };
    } else if (currentCircleChat) {
        return { type: 'circle', id: currentCircleChat.id, data: currentCircleChat };
    }
    return { type: 'none', id: null, data: null };
}
// ========== END CHAT CONTEXT MANAGEMENT ==========

// UUID Generator
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

// Authentication functions
function showRegister() {
    document.getElementById('login-form').style.display = 'none';
    document.getElementById('forgot-password-form').style.display = 'none';
    document.getElementById('password-reset-form').style.display = 'none';
    document.getElementById('register-form').style.display = 'block';
}

function showLogin() {
    document.getElementById('register-form').style.display = 'none';
    document.getElementById('forgot-password-form').style.display = 'none';
    document.getElementById('password-reset-form').style.display = 'none';
    document.getElementById('login-form').style.display = 'block';
}

function showForgotPassword() {
    document.getElementById('login-form').style.display = 'none';
    document.getElementById('register-form').style.display = 'none';
    document.getElementById('password-reset-form').style.display = 'none';
    document.getElementById('forgot-password-form').style.display = 'block';
}

function showPasswordResetModal() {
    console.log('Showing password reset modal');

    // Hide all other forms
    const loginForm = document.getElementById('login-form');
    const registerForm = document.getElementById('register-form');
    const forgotPasswordForm = document.getElementById('forgot-password-form');
    const passwordResetForm = document.getElementById('password-reset-form');

    if (loginForm) loginForm.style.display = 'none';
    if (registerForm) registerForm.style.display = 'none';
    if (forgotPasswordForm) forgotPasswordForm.style.display = 'none';
    if (passwordResetForm) passwordResetForm.style.display = 'block';

    // Show the welcome page (which contains the password reset form)
    const welcomePage = document.getElementById('welcome');
    if (welcomePage) {
        // Hide all other pages first
        document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
        welcomePage.classList.add('active');
    }

    // Hide loader if it's showing
    hideLoader();

    console.log('Password reset form should now be visible');
}

async function submitPasswordReset() {
    const newPassword = document.getElementById('new-reset-password').value;
    const confirmPassword = document.getElementById('confirm-reset-password').value;

    if (!newPassword || !confirmPassword) {
        return showNotification('Please fill in both password fields', 'error');
    }

    if (newPassword.length < 6) {
        return showNotification('New password must be at least 6 characters', 'error');
    }

    if (newPassword !== confirmPassword) {
        return showNotification('Passwords do not match', 'error');
    }

    try {
        showLoader('Resetting password...');

        const { error } = await supabase.auth.updateUser({
            password: newPassword
        });

        if (error) throw error;

        // User is now authenticated with new password - load their profile and navigate to app
        const { data: { session } } = await supabase.auth.getSession();

        if (session) {
            // Load user profile
            const { data: profileData, error: profileError } = await supabase
                .from('profiles')
                .select('*')
                .eq('id', session.user.id)
                .single();

            if (profileError) throw profileError;

            currentUser = profileData;
            // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
            SecureStorage.setUserId(currentUser.id);
            SecureStorage.setSessionData(currentUser);

            // Clear form fields
            document.getElementById('new-reset-password').value = '';
            document.getElementById('confirm-reset-password').value = '';

            // Load app data
            await renderCircles();
            window.appState.circlesLoaded = true;

            await loadMatches();
            window.appState.matchesLoaded = true;

            await updateNotificationBadge();

            // Mark app as initialized (critical for iOS)
            window.appState.initialized = true;
            window.appState.dataLoaded = true;
            console.log('✅ App initialized after password reset:', JSON.stringify(window.appState));

            // Clear hash parameters to prevent re-triggering password recovery flow
            window.history.replaceState({}, document.title, window.location.pathname);

            hideLoader();
            showNotification('Password reset successful! 🎉 Welcome back!', 'success');

            // Check for pending chat from notification click (takes priority)
            const hasPendingChat = sessionStorage.getItem('pending_chat_id') && sessionStorage.getItem('pending_chat_type');

            if (!hasPendingChat) {
                showPage('circles');
            }

            updateProfile();
            await processPendingChat();
        } else {
            // No session - show login
            hideLoader();
            showNotification('Password reset successful! 🎉 Please sign in with your new password.', 'success');
            showLogin();
        }

    } catch (error) {
        hideLoader();
        console.error('Password reset error:', error);
        showNotification(error.message || 'Error resetting password', 'error');
    }
}

async function sendPasswordReset() {
    const email = document.getElementById('reset-email').value.trim();

    if (!email) {
        return showNotification('Please enter your email address', 'error');
    }

    try {
        showLoader('Sending reset link...');

        const { error } = await supabase.auth.resetPasswordForEmail(email, {
            redirectTo: window.location.origin
        });

        if (error) throw error;

        hideLoader();
        showNotification('Password reset link sent! 📧\n\nIMPORTANT: The email may take 5-15 minutes to arrive. Please be patient and check your spam/junk folder if you don\'t see it.\n\nClick the link in the email to reset your password.', 'success');
        showLogin();
        document.getElementById('reset-email').value = '';

    } catch (error) {
        hideLoader();
        console.error('Password reset error:', error);
        showNotification(error.message || 'Error sending reset link', 'error');
    }
}

window.showWelcomeFromOnboarding = function() {
    document.getElementById('onboarding').classList.remove('active');
    document.getElementById('welcome').classList.add('active');
    
    // If they have an invite code, show registration form instead of login
    const inviteCode = sessionStorage.getItem('pending_invite_code');
    if (inviteCode) {
        showRegister();
    }
}

window.signUp = async function() {
    const email = document.getElementById('register-email').value.trim();
    const password = document.getElementById('register-password').value;
    const name = document.getElementById('register-name').value.trim();
    const selectedAvatar = document.querySelector('#register-form .avatar-option.selected');
    const photoFile = window.registerPhotoFile;

    // Debug logging (password length only for security)
    console.log('Sign up attempt:', {
        email,
        name,
        passwordLength: password.length,
        hasAvatar: !!selectedAvatar,
        hasPhoto: !!photoFile
    });

    if (!email || !password || !name) {
        console.error('Validation failed: missing required fields');
        return showNotification('Please fill in all fields', 'error');
    }

    if (!selectedAvatar && !photoFile) {
        return showNotification('Please select an avatar or upload a photo', 'error');
    }

    if (password.length < 6) {
        return showNotification('Password must be at least 6 characters', 'error');
    }

    try {
        showLoader('Creating your account...');

        // Sign up with Supabase Auth
        const { data: authData, error: authError } = await supabase.auth.signUp({
            email: email,
            password: password
        });

        if (authError) throw authError;

        let avatarValue = selectedAvatar ? selectedAvatar.dataset.avatar : '😊';

        // If user uploaded a photo, upload it to storage
        if (photoFile) {
            showLoader('Uploading profile picture...');

            const fileExt = photoFile.name.split('.').pop().toLowerCase();
            const fileName = `${authData.user.id}/avatar.${fileExt}`;

            // Upload photo
            const { error: uploadError } = await supabase.storage
                .from('avatars')
                .upload(fileName, photoFile, {
                    cacheControl: '3600',
                    upsert: true
                });

            if (uploadError) throw uploadError;

            // Get public URL
            const { data: urlData } = supabase.storage
                .from('avatars')
                .getPublicUrl(fileName);

            avatarValue = urlData.publicUrl;
        }

        // Create profile with authenticated user ID
        const profileDataToInsert = {
            id: authData.user.id, // Use Supabase Auth user ID
            name: name,
            avatar: avatarValue
        };

        console.log('Creating profile with data:', profileDataToInsert);

        const { data: profileData, error: profileError } = await supabase
            .from('profiles')
            .insert([profileDataToInsert])
            .select()
            .single();

        if (profileError) throw profileError;

        console.log('Profile created successfully:', { id: profileData.id, name: profileData.name, avatar: profileData.avatar });

        // Clear the photo file after successful registration
        window.registerPhotoFile = null;

        currentUser = profileData;

        // Load default activities now that user is authenticated
        // This is critical for new users who will create circles
        await loadDefaultActivities();

        // Request notification permission and subscribe to OneSignal
        if (window.OneSignalDeferred) {
            try {
                window.OneSignalDeferred.push(async function(OneSignal) {
                    // Use OneSignal API to request permission and subscribe
                    // This properly subscribes the user unlike native Notification.requestPermission()
                    const permission = await OneSignal.Notifications.permission;
                    if (!permission) {
                        console.log('🔔 Requesting OneSignal notification permission...');
                        await OneSignal.Notifications.requestPermission();
                    }

                    // Save player ID to profile
                    const userId = await OneSignal.User.PushSubscription.id;
                    if (userId) {
                        await supabase
                            .from('profiles')
                            .update({ onesignal_player_id: userId })
                            .eq('id', currentUser.id);

                        console.log('✅ OneSignal Player ID saved:', userId);
                    }
                });
            } catch (error) {
                console.error('Error setting up OneSignal:', error);
            }
        }

        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
        SecureStorage.setUserId(currentUser.id);
        SecureStorage.setSessionData(currentUser);

        showNotification('Account created successfully!');

        // Load app data before processing pending chat (critical for iOS)
        await renderCircles();
        window.appState.circlesLoaded = true;

        await loadMatches();
        window.appState.matchesLoaded = true;

        // Mark app as initialized
        window.appState.initialized = true;
        window.appState.dataLoaded = true;
        console.log('✅ App initialized after signup:', JSON.stringify(window.appState));

        // Check for pending chat from notification click (takes priority)
        const hasPendingChat = sessionStorage.getItem('pending_chat_id') && sessionStorage.getItem('pending_chat_type');

        if (!hasPendingChat) {
            showPage('circles');
        }

        updateProfile();
        await processInviteCode();
        await processPendingChat();

        hideLoader();

    } catch (error) {
        hideLoader();
        console.error('Signup error:', error);
        showNotification(error.message || 'Error creating account', 'error');
    }
}

window.signIn = async function() {
    const email = document.getElementById('login-email').value.trim();
    const password = document.getElementById('login-password').value;
    
    if (!email || !password) {
        return showNotification('Please enter email and password', 'error');
    }
    
    try {
        // Sign in with Supabase Auth
        const { data: authData, error: authError } = await supabase.auth.signInWithPassword({
            email: email,
            password: password
        });
        
        if (authError) throw authError;
        
        // Load user profile
        const { data: profileData, error: profileError } = await supabase
            .from('profiles')
            .select('*')
            .eq('id', authData.user.id)
            .single();
        
        if (profileError) throw profileError;
        
        currentUser = profileData;

        // Load default activities now that user is authenticated
        await loadDefaultActivities();

        // Save OneSignal Player ID to profile
        if (window.OneSignalDeferred) {
            try {
                window.OneSignalDeferred.push(async function(OneSignal) {
                    const userId = await OneSignal.User.PushSubscription.id;
                    if (userId && userId !== currentUser.onesignal_player_id) {
                        await supabase
                            .from('profiles')
                            .update({ onesignal_player_id: userId })
                            .eq('id', currentUser.id);

                        console.log('✅ OneSignal Player ID saved:', userId);
                        currentUser.onesignal_player_id = userId;
                    }
                });
            } catch (error) {
                console.error('Error setting up OneSignal:', error);
            }
        }

        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
        SecureStorage.setUserId(currentUser.id);
        SecureStorage.setSessionData(currentUser);

        showNotification('Signed in successfully!');

        // Load app data before processing pending chat (critical for iOS)
        await renderCircles();
        window.appState.circlesLoaded = true;

        await loadMatches();
        window.appState.matchesLoaded = true;

        // Mark app as initialized
        window.appState.initialized = true;
        window.appState.dataLoaded = true;
        console.log('✅ App initialized after signin:', JSON.stringify(window.appState));

        // Check for pending chat from notification click (takes priority)
        const hasPendingChat = sessionStorage.getItem('pending_chat_id') && sessionStorage.getItem('pending_chat_type');

        if (!hasPendingChat) {
            showPage('circles');
        }

        updateProfile();
        await processInviteCode();
        await processPendingChat();
        
    } catch (error) {
        console.error('Signin error:', error);
        showNotification(error.message || 'Error signing in', 'error');
    }
}

window.signOut = async function() {
    if (!confirm('Are you sure you want to sign out?')) return;
    
    try {
        // Clean up all active subscriptions
        allActiveSubscriptions.forEach(sub => {
            if (sub) supabase.removeChannel(sub);
        });
        allActiveSubscriptions = [];
        
        await supabase.auth.signOut();
        currentUser = null;
        // SECURITY: Clear all stored user data (localStorage + sessionStorage)
        SecureStorage.clearAll();
        showPage('welcome');
        showNotification('Signed out successfully');
    } catch (error) {
        console.error('Sign out error:', error);
        showNotification('Error signing out', 'error');
    }
}

async function processInviteCode() {
    const inviteCode = sessionStorage.getItem('pending_invite_code');
    if (!inviteCode || !currentUser) return;
    
    try {
        // Find circle by code
        const { data: circle, error: circleError } = await supabase
            .from('circles')
            .select('*')
            .eq('code', inviteCode)
            .single();
        
        if (circleError || !circle) {
            showNotification('Invalid invite code', 'error');
            sessionStorage.removeItem('pending_invite_code');
            return;
        }
        
        // Check if user is already a member
        const { data: existingMember } = await supabase
            .from('circle_members')
            .select('*')
            .eq('circle_id', circle.id)
            .eq('profile_id', currentUser.id)
            .single();
        
        if (existingMember) {
            showNotification('You are already a member of this circle');
            sessionStorage.removeItem('pending_invite_code');
            return;
        }
        
        // Add user to circle
        const { error: joinError } = await supabase
            .from('circle_members')
            .insert([{ circle_id: circle.id, profile_id: currentUser.id }]);
        
        if (joinError) throw joinError;
        
        showNotification('Successfully joined "' + circle.name + '"!');
        renderCircles(); // Refresh circles display
        sessionStorage.removeItem('pending_invite_code');
        
    } catch (error) {
        console.error('Error processing invite:', error);
        showNotification('Error joining circle', 'error');
        sessionStorage.removeItem('pending_invite_code');
    }
}

async function processPendingChat() {
    const pendingChatId = sessionStorage.getItem('pending_chat_id');
    const pendingChatType = sessionStorage.getItem('pending_chat_type');

    if (!pendingChatId || !pendingChatType || !currentUser) {
        console.log('⚠️ No pending chat to process:', { pendingChatId, pendingChatType, hasUser: !!currentUser });
        return;
    }

    console.log('🔄 Processing pending chat from notification:', { pendingChatId, pendingChatType });
    console.log('📱 Device info:', { userAgent: navigator.userAgent, platform: navigator.platform });

    try {
        // Clear the stored values first
        sessionStorage.removeItem('pending_chat_id');
        sessionStorage.removeItem('pending_chat_type');

        // Wait for app to be fully ready with proper timeout (critical for iOS)
        console.log('⏳ Waiting for app to be ready before opening chat...');
        console.log('📊 Current app state:', window.appState);

        try {
            await window.waitForAppReady(30000); // 30 second timeout for slower devices
            console.log('✅ App is ready, attempting to open chat');
            console.log('📊 App state after ready:', window.appState);
        } catch (error) {
            console.error('❌ Timeout waiting for app to be ready:', error);
            throw new Error('App initialization timeout - please try opening the notification again');
        }

        // Add retry logic with exponential backoff for robustness
        const maxRetries = 3;
        let lastError = null;

        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                console.log(`🔄 Attempt ${attempt}/${maxRetries} to open chat`);

                if (pendingChatType === 'match') {
                    await openMatchChatThreaded(pendingChatId);
                } else if (pendingChatType === 'event') {
                    await openEventChat(pendingChatId);
                } else if (pendingChatType === 'circle') {
                    await openCircleChat(pendingChatId);
                }

                console.log('✅ Opened pending chat successfully on attempt', attempt);
                return; // Success, exit function

            } catch (error) {
                lastError = error;
                console.error(`❌ Attempt ${attempt} failed:`, error);
                console.error('❌ Error stack:', error.stack);

                if (attempt < maxRetries) {
                    // Exponential backoff: 500ms, 1000ms, 2000ms
                    const delayMs = 500 * Math.pow(2, attempt - 1);
                    console.log(`⏳ Waiting ${delayMs}ms before retry...`);
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                } else {
                    // Final attempt failed
                    console.error('❌ All retry attempts exhausted');
                    throw error;
                }
            }
        }

    } catch (error) {
        console.error('❌ Error opening pending chat after all retries:', error);
        console.error('❌ Final error stack:', error.stack);
        console.error('❌ Final app state:', window.appState);
        showNotification('Could not open chat. Please try again from the Matches tab.', 'error');
    }
}

        // Utility Functions
        function generateCode() { return Math.floor(100000 + Math.random() * 900000).toString(); }
	// Check if chat is muted and update button
async function updateMuteButton(matchId, eventId, circleId) {
    try {
        // Build query dynamically to handle nulls correctly
        let query = supabase
            .from('muted_chats')
            .select('id')
            .eq('profile_id', currentUser.id);

        // Use .is() for null values, .eq() for non-null
        if (matchId) {
            query = query.eq('match_id', matchId);
        } else {
            query = query.is('match_id', null);
        }

        if (eventId) {
            query = query.eq('event_id', eventId);
        } else {
            query = query.is('event_id', null);
        }

        if (circleId) {
            query = query.eq('circle_id', circleId);
        } else {
            query = query.is('circle_id', null);
        }

        const { data: muted, error } = await query.maybeSingle();

        if (error) {
            console.error('Error checking mute status:', error);
            return;
        }

        const btnText = document.getElementById('mute-btn-text');
        if (muted) {
            btnText.textContent = '🔕 Unmute';
        } else {
            btnText.textContent = '🔔 Mute';
        }
    } catch (error) {
        console.error('Error checking mute status:', error);
    }
}

// Toggle mute for current chat
window.toggleMuteChat = async function() {
    const currentChatContext = getCurrentChatContext();

    if (!currentChatContext || currentChatContext.type === 'none') {
        showNotification('No chat selected', 'error');
        return;
    }

    const matchId = currentChatContext.type === 'match' ? currentChatContext.id : null;
    const eventId = currentChatContext.type === 'event' ? currentChatContext.id : null;
    const circleId = currentChatContext.type === 'circle' ? currentChatContext.id : null;

    try {
        showLoader('Updating...');

        // Check if already muted
        let query = supabase
            .from('muted_chats')
            .select('id')
            .eq('profile_id', currentUser.id);

        // Use .is() for null values, .eq() for non-null
        if (matchId) {
            query = query.eq('match_id', matchId);
        } else {
            query = query.is('match_id', null);
        }

        if (eventId) {
            query = query.eq('event_id', eventId);
        } else {
            query = query.is('event_id', null);
        }

        if (circleId) {
            query = query.eq('circle_id', circleId);
        } else {
            query = query.is('circle_id', null);
        }

        const { data: existing, error: selectError } = await query.maybeSingle();

        if (selectError) {
            hideLoader();
            console.error('Error checking mute status:', selectError);
            showNotification('Error checking mute status', 'error');
            return;
        }

        if (existing) {
            // Unmute
            const { error: deleteError } = await supabase
                .from('muted_chats')
                .delete()
                .eq('id', existing.id);

            if (deleteError) {
                hideLoader();
                console.error('Error unmuting chat:', deleteError);
                showNotification('Error unmuting chat', 'error');
                return;
            }

            hideLoader();
            showNotification('🔔 Chat unmuted - you\'ll receive notifications');
        } else {
            // Mute
            const { error: insertError } = await supabase
                .from('muted_chats')
                .insert({
                    profile_id: currentUser.id,
                    match_id: matchId,
                    event_id: eventId,
                    circle_id: circleId
                });

            if (insertError) {
                hideLoader();
                console.error('Error muting chat:', insertError);
                showNotification('Error muting chat', 'error');
                return;
            }

            hideLoader();
            showNotification('🔕 Chat muted - you won\'t receive notifications');
        }

        // Update button text
        await updateMuteButton(matchId, eventId, circleId);

    } catch (error) {
        hideLoader();
        console.error('Error toggling mute:', error);
        showNotification('Error updating mute setting', 'error');
    }
}
        function showNotification(message, type = 'success') { /* ... */ }

function showLoader(message = 'Loading...') {
    // Remove existing loader if any
    hideLoader();

    const isDarkMode = document.body.classList.contains('dark-mode');
    const bgColor = isDarkMode ? '#1a1a1e' : '#ffffff';
    const textColor = isDarkMode ? '#e5e5e7' : '#1a1a1a';

    const loader = document.createElement('div');
    loader.id = 'app-loader';
    loader.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        backdrop-filter: blur(4px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
    `;
    loader.innerHTML = `
        <div style="background: ${bgColor}; padding: 40px; border-radius: 16px; text-align: center; box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3); animation: fadeIn 0.2s ease;">
            <div style="font-size: 3em; margin-bottom: 20px; animation: spin 1s linear infinite;">⏳</div>
            <div style="font-size: 16px; color: ${textColor}; font-weight: 500;">${message}</div>
        </div>
    `;
    document.body.appendChild(loader);
}

function hideLoader() {
    const loader = document.getElementById('app-loader');
    if (loader) loader.remove();
}

function showNotificationPrompt() {
    const promptHtml = `
        <div class="modal-overlay" id="notification-prompt" style="display: flex;">
            <div class="modal-content" style="max-width: 400px; text-align: center;">
                <h3 style="margin-top: 0; color: #667eea;">🔔 Stay Connected!</h3>
                <p style="line-height: 1.6; color: #666; margin: 20px 0;">
                    Get notified when friends message you or join your activities. 
                    You can turn this off anytime in settings.
                </p>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn btn-primary" onclick="enableNotifications()" style="flex: 1;">
                        Enable Notifications
                    </button>
                    <button class="btn btn-secondary" onclick="closeNotificationPrompt()" style="flex: 1;">
                        Maybe Later
                    </button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', promptHtml);
}

window.enableNotifications = async function() {
    closeNotificationPrompt();

    // Use OneSignal API to properly request permission and subscribe
    if (window.OneSignalDeferred) {
        window.OneSignalDeferred.push(async function(OneSignal) {
            try {
                await OneSignal.Notifications.requestPermission();
                const permission = await OneSignal.Notifications.permission;

                if (permission) {
                    showNotification('Notifications enabled! 🎉');

                    // Save player ID to profile
                    const userId = await OneSignal.User.PushSubscription.id;
                    if (userId && window.currentUser) {
                        await supabase
                            .from('profiles')
                            .update({ onesignal_player_id: userId })
                            .eq('id', currentUser.id);
                        console.log('✅ OneSignal Player ID saved:', userId);
                    }
                } else {
                    showNotification('Notification permission denied', 'error');
                }
            } catch (error) {
                console.error('Error enabling notifications:', error);
                showNotification('Error enabling notifications', 'error');
            }
        });
    }
}

// PWA Install Prompt
let deferredPrompt = null;

// Capture the beforeinstallprompt event (Android/Chrome)
window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    console.log('✅ beforeinstallprompt event captured');
});

// Detect iOS Safari
function isIOSSafari() {
    const ua = window.navigator.userAgent;
    const iOS = !!ua.match(/iPad/i) || !!ua.match(/iPhone/i);
    const webkit = !!ua.match(/WebKit/i);
    const iOSSafari = iOS && webkit && !ua.match(/CriOS/i);
    return iOSSafari;
}

// Check if app is already installed
function isAppInstalled() {
    return window.matchMedia('(display-mode: standalone)').matches ||
           window.navigator.standalone === true;
}

// Check if we should show the PWA install prompt
function shouldShowPWAPrompt() {
    // Don't show if already installed
    if (isAppInstalled()) {
        console.log('❌ PWA prompt: App already installed');
        return false;
    }

    // Check if dismissed recently (within 7 days)
    const dismissedAt = localStorage.getItem('pwa_prompt_dismissed_at');
    if (dismissedAt) {
        const daysSinceDismissed = (Date.now() - parseInt(dismissedAt)) / (1000 * 60 * 60 * 24);
        if (daysSinceDismissed < 7) {
            console.log(`❌ PWA prompt: Dismissed ${Math.floor(daysSinceDismissed)} days ago`);
            return false;
        }
    }

    // Track visits
    const visitCount = parseInt(localStorage.getItem('pwa_visit_count') || '0');
    const hasJoinedCircle = localStorage.getItem('pwa_has_joined_circle') === 'true';

    console.log('PWA prompt check:', { visitCount, hasJoinedCircle });

    // Show if user has joined their first circle OR on their second visit
    return hasJoinedCircle || visitCount >= 2;
}

// Track page visits
function trackPWAVisit() {
    const visitCount = parseInt(localStorage.getItem('pwa_visit_count') || '0');
    localStorage.setItem('pwa_visit_count', (visitCount + 1).toString());
    console.log(`📊 PWA visit tracked: ${visitCount + 1}`);
}

// Mark that user joined a circle
function markCircleJoined() {
    localStorage.setItem('pwa_has_joined_circle', 'true');
    console.log('✅ First circle join marked for PWA prompt');
}

// Show PWA install prompt
function showPWAPrompt() {
    if (!shouldShowPWAPrompt()) {
        return;
    }

    const isIOS = isIOSSafari();

    // For iOS, show instructions modal
    if (isIOS) {
        showIOSInstallInstructions();
        return;
    }

    // For Android/Chrome with beforeinstallprompt support
    if (!deferredPrompt) {
        console.log('❌ PWA prompt: No deferred prompt available');
        return;
    }

    const bannerHTML = `
        <div class="pwa-install-banner" id="pwa-install-banner">
            <button class="pwa-banner-close" onclick="dismissPWAPrompt()" aria-label="Close">×</button>
            <div class="pwa-banner-content">
                <div class="pwa-banner-icon">📱</div>
                <div class="pwa-banner-text">
                    <div class="pwa-banner-title">Install Friendle</div>
                    <div class="pwa-banner-subtitle">Quick access from your home screen</div>
                </div>
            </div>
            <div class="pwa-banner-buttons">
                <button class="pwa-banner-btn pwa-banner-btn-primary" onclick="installPWA()">
                    Add to Home Screen
                </button>
                <button class="pwa-banner-btn pwa-banner-btn-secondary" onclick="dismissPWAPrompt()">
                    Maybe Later
                </button>
            </div>
        </div>
    `;

    document.body.insertAdjacentHTML('beforeend', bannerHTML);

    // Animate in after a brief delay
    setTimeout(() => {
        const banner = document.getElementById('pwa-install-banner');
        if (banner) {
            banner.classList.add('show');
        }
    }, 300);

    console.log('✅ PWA install banner shown');
}

// Show iOS installation instructions in modal
function showIOSInstallInstructions() {
    const modalHTML = `
        <div class="modal-overlay" id="pwa-ios-modal" style="display: flex;">
            <div class="modal-content" style="max-width: 400px;">
                <h3 style="margin-top: 0; color: var(--primary-color);">📱 Install Friendle</h3>
                <p style="line-height: 1.6; color: var(--text-secondary); margin: 15px 0;">
                    Add Friendle to your home screen for the best experience!
                </p>
                <div class="pwa-ios-instructions">
                    <div class="pwa-ios-step">
                        <div class="pwa-ios-step-number">1</div>
                        <div>Tap the Share button <strong>⎘</strong> at the bottom</div>
                    </div>
                    <div class="pwa-ios-step">
                        <div class="pwa-ios-step-number">2</div>
                        <div>Scroll down and tap <strong>"Add to Home Screen"</strong></div>
                    </div>
                    <div class="pwa-ios-step">
                        <div class="pwa-ios-step-number">3</div>
                        <div>Tap <strong>"Add"</strong> in the top right</div>
                    </div>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn btn-secondary" onclick="dismissPWAPrompt()" style="flex: 1;">
                        Maybe Later
                    </button>
                </div>
            </div>
        </div>
    `;

    document.body.insertAdjacentHTML('beforeend', modalHTML);
    console.log('✅ iOS install instructions shown');
}

// Install PWA (Android/Chrome)
window.installPWA = async function() {
    if (!deferredPrompt) {
        console.log('❌ No deferred prompt available');
        return;
    }

    // Show the install prompt
    deferredPrompt.prompt();

    // Wait for the user to respond to the prompt
    const { outcome } = await deferredPrompt.userChoice;
    console.log(`User response to install prompt: ${outcome}`);

    if (outcome === 'accepted') {
        showNotification('App installed! 🎉');
    }

    // Clear the deferred prompt
    deferredPrompt = null;

    // Close the banner
    closePWABanner();
}

// Dismiss PWA prompt
window.dismissPWAPrompt = function() {
    // Store dismissal timestamp
    localStorage.setItem('pwa_prompt_dismissed_at', Date.now().toString());
    console.log('PWA prompt dismissed for 7 days');

    // Close banner or modal
    closePWABanner();

    const iosModal = document.getElementById('pwa-ios-modal');
    if (iosModal) {
        iosModal.remove();
    }
}

// Close PWA banner with animation
function closePWABanner() {
    const banner = document.getElementById('pwa-install-banner');
    if (banner) {
        banner.classList.remove('show');
        setTimeout(() => banner.remove(), 300);
    }
}

function closeNotificationPrompt() {
    const prompt = document.getElementById('notification-prompt');
    if (prompt) prompt.remove();
}

        // Profile Management & Avatar Selection
       window.createProfile = async function() {
  const name = document.getElementById('name').value.trim();
  const selectedAvatar = document.querySelector('.avatar-option.selected');
  if (!name || !selectedAvatar) {
    return showNotification('Please enter a name and select an avatar', 'error');
  }

  // Create profile object with UUID
  const profileData = {
    id: generateUUID(), // Use UUID instead of letting Supabase auto-generate
    name, 
    avatar: selectedAvatar.dataset.avatar
  };

  // Insert into Supabase
  const { data, error } = await supabase
    .from('profiles')
    .insert([profileData])
    .select()
    .single();

  if (error) {
    console.error(error);
    return showNotification('Could not create profile', 'error');
  }

  currentUser = data; // store the profile from DB
  // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser); // keep local copy for session
  showPage('circles');
  updateProfile();
  processInvite();
}

        function updateProfile() {
            if (currentUser) {
                document.getElementById('profile-name').textContent = currentUser.name;

                const avatarElement = document.getElementById('profile-avatar');
                const removePictureBtn = document.getElementById('remove-picture-btn');

                // Check if avatar is a URL or emoji
                if (currentUser.avatar && currentUser.avatar.startsWith('http')) {
                    // It's an image URL
                    avatarElement.innerHTML = `<img src="${currentUser.avatar}" alt="Profile picture" class="avatar-display">`;
                    avatarElement.classList.remove('emoji');
                    if (removePictureBtn) removePictureBtn.style.display = 'inline-block';
                } else {
                    // It's an emoji
                    avatarElement.textContent = currentUser.avatar || '😊';
                    avatarElement.classList.add('emoji');
                    if (removePictureBtn) removePictureBtn.style.display = 'none';
                }

                loadMinimumGroupSize();
            }
        }

async function loadMinimumGroupSize() {
    if (!currentUser) return;

    // Load all notification preferences
    const reminderToggle = document.getElementById('event-reminders-toggle');
    if (reminderToggle) {
        reminderToggle.checked = currentUser.event_reminders_enabled || false;
    }

    // Load timezone preference
    const timezoneSelect = document.getElementById('timezone-select');
    if (timezoneSelect) {
        timezoneSelect.value = currentUser.timezone || 'America/Los_Angeles';
    }

    const newMatchToggle = document.getElementById('new-match-toggle');
    if (newMatchToggle) {
        newMatchToggle.checked = currentUser.notify_new_matches !== false; // Default true
    }

    const eventJoinToggle = document.getElementById('event-join-toggle');
    if (eventJoinToggle) {
        eventJoinToggle.checked = currentUser.notify_event_joins !== false; // Default true
    }

    const inactivityToggle = document.getElementById('inactivity-warnings-toggle');
    if (inactivityToggle) {
        inactivityToggle.checked = currentUser.notify_inactivity_warnings !== false; // Default true
    }

    const chatToggle = document.getElementById('chat-messages-toggle');
    if (chatToggle) {
        chatToggle.checked = currentUser.notify_chat_messages !== false; // Default true
    }

    // Load dark mode preference
    const darkModeToggle = document.getElementById('dark-mode-toggle');
    if (darkModeToggle) {
        const isDarkMode = currentUser.dark_mode_enabled || false;
        darkModeToggle.checked = isDarkMode;
        // Apply dark mode on load
        if (isDarkMode) {
            document.body.classList.add('dark-mode');
        }
    }
}

window.changeUsername = async function() {
    const newName = document.getElementById('new-username').value.trim();

    if (!newName) {
        return showNotification('Please enter a name', 'error');
    }

    try {
        const { error } = await supabase
            .from('profiles')
            .update({ name: newName })
            .eq('id', currentUser.id);

        if (error) throw error;

        currentUser.name = newName;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser);

        updateProfile();
        document.getElementById('new-username').value = '';

        showNotification('Name updated successfully!');

    } catch (error) {
        console.error('Error changing username:', error);
        showNotification('Error updating name', 'error');
    }
}

window.uploadProfilePicture = async function(event) {
    const file = event.target.files[0];

    if (!file) {
        return;
    }

    // SECURITY: Rate limiting - max 3 uploads per minute
    if (!RateLimiter.checkLimit('file_upload', 3, 60000)) {
        const remaining = RateLimiter.getRemaining('file_upload', 3, 60000);
        const waitTime = remaining === 0 ? '1 minute' : `${60 - remaining * 20} seconds`;
        return showNotification(`Too many uploads. Please wait ${waitTime} before trying again.`, 'error');
    }

    // SECURITY: Comprehensive file upload validation

    // 1. Validate file extension (whitelist only safe formats)
    const allowedExtensions = ['jpg', 'jpeg', 'png', 'webp'];
    const fileExt = file.name.split('.').pop().toLowerCase();

    if (!allowedExtensions.includes(fileExt)) {
        return showNotification(`Only ${allowedExtensions.join(', ').toUpperCase()} images are allowed`, 'error');
    }

    // 2. Validate MIME type matches extension
    const expectedMimeTypes = {
        'jpg': 'image/jpeg',
        'jpeg': 'image/jpeg',
        'png': 'image/png',
        'webp': 'image/webp'
    };

    const expectedMime = expectedMimeTypes[fileExt];
    if (!file.type || file.type !== expectedMime) {
        return showNotification('File type does not match extension. Please select a valid image.', 'error');
    }

    // 3. Validate file size (max 5MB)
    if (file.size > 5 * 1024 * 1024) {
        return showNotification('Image must be less than 5MB', 'error');
    }

    // 4. Validate image dimensions (max 4096x4096)
    // Create a promise to load and validate the image
    const validateImageDimensions = new Promise((resolve, reject) => {
        const img = new Image();
        const url = URL.createObjectURL(file);

        img.onload = function() {
            URL.revokeObjectURL(url); // Clean up

            if (this.width > 4096 || this.height > 4096) {
                reject(new Error('Image dimensions must not exceed 4096x4096 pixels'));
            } else if (this.width < 10 || this.height < 10) {
                reject(new Error('Image is too small. Minimum size is 10x10 pixels'));
            } else {
                resolve({ width: this.width, height: this.height });
            }
        };

        img.onerror = function() {
            URL.revokeObjectURL(url);
            reject(new Error('Invalid image file. File may be corrupted.'));
        };

        img.src = url;
    });

    try {
        // Wait for dimension validation to complete
        showLoader('Validating image...');
        await validateImageDimensions;

        showLoader('Uploading profile picture...');
        const fileName = `${currentUser.id}/avatar.${fileExt}`;

        // Delete old avatar if exists
        const { data: existingFiles } = await supabase.storage
            .from('avatars')
            .list(currentUser.id);

        if (existingFiles && existingFiles.length > 0) {
            for (const oldFile of existingFiles) {
                await supabase.storage
                    .from('avatars')
                    .remove([`${currentUser.id}/${oldFile.name}`]);
            }
        }

        // Upload new avatar
        const { error: uploadError } = await supabase.storage
            .from('avatars')
            .upload(fileName, file, {
                cacheControl: '3600',
                upsert: true
            });

        if (uploadError) throw uploadError;

        // Get public URL
        const { data: urlData } = supabase.storage
            .from('avatars')
            .getPublicUrl(fileName);

        const avatarUrl = urlData.publicUrl;

        // Update profile with new avatar URL
        const { error: updateError } = await supabase
            .from('profiles')
            .update({ avatar: avatarUrl })
            .eq('id', currentUser.id);

        if (updateError) throw updateError;

        // Update current user and UI
        currentUser.avatar = avatarUrl;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser);

        updateProfile();
        hideLoader();
        showNotification('Profile picture updated successfully!');

    } catch (error) {
        console.error('Error uploading profile picture:', error);
        hideLoader();
        // Show specific error message if validation failed, otherwise generic error
        const errorMessage = error.message || 'Error uploading profile picture';
        showNotification(errorMessage, 'error');
    }
}

window.removeProfilePicture = async function() {
    if (!confirm('Are you sure you want to remove your profile picture?')) {
        return;
    }

    try {
        showLoader('Removing profile picture...');

        // Delete avatar from storage if it's a URL
        if (currentUser.avatar && currentUser.avatar.includes('supabase')) {
            const { data: existingFiles } = await supabase.storage
                .from('avatars')
                .list(currentUser.id);

            if (existingFiles && existingFiles.length > 0) {
                for (const file of existingFiles) {
                    await supabase.storage
                        .from('avatars')
                        .remove([`${currentUser.id}/${file.name}`]);
                }
            }
        }

        // Set default emoji avatar
        const defaultAvatar = '😊';

        // Update profile with default avatar
        const { error: updateError } = await supabase
            .from('profiles')
            .update({ avatar: defaultAvatar })
            .eq('id', currentUser.id);

        if (updateError) throw updateError;

        // Update current user and UI
        currentUser.avatar = defaultAvatar;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser);

        updateProfile();
        hideLoader();
        showNotification('Profile picture removed');

    } catch (error) {
        console.error('Error removing profile picture:', error);
        hideLoader();
        showNotification('Error removing profile picture', 'error');
    }
}

// Camera functionality
let cameraStream = null;
let cameraContext = 'register'; // 'register' or 'settings'

window.openRegisterCamera = async function() {
    cameraContext = 'register';
    await openCameraModal();
}

window.openSettingsCamera = async function() {
    cameraContext = 'settings';
    await openCameraModal();
}

async function openCameraModal() {
    const modal = document.getElementById('camera-modal');
    const video = document.getElementById('camera-video');

    try {
        // Request camera access
        cameraStream = await navigator.mediaDevices.getUserMedia({
            video: {
                facingMode: 'user',
                width: { ideal: 1280 },
                height: { ideal: 720 }
            }
        });

        video.srcObject = cameraStream;
        modal.style.display = 'flex';
    } catch (error) {
        console.error('Error accessing camera:', error);
        if (error.name === 'NotAllowedError') {
            showNotification('Camera access denied. Please enable camera permissions in your browser.', 'error');
        } else if (error.name === 'NotFoundError') {
            showNotification('No camera found on this device.', 'error');
        } else {
            showNotification('Error accessing camera: ' + error.message, 'error');
        }
    }
}

window.closeCameraModal = function() {
    const modal = document.getElementById('camera-modal');
    const video = document.getElementById('camera-video');

    // Stop camera stream
    if (cameraStream) {
        cameraStream.getTracks().forEach(track => track.stop());
        cameraStream = null;
    }

    video.srcObject = null;
    modal.style.display = 'none';
}

window.capturePhoto = function() {
    const video = document.getElementById('camera-video');
    const canvas = document.getElementById('camera-canvas');

    // Set canvas dimensions to match video
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    // Draw video frame to canvas
    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    // Convert canvas to blob
    canvas.toBlob(async (blob) => {
        if (!blob) {
            showNotification('Error capturing photo', 'error');
            return;
        }

        // Close camera modal
        closeCameraModal();

        // Create a file from the blob
        const file = new File([blob], 'camera-photo.jpg', { type: 'image/jpeg' });

        // Handle the captured photo based on context
        if (cameraContext === 'register') {
            await handleRegisterPhotoCapture(file);
        } else {
            await handleSettingsPhotoCapture(file);
        }
    }, 'image/jpeg', 0.9);
}

// Registration photo handling
window.registerPhotoFile = null;

window.handleRegisterPhotoUpload = async function(event) {
    const file = event.target.files[0];
    if (!file) return;

    await handleRegisterPhotoCapture(file);
}

async function handleRegisterPhotoCapture(file) {
    // Validate file
    const allowedExtensions = ['jpg', 'jpeg', 'png', 'webp'];
    const fileExt = file.name.split('.').pop().toLowerCase();

    if (!allowedExtensions.includes(fileExt) && file.type === 'image/jpeg') {
        // Allow camera captures which are always JPEG
    } else if (!allowedExtensions.includes(fileExt)) {
        return showNotification(`Only ${allowedExtensions.join(', ').toUpperCase()} images are allowed`, 'error');
    }

    // Validate file size (max 5MB)
    if (file.size > 5 * 1024 * 1024) {
        return showNotification('Image must be less than 5MB', 'error');
    }

    // Validate image dimensions
    const validateImageDimensions = new Promise((resolve, reject) => {
        const img = new Image();
        const url = URL.createObjectURL(file);

        img.onload = function() {
            URL.revokeObjectURL(url);

            if (this.width > 4096 || this.height > 4096) {
                reject(new Error('Image dimensions must not exceed 4096x4096 pixels'));
            } else if (this.width < 10 || this.height < 10) {
                reject(new Error('Image is too small. Minimum size is 10x10 pixels'));
            } else {
                resolve({ width: this.width, height: this.height, url: URL.createObjectURL(file) });
            }
        };

        img.onerror = function() {
            URL.revokeObjectURL(url);
            reject(new Error('Invalid image file. File may be corrupted.'));
        };

        img.src = url;
    });

    try {
        const { url: previewUrl } = await validateImageDimensions;

        // Store the file for upload during registration
        window.registerPhotoFile = file;

        // Update preview
        const preview = document.getElementById('register-profile-preview');
        const display = document.getElementById('register-avatar-display');

        display.innerHTML = '';
        display.style.fontSize = '0';
        preview.style.backgroundImage = `url(${previewUrl})`;
        preview.style.backgroundSize = 'cover';
        preview.style.backgroundPosition = 'center';

        // Deselect any emoji avatars
        const avatars = document.querySelectorAll('#register-form .avatar-option');
        avatars.forEach(a => a.classList.remove('selected'));

        showNotification('Photo ready! Complete the form to create your account.');
    } catch (error) {
        console.error('Error validating image:', error);
        showNotification(error.message || 'Error processing image', 'error');
    }
}

async function handleSettingsPhotoCapture(file) {
    // Create a fake event object for uploadProfilePicture
    const fakeEvent = {
        target: {
            files: [file]
        }
    };

    await uploadProfilePicture(fakeEvent);
}

// Photo menu functionality
let photoMenuContext = 'settings'; // 'settings' or 'register'

window.showSettingsPhotoMenu = function(event) {
    event.stopPropagation();
    photoMenuContext = 'settings';

    // Show remove option if user has a photo
    const hasPhoto = currentUser && currentUser.avatar && currentUser.avatar.includes('supabase');
    const removeOption = document.getElementById('photo-menu-remove');
    if (removeOption) {
        removeOption.style.display = hasPhoto ? 'block' : 'none';
    }

    showPhotoMenuAtPosition(event.clientX, event.clientY);
}

window.showRegisterPhotoMenu = function(event) {
    event.stopPropagation();
    photoMenuContext = 'register';

    // Hide remove option for registration
    const removeOption = document.getElementById('photo-menu-remove');
    if (removeOption) {
        removeOption.style.display = 'none';
    }

    showPhotoMenuAtPosition(event.clientX, event.clientY);
}

function showPhotoMenuAtPosition(x, y) {
    const menu = document.getElementById('photo-menu');
    menu.style.display = 'block';

    // Position the menu
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';

    // Adjust if menu goes off screen
    setTimeout(() => {
        const rect = menu.getBoundingClientRect();
        if (rect.right > window.innerWidth) {
            menu.style.left = (window.innerWidth - rect.width - 10) + 'px';
        }
        if (rect.bottom > window.innerHeight) {
            menu.style.top = (window.innerHeight - rect.height - 10) + 'px';
        }
    }, 0);

    // Close menu when clicking outside
    setTimeout(() => {
        document.addEventListener('click', closePhotoMenu, { once: true });
    }, 0);
}

function closePhotoMenu() {
    const menu = document.getElementById('photo-menu');
    menu.style.display = 'none';
}

window.handlePhotoMenuAction = async function(action) {
    closePhotoMenu();

    if (action === 'camera') {
        if (photoMenuContext === 'settings') {
            await openSettingsCamera();
        } else {
            await openRegisterCamera();
        }
    } else if (action === 'upload') {
        if (photoMenuContext === 'settings') {
            document.getElementById('profile-picture-input').click();
        } else {
            document.getElementById('register-photo-input').click();
        }
    } else if (action === 'remove') {
        // Show avatar selection modal
        showAvatarSelectionModal();
    }
}

// Avatar selection modal
window.showAvatarSelectionModal = function() {
    const modal = document.getElementById('avatar-selection-modal');
    modal.style.display = 'flex';

    // Set up click handlers for avatar options in the modal
    const avatars = modal.querySelectorAll('.avatar-option');
    avatars.forEach(option => {
        option.addEventListener('click', function() {
            avatars.forEach(o => o.classList.remove('selected'));
            this.classList.add('selected');
        });
    });
}

window.closeAvatarSelectionModal = function() {
    const modal = document.getElementById('avatar-selection-modal');
    modal.style.display = 'none';

    // Clear selections
    const avatars = modal.querySelectorAll('.avatar-option');
    avatars.forEach(o => o.classList.remove('selected'));
}

window.confirmAvatarSelection = async function() {
    const modal = document.getElementById('avatar-selection-modal');
    const selectedAvatar = modal.querySelector('.avatar-option.selected');

    if (!selectedAvatar) {
        showNotification('Please select an avatar', 'error');
        return;
    }

    const avatarEmoji = selectedAvatar.dataset.avatar;

    try {
        showLoader('Updating profile picture...');

        // Delete avatar from storage if it exists
        if (currentUser.avatar && currentUser.avatar.includes('supabase')) {
            const { data: existingFiles } = await supabase.storage
                .from('avatars')
                .list(currentUser.id);

            if (existingFiles && existingFiles.length > 0) {
                for (const file of existingFiles) {
                    await supabase.storage
                        .from('avatars')
                        .remove([`${currentUser.id}/${file.name}`]);
                }
            }
        }

        // Update profile with selected avatar
        const { error: updateError } = await supabase
            .from('profiles')
            .update({ avatar: avatarEmoji })
            .eq('id', currentUser.id);

        if (updateError) throw updateError;

        // Update current user and UI
        currentUser.avatar = avatarEmoji;
        SecureStorage.setUserId(currentUser.id);
        SecureStorage.setSessionData(currentUser);

        updateProfile();
        hideLoader();
        closeAvatarSelectionModal();
        showNotification('Avatar updated successfully!');

    } catch (error) {
        console.error('Error updating avatar:', error);
        hideLoader();
        showNotification('Error updating avatar', 'error');
    }
}

window.toggleEventReminders = async function() {
    const toggle = document.getElementById('event-reminders-toggle');
    const isEnabled = toggle.checked;

    try {
        showLoader('Updating settings...');

        const { error } = await supabase
            .from('profiles')
            .update({ event_reminders_enabled: isEnabled })
            .eq('id', currentUser.id);

        if (error) throw error;

        currentUser.event_reminders_enabled = isEnabled;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser);

        hideLoader();
        showNotification(isEnabled ? '🔔 Event reminders enabled!' : '🔕 Event reminders disabled');

    } catch (error) {
        hideLoader();
        console.error('Error toggling event reminders:', error);
        showNotification('Error updating setting', 'error');
        // Revert toggle on error
        toggle.checked = !isEnabled;
    }
}

window.updateTimezone = async function() {
    const select = document.getElementById('timezone-select');
    const timezone = select.value;

    try {
        showLoader('Updating timezone...');

        const { error } = await supabase
            .from('profiles')
            .update({ timezone: timezone })
            .eq('id', currentUser.id);

        if (error) throw error;

        currentUser.timezone = timezone;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser);

        hideLoader();
        showNotification('Timezone updated!');

    } catch (error) {
        hideLoader();
        console.error('Error updating timezone:', error);
        showNotification('Error updating timezone', 'error');
    }
}

window.toggleNewMatches = async function() {
    const toggle = document.getElementById('new-match-toggle');
    const isEnabled = toggle.checked;

    try {
        const { error } = await supabase
            .from('profiles')
            .update({ notify_new_matches: isEnabled })
            .eq('id', currentUser.id);

        if (error) throw error;

        currentUser.notify_new_matches = isEnabled;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser);

        showNotification(isEnabled ? '🔔 New match notifications enabled!' : '🔕 New match notifications disabled');

    } catch (error) {
        console.error('Error toggling new match notifications:', error);
        showNotification('Error updating setting', 'error');
        toggle.checked = !isEnabled;
    }
}

window.toggleEventJoins = async function() {
    const toggle = document.getElementById('event-join-toggle');
    const isEnabled = toggle.checked;

    try {
        const { error } = await supabase
            .from('profiles')
            .update({ notify_event_joins: isEnabled })
            .eq('id', currentUser.id);

        if (error) throw error;

        currentUser.notify_event_joins = isEnabled;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser);

        showNotification(isEnabled ? '🔔 Event join notifications enabled!' : '🔕 Event join notifications disabled');

    } catch (error) {
        console.error('Error toggling event join notifications:', error);
        showNotification('Error updating setting', 'error');
        toggle.checked = !isEnabled;
    }
}

window.toggleInactivityWarnings = async function() {
    const toggle = document.getElementById('inactivity-warnings-toggle');
    const isEnabled = toggle.checked;

    try {
        const { error } = await supabase
            .from('profiles')
            .update({ notify_inactivity_warnings: isEnabled })
            .eq('id', currentUser.id);

        if (error) throw error;

        currentUser.notify_inactivity_warnings = isEnabled;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser);

        showNotification(isEnabled ? '🔔 Inactivity warnings enabled!' : '🔕 Inactivity warnings disabled');

    } catch (error) {
        console.error('Error toggling inactivity warnings:', error);
        showNotification('Error updating setting', 'error');
        toggle.checked = !isEnabled;
    }
}

window.toggleChatMessages = async function() {
    const toggle = document.getElementById('chat-messages-toggle');
    const isEnabled = toggle.checked;

    try {
        const { error } = await supabase
            .from('profiles')
            .update({ notify_chat_messages: isEnabled })
            .eq('id', currentUser.id);

        if (error) throw error;

        currentUser.notify_chat_messages = isEnabled;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser);

        showNotification(isEnabled ? '🔔 Chat notifications enabled!' : '🔕 Chat notifications disabled');

    } catch (error) {
        console.error('Error toggling chat notifications:', error);
        showNotification('Error updating setting', 'error');
        toggle.checked = !isEnabled;
    }
}

window.toggleDarkMode = async function() {
    const toggle = document.getElementById('dark-mode-toggle');
    const isEnabled = toggle.checked;

    try {
        // Apply dark mode immediately for smooth UX
        if (isEnabled) {
            document.body.classList.add('dark-mode');
        } else {
            document.body.classList.remove('dark-mode');
        }

        const { error } = await supabase
            .from('profiles')
            .update({ dark_mode_enabled: isEnabled })
            .eq('id', currentUser.id);

        if (error) throw error;

        currentUser.dark_mode_enabled = isEnabled;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser);

        showNotification(isEnabled ? '🌙 Dark mode enabled!' : '☀️ Light mode enabled');

    } catch (error) {
        console.error('Error toggling dark mode:', error);
        showNotification('Error updating setting', 'error');
        // Revert dark mode on error
        toggle.checked = !isEnabled;
        if (isEnabled) {
            document.body.classList.remove('dark-mode');
        } else {
            document.body.classList.add('dark-mode');
        }
    }
}

window.changePassword = async function() {
    const newPassword = document.getElementById('new-password').value;
    const confirmPassword = document.getElementById('confirm-password').value;
    
    if (!newPassword || !confirmPassword) {
        return showNotification('Please fill in both password fields', 'error');
    }
    
    if (newPassword.length < 6) {
        return showNotification('New password must be at least 6 characters', 'error');
    }
    
    if (newPassword !== confirmPassword) {
        return showNotification('Passwords do not match', 'error');
    }
    
    try {
        const { error } = await supabase.auth.updateUser({
            password: newPassword
        });
        
        if (error) throw error;
        
        document.getElementById('new-password').value = '';
        document.getElementById('confirm-password').value = '';
        
        showNotification('Password updated successfully!');
        
    } catch (error) {
        console.error('Error changing password:', error);
        showNotification(error.message || 'Error updating password', 'error');
    }
}

        document.querySelectorAll('.avatar-option').forEach(option => {
            option.addEventListener('click', function() {
                document.querySelectorAll('.avatar-option').forEach(o => o.classList.remove('selected'));
                this.classList.add('selected');
            });
        });

        // Circle Management
        window.showCreateCircle = () => { document.getElementById('create-circle').style.display = 'block'; document.getElementById('circle-modal-overlay').style.display = 'flex'; };
        window.showJoinCircle = () => { document.getElementById('join-circle').style.display = 'block'; document.getElementById('circle-modal-overlay').style.display = 'flex'; };
        window.closeCircleModal = () => { document.getElementById('circle-modal-overlay').style.display = 'none'; document.getElementById('create-circle').style.display = 'none'; document.getElementById('join-circle').style.display = 'none'; };
	window.goToCircleStep2 = async function() {
    const name = document.getElementById('circle-name').value.trim();
    
    if (!name) {
        return showNotification('Please enter a circle name', 'error');
    }
    
    // Hide step 1, show step 2
    document.getElementById('circle-step-1').style.display = 'none';
    document.getElementById('circle-step-2').style.display = 'block';
    
    // Load and render activities (no previous selections on first load)
    await renderCircleCreationActivities();
}

window.goBackToCircleStep1 = function() {
    document.getElementById('circle-step-2').style.display = 'none';
    document.getElementById('circle-step-1').style.display = 'block';
}

async function renderCircleCreationActivities(previousSelections = new Set(), autoSelectId = null) {
    const grid = document.getElementById('circle-creation-activities-grid');
    grid.innerHTML = '';

    // Show helpful message if no default activities are available
    if (!defaultActivities || defaultActivities.length === 0) {
        grid.innerHTML = `
            <div style="grid-column: 1/-1; text-align: center; padding: 40px 20px; color: #666;">
                <div style="font-size: 3em; margin-bottom: 20px;">🎯</div>
                <h3 style="margin-bottom: 15px; color: #333;">No Default Activities Available</h3>
                <p style="margin-bottom: 20px;">The database needs to be seeded with default activities.</p>
                <p style="font-size: 0.9em; color: #999;">For now, you can create custom activities by clicking the "+ Custom Activity" button above.</p>
            </div>
        `;
        updateCircleSelectedCount();
        return;
    }

    // Render all default activities
    defaultActivities.forEach(activity => {
        const card = document.createElement('div');
        card.className = 'activity-card';
        card.dataset.activityId = activity.id;

        // Restore previous selections or auto-select new activity
        if (previousSelections.has(activity.id) || activity.id === autoSelectId) {
            card.classList.add('selected');
        }

        card.innerHTML = `
            <div class="activity-emoji">${activity.emoji || '🎯'}</div>
            <div class="activity-name">${activity.name}</div>
        `;

        card.onclick = () => {
            card.classList.toggle('selected');
            updateCircleSelectedCount();
        };

        grid.appendChild(card);
    });

    updateCircleSelectedCount();
}

function updateCircleSelectedCount() {
    const selectedCards = document.querySelectorAll('#circle-creation-activities-grid .activity-card.selected');
    const count = selectedCards.length;
    
    document.getElementById('circle-selected-count').textContent = count;
    
    const createBtn = document.getElementById('circle-create-btn');
    const warning = document.getElementById('circle-min-warning');
    
    if (count >= 4) {
        createBtn.disabled = false;
        createBtn.style.opacity = '1';
        createBtn.style.cursor = 'pointer';
        warning.style.display = 'none';
    } else {
        createBtn.disabled = true;
        createBtn.style.opacity = '0.5';
        createBtn.style.cursor = 'not-allowed';
        warning.style.display = 'block';
    }
}

window.finalizeCircleCreation = async function() {
    const name = document.getElementById('circle-name').value.trim();
    
    if (!name) {
        return showNotification('Please enter a circle name', 'error');
    }
    
    // Get selected activities
    const selectedCards = document.querySelectorAll('#circle-creation-activities-grid .activity-card.selected');
    const selectedActivityIds = Array.from(selectedCards).map(card => card.dataset.activityId);
    
    if (selectedActivityIds.length < 4) {
        return showNotification('Please select at least 4 activities', 'error');
    }
    
    showLoader('Creating circle...');
    
    try {
        const code = generateCode();
        
        // Insert into circles
        const { data: circle, error } = await supabase
            .from('circles')
            .insert([{ name, code, created_by: currentUser.id }])
            .select()
            .single();
        
        if (error) throw error;
        
        // Add creator as a member
        await supabase.from('circle_members').insert([{ 
            circle_id: circle.id, 
            profile_id: currentUser.id 
        }]);
        
        // Save any custom activities that were suggested during creation
        const customActivities = defaultActivities.filter(a => 
            typeof a.id === 'string' && a.id.startsWith('temp_')
        );
        
        const activityIdMapping = {}; // Maps temp IDs to real IDs
        
        for (const customActivity of customActivities) {
            const { data: newActivity, error: actError } = await supabase
                .from('activities')
                .insert([{
                    name: customActivity.name,
                    emoji: customActivity.emoji,
                    category: 'custom',
                    circle_id: circle.id
                }])
                .select()
                .single();
            
            if (!actError && newActivity) {
                activityIdMapping[customActivity.id] = newActivity.id;
            }
        }
        
        // Update selected IDs to use real IDs instead of temp IDs
        const finalSelectedIds = selectedActivityIds.map(id => 
            activityIdMapping[id] || id
        );
        
        // Set activity visibility for this circle
        if (finalSelectedIds.length > 0) {
            // Get all default activity IDs (excluding temp ones)
            const allDefaultIds = defaultActivities
                .filter(a => !(typeof a.id === 'string' && a.id.startsWith('temp_')))
                .map(a => a.id);
            
            // Create visibility records for default activities
            const visibilityRecords = allDefaultIds.map(activityId => ({
                circle_id: circle.id,
                activity_id: activityId,
                is_visible: finalSelectedIds.includes(activityId)
            }));
            
            await supabase
                .from('circle_activities')
                .insert(visibilityRecords);
        }
        
        // Clean up temp activities from defaultActivities
        defaultActivities = defaultActivities.filter(a => 
            !(typeof a.id === 'string' && a.id.startsWith('temp_'))
        );
        
        circles.push(circle);
        
        // Reset modal
        document.getElementById('circle-name').value = '';
        document.getElementById('circle-step-2').style.display = 'none';
        document.getElementById('circle-step-1').style.display = 'block';
        
        closeCircleModal();
        hideLoader();
        renderCircles();
        
        showNotification(`Circle created! Share code: ${circle.code}`);
        
    } catch (error) {
        hideLoader();
        console.error('Error creating circle:', error);
        showNotification('Could not create circle', 'error');
    }
}

        
        window.joinCircle = async function() {
  const code = document.getElementById('circle-code').value.trim();
  if (!code) return;

  // Find the circle by code
  const { data: circle, error } = await supabase
    .from('circles')
    .select('*')
    .eq('code', code)
    .single();

  if (error || !circle) {
    return showNotification('Circle not found', 'error');
  }

  // Add user to circle_members
  await supabase.from('circle_members').insert([{ circle_id: circle.id, profile_id: currentUser.id }]);

  circles.push(circle);
  closeCircleModal();
  renderCircles();
  showNotification(`Joined Circle!`);

  // Mark that user joined their first circle for PWA prompt
  markCircleJoined();

  // Show PWA install prompt after a short delay
  setTimeout(() => {
    showPWAPrompt();
  }, 1500);
}

        async function renderCircles() {
  showLoader('Loading circles...');

  try {
    // Get circles with last_read_at for unread tracking
    const { data, error } = await supabase
      .from('circle_members')
      .select(`
        circle_id,
        circles(*),
        profile_id,
        last_read_at
      `)
      .eq('profile_id', currentUser.id);

    if (error) throw error;

    circles = data.map(d => d.circles);

    // Create map of circle_id -> last_read_at
    const lastReadMap = new Map();
    data.forEach(d => {
      lastReadMap.set(d.circle_id, d.last_read_at);
    });

    // Get member counts for each circle
    const circleIds = circles.map(c => c.id);
    const { data: memberCounts, error: countError } = await supabase
      .from('circle_members')
      .select('circle_id')
      .in('circle_id', circleIds);

    if (countError) throw countError;

    // Count members per circle
    const counts = {};
    memberCounts.forEach(member => {
      counts[member.circle_id] = (counts[member.circle_id] || 0) + 1;
    });

    // Get unread counts for all circles in parallel
    const unreadPromises = circles.map(circle =>
      getCircleUnreadCount(circle.id, lastReadMap.get(circle.id))
    );
    const unreadCounts = await Promise.all(unreadPromises);

    // Create map of circle_id -> unread count
    const unreadMap = new Map();
    circles.forEach((circle, index) => {
      unreadMap.set(circle.id, unreadCounts[index]);
    });

    const list = document.getElementById('circles-list');

    if (circles.length === 0) {
      list.innerHTML = `
        <div class="empty-state">
          <div class="empty-state-icon">👥</div>
          <div class="empty-state-title">No Circles Yet</div>
          <div class="empty-state-description">Circles are your friend groups. Create one to start coordinating activities, or join an existing circle with an invite code.</div>
          <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
            <button class="btn" onclick="showCreateCircle()">+ Create Circle</button>
            <button class="btn btn-secondary" onclick="showJoinCircle()">Join Circle</button>
          </div>
        </div>`;
      hideLoader();
      return;
    }

    list.innerHTML = circles.map(circle => {
      const memberCount = counts[circle.id] || 0;
      const memberText = memberCount === 1 ? '1 member' : `${memberCount} members`;
      const unreadCount = unreadMap.get(circle.id) || 0;

      // Escape single quotes in circle name and code for onclick handlers
      const escapedName = circle.name.replace(/'/g, "\\'");
      const escapedCode = circle.code.replace(/'/g, "\\'");

      return `
        <div class="circle-card${unreadCount > 0 ? ' unread' : ''}">
          <div class="main-content" onclick='selectCircle("${circle.id}")'>
            <div class="circle-name">
              ${circle.name}
            </div>
            <div class="circle-members">${memberText}</div>
            <div class="circle-code">Invite Code: <strong>${circle.code}</strong></div>
          </div>
          <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 10px;">
    <button class="btn btn-small" onclick="event.stopPropagation(); openCircleChat('${circle.id}')" style="width: 100%; background: #667eea;">💬 Open Circle Chat</button>
    <button class="btn btn-small btn-secondary" onclick="event.stopPropagation(); viewCircleMembers('${circle.id}')" style="width: 100%;">👥 View Members</button>
    <div style="display: flex; gap: 8px;">
        <button class="btn btn-small btn-secondary" onclick="event.stopPropagation(); copyCircleCode('${escapedCode}')" style="flex: 1;">Copy Code</button>
        <button class="btn btn-small btn-secondary" onclick="event.stopPropagation(); inviteByEmail('${escapedName}', '${escapedCode}')" style="flex: 1;">Invite</button>
    </div>
    <div style="display: flex; gap: 8px;">
        <button class="btn btn-small btn-secondary" onclick="event.stopPropagation(); renameCircle('${circle.id}')" style="flex: 1;">Rename</button>
        <button class="btn btn-small" onclick="event.stopPropagation(); leaveCircle('${circle.id}')" style="background: #dc3545; flex: 1;">Leave</button>
    </div>
</div>
        </div>`;
    }).join('');
    } catch (error) {
    console.error('Error loading circles:', error);
    circles = [];
  } finally {
    hideLoader();
  }
}

window.leaveCircle = async function(circleId) {
  if (!confirm("Are you sure you want to leave this circle?")) return;
  
  showLoader('Leaving circle...');
  
  try {
    // Check if user is the last member
    const { data: members, error: membersError } = await supabase
      .from('circle_members')
      .select('profile_id')
      .eq('circle_id', circleId);
    
    if (membersError) throw membersError;
    
    const isLastMember = members && members.length === 1;
    
    // Delete your membership
    const { error: deleteError } = await supabase
      .from('circle_members')
      .delete()
      .eq('circle_id', circleId)
      .eq('profile_id', currentUser.id);
    
    if (deleteError) throw deleteError;
    
    // If last member, delete the entire circle
    if (isLastMember) {
      await deleteCircle(circleId);
      hideLoader();
      showNotification("Circle deleted (you were the last member)");
    } else {
      hideLoader();
      showNotification("You left the circle.");
    }
    
    // Refresh circles list
    await renderCircles();
    
  } catch (error) {
    hideLoader();
    console.error('Error leaving circle:', error);
    showNotification("Error leaving circle", "error");
  }
};

async function deleteCircle(circleId) {
  try {
    console.log('🗑️ Deleting empty circle:', circleId);
    
    // Delete all related data (Supabase should handle cascades, but let's be explicit)
    
    // 1. Delete circle_activities
    await supabase
      .from('circle_activities')
      .delete()
      .eq('circle_id', circleId);
    
    // 2. Delete preferences
    await supabase
      .from('preferences')
      .delete()
      .eq('circle_id', circleId);
    
    // 3. Delete match_participants (for matches in this circle)
    const { data: circleMatches } = await supabase
      .from('matches')
      .select('id')
      .eq('circle_id', circleId);
    
    if (circleMatches && circleMatches.length > 0) {
      const matchIds = circleMatches.map(m => m.id);
      
      await supabase
        .from('match_participants')
        .delete()
        .in('match_id', matchIds);
      
      // 4. Delete match_messages
      await supabase
        .from('match_messages')
        .delete()
        .in('match_id', matchIds);
    }
    
    // 5. Delete events and related data
    const { data: circleEvents } = await supabase
      .from('events')
      .select('id')
      .eq('circle_id', circleId);
    
    if (circleEvents && circleEvents.length > 0) {
      const eventIds = circleEvents.map(e => e.id);
      
      // Delete event_participants
      await supabase
        .from('event_participants')
        .delete()
        .in('event_id', eventIds);
      
      // Delete event_messages
      await supabase
        .from('event_messages')
        .delete()
        .in('event_id', eventIds);
      
      // Delete events
      await supabase
        .from('events')
        .delete()
        .in('id', eventIds);
    }
    
    // 6. Delete matches
    await supabase
      .from('matches')
      .delete()
      .eq('circle_id', circleId);
    
    // 7. Delete custom activities for this circle
    await supabase
      .from('activities')
      .delete()
      .eq('circle_id', circleId);
    
    // 8. Finally, delete the circle itself
    const { error: circleError } = await supabase
      .from('circles')
      .delete()
      .eq('id', circleId);
    
    if (circleError) throw circleError;
    
    console.log('✅ Circle and all related data deleted');
    
  } catch (error) {
    console.error('Error deleting circle:', error);
    throw error;
  }
}

window.copyCircleCode = function(code) {
    navigator.clipboard.writeText(code).then(() => {
        showNotification('Circle code ' + code + ' copied to clipboard!');
    }).catch(() => {
        const textArea = document.createElement('textarea');
        textArea.value = code;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        showNotification('Circle code ' + code + ' copied to clipboard!');
    });
}

window.inviteByEmail = function(circleName, circleCode) {
    const subject = encodeURIComponent('Join my "' + circleName + '" circle on Friendle');
    const appUrl = 'https://friendlecircles.app/';
    const inviteUrl = appUrl + '?invite_code=' + circleCode;
    
    const body = encodeURIComponent(
    'Hi! I would like to invite you to join my "' + circleName + '" circle on Friendle.\n\n' +
    'Join us for coffee, hiking, and whatever else comes up.\n\n' +
    'CLICK THIS LINK TO JOIN:\n' +
    inviteUrl + '\n\n' +
    '(Copy and paste the link above into your browser if it does not appear clickable)\n\n' +
    'Or visit ' + appUrl + ' and manually enter code: ' + circleCode + '\n\n' +
    'Looking forward to planning some fun activities together!'
);
    
    const mailtoLink = 'mailto:?subject=' + subject + '&body=' + body;
    window.open(mailtoLink, '_self');
}

window.renameCircle = async function(circleId) {
    const circle = circles.find(c => c.id === circleId);

    if (!circle) {
        showNotification('Circle not found', 'error');
        return;
    }

    const newName = prompt('Enter new circle name:', circle.name);

    if (!newName || !newName.trim()) {
        return; // User cancelled or entered empty name
    }

    if (newName.trim() === circle.name) {
        return; // No change
    }

    try {
        const { error } = await supabase
            .from('circles')
            .update({ name: newName.trim() })
            .eq('id', circleId)
            .eq('created_by', currentUser.id); // Only creator can rename

        if (error) {
            if (error.code === '42501') {
                showNotification('Only the circle creator can rename it', 'error');
            } else {
                throw error;
            }
            return;
        }

        showNotification('Circle renamed!');
        await renderCircles(); // Refresh the display
    } catch (error) {
        console.error('Error renaming circle:', error);
        showNotification('Error renaming circle', 'error');
    }
}

window.viewCircleMembers = async function(circleId) {
    const circle = circles.find(c => c.id === circleId);

    if (!circle) {
        showNotification('Circle not found', 'error');
        return;
    }

    try {
        showLoader('Loading members...');

        const { data: members, error } = await supabase
            .from('circle_members')
            .select('profile_id, profiles(id, name, avatar)')
            .eq('circle_id', circleId);

        if (error) throw error;

        hideLoader();

        if (!members || members.length === 0) {
            alert('No members found in this circle.');
            return;
        }

        const membersList = members
            .map(m => {
                // Only show emoji avatars, not URLs
                const avatar = m.profiles.avatar && !m.profiles.avatar.startsWith('http')
                    ? `${m.profiles.avatar} `
                    : '';
                return `${avatar}${m.profiles.name}`;
            })
            .join('\n');

        alert(`Members of ${circle.name}:\n\n${membersList}`);
    } catch (error) {
        hideLoader();
        console.error('Error loading circle members:', error);
        showNotification('Error loading members', 'error');
    }
}

// Save user preferences to Supabase
async function saveUserPreferences(circleId, selectedActivityIds) {
    try {

        // First, clear existing preferences for this circle
        const { error: deleteError } = await supabase
            .from('preferences')
            .delete()
            .eq('profile_id', currentUser.id)
            .eq('circle_id', circleId);

        if (deleteError) {
            console.error('Delete error:', deleteError);
            throw deleteError;
        }

        // Then insert new preferences (only if there are selections)
        if (selectedActivityIds.length > 0) {
            const preferences = selectedActivityIds.map(activityId => ({
                profile_id: currentUser.id,
                circle_id: circleId,
                activity_id: activityId.toString(),
                selected: true
            }));

            const { error: insertError } = await supabase
                .from('preferences')
                .insert(preferences);

            if (insertError) {
                console.error('Insert error:', insertError);
                throw insertError;
            }
            
            // Verify what was saved
            const { data: verifyData } = await supabase
                .from('preferences')
                .select('activity_id')
                .eq('profile_id', currentUser.id)
                .eq('circle_id', circleId);

        } else {

        }

        showNotification('Preferences saved!');
    } catch (error) {
        console.error('Error saving preferences:', error);
        showNotification('Error saving preferences', 'error');
    }
}

// Load user preferences from Supabase
async function loadUserPreferences(circleId) {
    try {
        
        const { data, error } = await supabase
            .from('preferences')
            .select('activity_id')
            .eq('profile_id', currentUser.id)
            .eq('circle_id', circleId)
            .eq('selected', true);

        if (error) throw error;
        
        const activityIds = data.map(pref => pref.activity_id);
        
        return activityIds;
    } catch (error) {
        console.error('Error loading preferences:', error);
        return [];
    }
}

        // In selectCircle, after filtering:
window.selectCircle = async function(circleId) {
    selectedCircle = circles.find(c => c.id === circleId);
    
    localStorage.setItem('friendle_last_circle', circleId);
    
    const savedActivityIds = await loadUserPreferences(selectedCircle.id);
    const allActivities = await loadActivities(selectedCircle.id);
    
    activities = allActivities.filter(activity => savedActivityIds.includes(activity.id));
    
        skipAutoLoad = true;
    showPage('activities');
    
    const selector = document.getElementById('circle-selector');
    if (selector) {
        selector.value = circleId;
    }
    
    renderActivities();
}

async function populateCircleSelector() {
    const selector = document.getElementById('circle-selector');
    if (!selector) return;
    
    selector.innerHTML = '<option value="">Choose a circle...</option>';
    
    circles.forEach(circle => {
        const option = document.createElement('option');
        option.value = circle.id;
        option.textContent = circle.name;
        selector.appendChild(option);
    });
    
    if (skipAutoLoad) {
        skipAutoLoad = false;
        return;
    }
    
    // Auto-select last used circle or first circle
    const lastCircleId = localStorage.getItem('friendle_last_circle');
    if (lastCircleId && circles.find(c => c.id === lastCircleId)) {
        selector.value = lastCircleId;
        await handleCircleChange(false);
    } else if (circles.length > 0) {
        selector.value = circles[0].id;
        await handleCircleChange(false);
    }
    
    // Initialize swipe view if we're in swipe mode AFTER circle is loaded
    if (viewMode === 'swipe' && selectedCircle) {
        await initializeSwipeView();
    }
}

window.handleCircleChange = async function(shouldScroll = true) {
    const selector = document.getElementById('circle-selector');
    const circleId = selector.value;
    
    if (!circleId) {
        hideLoader(); // Clear any existing loader
        selectedCircle = null;
        activities = [];
        document.getElementById('activities-grid').innerHTML = '';
        document.getElementById('frequent-grid').innerHTML = '';
        document.getElementById('frequent-section').style.display = 'none';
        return;
    }
    
    localStorage.setItem('friendle_last_circle', circleId);
    
    showLoader('Loading activities...');
    
    selectedCircle = circles.find(c => c.id === circleId);
    
    const savedActivityIds = await loadUserPreferences(selectedCircle.id);
    const allActivities = await loadActivities(selectedCircle.id);
    
    activities = allActivities.filter(activity => savedActivityIds.includes(activity.id));
    
    renderActivities();
    
    // If in swipe mode, reinitialize swipe view
    if (viewMode === 'swipe') {
        await initializeSwipeView();
    }
    
    hideLoader();
    
    if (shouldScroll) {
        document.getElementById('activity-search').scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
}

// View mode switching
let viewMode = 'swipe'; // Default to swipe view

window.switchToGridView = function() {
    viewMode = 'grid';
    document.getElementById('swipe-view-container').style.display = 'none';
    document.getElementById('grid-view-container').style.display = 'block';
    
    // Update button styles
    document.getElementById('grid-view-btn').style.background = '#667eea';
    document.getElementById('grid-view-btn').style.color = 'white';
    document.getElementById('swipe-view-btn').style.background = '#f8f9fa';
    document.getElementById('swipe-view-btn').style.color = '#333';
    
    // Show save button in grid mode
    document.getElementById('grid-save-button').style.display = 'block';
    
    renderActivities(); // Render grid view
}

window.switchToSwipeView = async function() {
    viewMode = 'swipe';
    document.getElementById('grid-view-container').style.display = 'none';
    document.getElementById('swipe-view-container').style.display = 'block';
    
    // Update button styles
    document.getElementById('swipe-view-btn').style.background = '#667eea';
    document.getElementById('swipe-view-btn').style.color = 'white';
    document.getElementById('grid-view-btn').style.background = '#f8f9fa';
    document.getElementById('grid-view-btn').style.color = '#333';
    
    // Hide save button in swipe mode
    document.getElementById('grid-save-button').style.display = 'none';
    
    await initializeSwipeView(); // Initialize swipe cards
}

// Swipe view state
let currentCardIndex = 0;
let swipeHistory = [];
let sortedActivities = [];

window.initializeSwipeView = async function() {
    if (!selectedCircle) {
        document.getElementById('card-stack').innerHTML = '<div style="text-align: center; padding: 60px; color: #666;">Please select a circle first</div>';
        return;
    }
    
    // Load and sort activities
    sortedActivities = await loadActivitiesForSwiping(selectedCircle.id);
    currentCardIndex = 0;
    swipeHistory = [];
    
    // Clear card stack
    document.getElementById('card-stack').innerHTML = '';
    
    if (sortedActivities.length === 0) {
        document.getElementById('card-stack').innerHTML = '<div class="empty-state"><div class="empty-state-icon">🎯</div><div class="empty-state-title">No Activities Available</div><div class="empty-state-description">Add some activities to your circle to get started!</div></div>';
        return;
    }
    
    // Show first card
    showNextCard();
}

async function loadActivitiesForSwiping(circleId) {
    // Get all visible activities
    const allActivities = await loadActivities(circleId);
    
    // Get user's current preferences to filter out already selected
    const userPrefs = await loadUserPreferences(circleId);
    // Convert all IDs to strings for consistent comparison
const alreadySelectedIds = new Set(userPrefs.map(id => id.toString()));
    
    // Filter out activities user has already selected
// Convert both to strings for comparison since IDs might be mixed types
const availableActivities = allActivities.filter(activity => 
    !alreadySelectedIds.has(activity.id.toString())
);
    
    // Get what others in circle have selected
    const { data: circlePrefs } = await supabase
        .from('preferences')
        .select('activity_id, profile_id')
        .eq('circle_id', circleId)
        .neq('profile_id', currentUser.id);
    
    // Count popularity
    const popularityCounts = {};
    circlePrefs?.forEach(pref => {
        popularityCounts[pref.activity_id] = (popularityCounts[pref.activity_id] || 0) + 1;
    });
    
    // Sort activities by priority
    return availableActivities.sort((a, b) => {
        const aPopular = popularityCounts[a.id] || 0;
        const bPopular = popularityCounts[b.id] || 0;
        const aFrequent = activityCounts[a.id] || 0;
        const bFrequent = activityCounts[b.id] || 0;
        const aCore = coreActivityIds.includes(a.id) ? 1 : 0;
        const bCore = coreActivityIds.includes(b.id) ? 1 : 0;
        
        // Priority: popular > frequent > core > alphabetical
        if (aPopular !== bPopular) return bPopular - aPopular;
        if (aFrequent !== bFrequent) return bFrequent - aFrequent;
        if (aCore !== bCore) return bCore - aCore;
        return a.name.localeCompare(b.name);
    }).map(activity => ({
        ...activity,
        popularityCount: popularityCounts[activity.id] || 0
    }));
}

function filterSwipeActivities(searchTerm) {
    if (!searchTerm.trim()) {
        // No search term - reload all activities
        initializeSwipeView();
        return;
    }
    
    // Re-load and filter activities
    loadActivitiesForSwiping(selectedCircle.id).then(allActivities => {
        sortedActivities = allActivities.filter(a => 
            a.name.toLowerCase().includes(searchTerm.toLowerCase())
        );
        
        currentCardIndex = 0;
        swipeHistory = [];
        
        document.getElementById('card-stack').innerHTML = '';
        
        if (sortedActivities.length === 0) {
            document.getElementById('card-stack').innerHTML = 
                '<div class="empty-state"><div class="empty-state-icon">🔍</div><div class="empty-state-title">No Matches Found</div><div class="empty-state-description">Try a different search term</div></div>';
            document.getElementById('swipe-progress').textContent = 'No results';
        } else {
            showNextCard();
        }
    });
}

function showNextCard() {
    if (currentCardIndex >= sortedActivities.length) {
    // All done!
    document.getElementById('card-stack').innerHTML = `
        <div style="text-align: center; padding: 60px;">
            <div style="font-size: 4em;">🎉</div>
            <h2>All done!</h2>
            <p>You've reviewed all activities</p>
            <button class="btn" onclick="showPage('matches')">View Matches</button>
        </div>
    `;
    document.getElementById('swipe-progress').textContent = 'Complete!';
    return;
}
    
    const activity = sortedActivities[currentCardIndex];
    const card = renderSwipeCard(activity);
    document.getElementById('card-stack').innerHTML = '';
    document.getElementById('card-stack').appendChild(card);
    updateProgress();
}

function updateProgress() {
    const total = sortedActivities.length;
    const current = Math.min(currentCardIndex + 1, total);
    document.getElementById('swipe-progress').textContent = `${current} of ${total}`;
}

function renderSwipeCard(activity) {
    const card = document.createElement('div');
    card.className = 'swipe-card';
    card.id = `card-${activity.id}`;

    // Check for dark mode
    const isDarkMode = document.body.classList.contains('dark-mode');
    const bgColor = isDarkMode ? '#1a1a1e' : 'white';
    const borderColor = isDarkMode ? '#2a2a2e' : '#e1e5e9';
    const textColor = isDarkMode ? '#e5e5e7' : '#1a1a1a';

    card.style.cssText = `
        position: absolute;
        width: 100%;
        max-width: 350px;
        height: 400px;
        background: ${bgColor};
        border: 3px solid ${borderColor};
        border-radius: 20px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 40px;
        cursor: grab;
        user-select: none;
        transition: transform 0.1s ease-out;
    `;

    const isAlreadySelected = activities.some(a => a.id === activity.id);

    card.innerHTML = `
        <div style="font-size: 5em; margin-bottom: 20px;">${activity.emoji}</div>
        <h2 style="font-size: 1.8em; margin-bottom: 10px; text-align: center; color: ${textColor};">${activity.name}</h2>
        ${activity.popularityCount > 0 ? `
            <div style="
                background: linear-gradient(135deg, #667eea, #764ba2);
                color: white;
                padding: 8px 16px;
                border-radius: 20px;
                font-size: 0.9em;
                margin-top: 10px;
            ">
                ✨ ${activity.popularityCount} friend${activity.popularityCount > 1 ? 's' : ''} interested
            </div>
        ` : ''}
        ${isAlreadySelected ? `
            <div style="
                background: #4CAF50;
                color: white;
                padding: 6px 12px;
                border-radius: 15px;
                font-size: 0.85em;
                margin-top: 10px;
            ">
                ✓ Already selected
            </div>
        ` : ''}
    `;

    setupSwipeDetection(card, activity);
    return card;
}

// Animation functions (must be defined before setupSwipeDetection)
async function animateSwipeRight(card, activity) {
    
    card.style.transition = 'all 0.3s ease-out';
    card.style.transform = 'translateX(500px) rotate(30deg)';
    card.style.opacity = '0';
    
    // Add to selected activities
    if (!activities.some(a => a.id === activity.id)) {
        activities.push(activity);
        console.log('Added activity to array');
    } else {
        console.log('Activity already in array - skipping');
    }
    
    console.log('activities array after add:', activities.map(a => a.id));
    
    // Save to history for undo
    swipeHistory.push({ activity, wasSelected: true });
    
    // Auto-save preference immediately
    const selectedActivityIds = activities.map(a => a.id);
    console.log('Saving to database:', selectedActivityIds.length, 'activities');
    await saveUserPreferences(selectedCircle.id, selectedActivityIds);
    
    // Update activity counts
    activityCounts[activity.id] = (activityCounts[activity.id] || 0) + 1;
    localStorage.setItem('friendle_activity_counts', JSON.stringify(activityCounts));
    
    // Check if match exists and get other interested users
    const { data: existingMatch } = await supabase
        .from('matches')
        .select('id')
        .eq('circle_id', selectedCircle.id)
        .eq('activity_id', activity.id)
        .single();
    
    if (existingMatch) {
        // Get other users interested in this activity
        const { data: otherParticipants } = await supabase
            .from('match_participants')
            .select('profile_id, profiles(id, name, avatar)')
            .eq('match_id', existingMatch.id)
            .neq('profile_id', currentUser.id);
        
        const otherUsers = otherParticipants?.map(p => p.profiles) || [];
        
        // Show match notification
        showMatchNotification(activity, existingMatch.id, otherUsers);
    }
    
    console.log('Calling checkForMatches...');
    // Check for new matches and send notifications
    await checkForMatches();
    
    console.log('Calling loadMatches...');
    // Reload matches to see any changes
    await loadMatches();
    
    setTimeout(() => {
        currentCardIndex++;
        showNextCard();
    }, 300);
}

function animateSwipeLeft(card, activity) {
    card.style.transition = 'all 0.3s ease-out';
    card.style.transform = 'translateX(-500px) rotate(-30deg)';
    card.style.opacity = '0';
    
    // Remove from selected activities if it was there
    const index = activities.findIndex(a => a.id === activity.id);
    const wasSelected = index > -1;
    if (wasSelected) {
        activities.splice(index, 1);
    }
    
    // Save to history for undo
    swipeHistory.push({ activity, wasSelected });
    
    setTimeout(() => {
        currentCardIndex++;
        showNextCard();
    }, 300);
}

function setupSwipeDetection(card, activity) {
    let startX = 0;
    let startY = 0;
    let currentX = 0;
    let currentY = 0;
    let isDragging = false;
    
    // Touch events for mobile
    card.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        isDragging = true;
        card.style.cursor = 'grabbing';
    });
    
    card.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        
        currentX = e.touches[0].clientX;
        currentY = e.touches[0].clientY;
        const deltaX = currentX - startX;
        const deltaY = currentY - startY;
        
        // Move card and rotate slightly
        card.style.transform = `translateX(${deltaX}px) translateY(${deltaY}px) rotate(${deltaX * 0.1}deg)`;
        card.style.transition = 'none';
        
        // Color hint
        if (deltaX > 50) {
            card.style.borderColor = '#4CAF50'; // Green for like
        } else if (deltaX < -50) {
            card.style.borderColor = '#f44336'; // Red for pass
        } else {
            card.style.borderColor = '#e1e5e9';
        }
    });
    
    card.addEventListener('touchend', (e) => {
        if (!isDragging) return;
        isDragging = false;
        card.style.cursor = 'grab';
        
        const deltaX = currentX - startX;
        
        if (deltaX > 100) {
            // Swiped right - interested
            animateSwipeRight(card, activity);
        } else if (deltaX < -100) {
            // Swiped left - pass
            animateSwipeLeft(card, activity);
        } else {
            // Reset position
            card.style.transition = 'transform 0.3s ease-out';
            card.style.transform = '';
            card.style.borderColor = '#e1e5e9';
        }
    });
    
    // Mouse events for desktop
    card.addEventListener('mousedown', (e) => {
        startX = e.clientX;
        startY = e.clientY;
        isDragging = true;
        card.style.cursor = 'grabbing';
    });
    
    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        currentX = e.clientX;
        currentY = e.clientY;
        const deltaX = currentX - startX;
        const deltaY = currentY - startY;
        
        // Move card and rotate slightly
        card.style.transform = `translateX(${deltaX}px) translateY(${deltaY}px) rotate(${deltaX * 0.1}deg)`;
        card.style.transition = 'none';
        
        // Color hint
        if (deltaX > 50) {
            card.style.borderColor = '#4CAF50';
        } else if (deltaX < -50) {
            card.style.borderColor = '#f44336';
        } else {
            card.style.borderColor = '#e1e5e9';
        }
    });
    
    document.addEventListener('mouseup', (e) => {
        if (!isDragging) return;
        isDragging = false;
        card.style.cursor = 'grab';
        
        const deltaX = currentX - startX;
        
        if (deltaX > 100) {
            animateSwipeRight(card, activity);
        } else if (deltaX < -100) {
            animateSwipeLeft(card, activity);
        } else {
            card.style.transition = 'transform 0.3s ease-out';
            card.style.transform = '';
            card.style.borderColor = '#e1e5e9';
        }
    });
}

function animateSwipeLeft(card, activity) {
    card.style.transition = 'all 0.3s ease-out';
    card.style.transform = 'translateX(-500px) rotate(-30deg)';
    card.style.opacity = '0';
    
    // Remove from selected activities if it was there
    const index = activities.findIndex(a => a.id === activity.id);
    const wasSelected = index > -1;
    if (wasSelected) {
        activities.splice(index, 1);
    }
    
    // Save to history for undo
    swipeHistory.push({ activity, wasSelected });
    
    setTimeout(() => {
        currentCardIndex++;
        showNextCard();
    }, 300);
}

// Button functions for non-touch devices
window.swipeRight = function() {
    if (currentCardIndex >= sortedActivities.length) return;
    
    const card = document.getElementById(`card-${sortedActivities[currentCardIndex].id}`);
    const activity = sortedActivities[currentCardIndex];
    
    if (card) {
        animateSwipeRight(card, activity);
    }
}

window.swipeLeft = function() {
    if (currentCardIndex >= sortedActivities.length) return;
    
    const card = document.getElementById(`card-${sortedActivities[currentCardIndex].id}`);
    const activity = sortedActivities[currentCardIndex];
    
    if (card) {
        animateSwipeLeft(card, activity);
    }
}

window.undoSwipe = async function() {
    
    if (swipeHistory.length === 0) {
        showNotification('Nothing to undo', 'error');
        return;
    }
    
    const lastAction = swipeHistory.pop();
    console.log('Undoing action:', lastAction);
    
    // Reverse the swipe action
    if (lastAction.wasSelected) {
        // If they swiped right (selected), now remove it
        const index = activities.findIndex(a => a.id === lastAction.activity.id);
        if (index > -1) {
            activities.splice(index, 1);
            console.log('Removed activity:', lastAction.activity.id);
        }
    } else {
        // If they swiped left (passed), now add it back
        if (!activities.some(a => a.id === lastAction.activity.id)) {
            activities.push(lastAction.activity);
            console.log('Added back activity:', lastAction.activity.id);
        }
    }
    
    console.log('activities AFTER undo:', activities.map(a => a.id));
    
    // Save the reverted preference state immediately
    const selectedActivityIds = activities.map(a => a.id);
    console.log('Saving preferences:', selectedActivityIds);
    await saveUserPreferences(selectedCircle.id, selectedActivityIds);
    
    console.log('Skipping loadMatches to avoid auto-join');
    // Don't call loadMatches here - it might trigger auto-join logic
    // await loadMatches();
    
    // Go back one card
    currentCardIndex = Math.max(0, currentCardIndex - 1);
    showNextCard();
    
    console.log('=== UNDO END ===');
    showNotification('Undone!');
}

async function loadActivities(circleId) {
    try {
        const { data: customActivities, error: activitiesError } = await supabase
            .from('activities')
            .select('*')
            .eq('circle_id', circleId);
        
        if (activitiesError) throw activitiesError;
        
        const { data: circleActivities, error: visibilityError } = await supabase
            .from('circle_activities')
            .select('activity_id, is_visible')
            .eq('circle_id', circleId);
        
        if (visibilityError) throw visibilityError;
        
        const visibilityMap = {};
        circleActivities?.forEach(ca => {
            visibilityMap[ca.activity_id] = ca.is_visible;
        });
        
        const visibleDefaultActivities = defaultActivities.filter(a => {
            if (visibilityMap.hasOwnProperty(a.id)) {
                return visibilityMap[a.id];
            }
            return coreActivityIds.includes(a.id);
        });
        
        return [...visibleDefaultActivities, ...customActivities];
    } catch (error) {
        console.error('Error loading activities:', error);
        return [];
    }
}

let coreActivityIds = [];
let extendedActivityIds = [];
let defaultActivities = [];

async function loadDefaultActivities() {
    try {
        // Load all default activities from database (where circle_id is null)
        const { data, error } = await supabase
            .from('activities')
            .select('*')
            .is('circle_id', null);

        if (error) throw error;

        defaultActivities = data || [];

        // Warn if no default activities found
        if (!defaultActivities || defaultActivities.length === 0) {
            console.warn('⚠️ No default activities found in database! Users will need to create custom activities.');
            console.warn('To fix: Run MIGRATION_seed_default_activities.sql in your Supabase SQL editor.');
            defaultActivities = [];
        }

        // Split into core and extended based on a category or naming convention
        // For now, let's say activities with IDs < 200 are core (adjust as needed)
        coreActivityIds = defaultActivities.filter(a => {
            // Define which activities are "core" - adjust these names as needed
            const coreNames = ['Coffee', 'Dinner', 'Drinks', 'Brunch', 'Pizza Night', 'Ice Cream',
                               'Hiking', 'Beach', 'Bowling', 'Walk in the Park',
                               'Movie', 'Trivia Night', 'Arcade', 'Board Games'];
            return coreNames.includes(a.name);
        }).map(a => a.id);

        extendedActivityIds = defaultActivities.filter(a => !coreActivityIds.includes(a.id)).map(a => a.id);

        console.log('Loaded default activities:', defaultActivities.length, 'activities');
        console.log('Core activity IDs:', coreActivityIds.length, 'core activities');
        console.log('Extended activity IDs:', extendedActivityIds.length, 'extended activities');

    } catch (error) {
        console.error('Error loading default activities:', error);
        defaultActivities = [];
        coreActivityIds = [];
        extendedActivityIds = [];
    }
}
        // Activity Management
        async function renderActivities(searchTerm = '') {
     		// Check if no circle is selected
    if (!selectedCircle) {
        document.getElementById('activities-grid').innerHTML = '<div style="text-align: center; padding: 40px 20px; color: #666;"><div style="font-size: 3em; margin-bottom: 20px;">🎯</div><h3 style="margin-bottom: 15px; color: #333;">Select a Circle First</h3><p>Choose a circle from the dropdown above to see available activities.</p></div>';
        document.getElementById('frequent-grid').innerHTML = '';
        document.getElementById('frequent-section').style.display = 'none';
        return;
    }

    const frequentGrid = document.getElementById('frequent-grid');
    const activitiesGrid = document.getElementById('activities-grid');
    frequentGrid.innerHTML = ''; 
    activitiesGrid.innerHTML = '';
    
    const sortedCounts = Object.entries(activityCounts).sort(([,a],[,b]) => b-a);
    const frequentIds = sortedCounts.slice(0, 4).map(([id]) => parseInt(id));
    
    // Load activities from both default + Supabase
    const allPossibleActivities = await loadActivities(selectedCircle.id);
    
    const filteredActivities = allPossibleActivities.filter(a => 
        a.name.toLowerCase().includes(searchTerm.toLowerCase())
    );

    const frequentActivities = filteredActivities.filter(a => frequentIds.includes(a.id));
    document.getElementById('frequent-section').style.display = 
        frequentActivities.length > 0 && !searchTerm ? 'block' : 'none';
    for (const activity of frequentActivities) {
    await createActivityCard(activity, frequentGrid);
}

    const nonFrequentActivities = filteredActivities.filter(a => !frequentIds.includes(a.id));
    for (const activity of nonFrequentActivities) {
    await createActivityCard(activity, activitiesGrid);
}
}
        async function createActivityCard(activity, grid) {
    const card = document.createElement('div');
    card.className = 'activity-card';
    card.dataset.activityId = activity.id;
    
    const isSelected = activities.some(a => a.id === activity.id);
    if (isSelected) card.classList.add('selected');
    
    // Check if marked as "today"
    const isToday = await isActivityAvailableToday(activity.id);
    
    card.innerHTML = `
        <div class="activity-emoji">${activity.emoji}</div>
        <div class="activity-name">${activity.name}</div>
    `;
    
    card.onclick = (event) => {
        event.stopPropagation();
        toggleActivity(card, activity);
    };
    
    grid.appendChild(card);
}

async function isActivityAvailableToday(activityId) {
    if (!selectedCircle || !currentUser) return false;
    
    try {
        const { data, error } = await supabase
            .from('activity_availability')
            .select('available_until')
            .eq('profile_id', currentUser.id)
            .eq('circle_id', selectedCircle.id)
            .eq('activity_id', activityId.toString())
            .maybeSingle();
        
        if (error) throw error;
        
        // Check if still valid
        if (data && new Date(data.available_until) > new Date()) {
            return true;
        }
        
        // If expired, clean it up
        if (data) {
            await supabase
                .from('activity_availability')
                .delete()
                .eq('profile_id', currentUser.id)
                .eq('circle_id', selectedCircle.id)
                .eq('activity_id', activityId.toString());
        }
        
        return false;
    } catch (error) {
        console.error('Error checking activity availability:', error);
        return false;
    }
}

window.setActivityMode = async function(activityId, isToday) {
    if (!selectedCircle) return;
    
    try {
        if (isToday) {
            // Set to TODAY
            const endOfDay = new Date();
            endOfDay.setHours(23, 59, 59, 999);
            
            await supabase
                .from('activity_availability')
                .upsert({
                    profile_id: currentUser.id,
                    circle_id: selectedCircle.id,
                    activity_id: activityId.toString(),
                    available_until: endOfDay.toISOString()
                }, {
                    onConflict: 'profile_id,circle_id,activity_id'
                });
            
            showNotification('Available for this activity today!');
        } else {
            // Set to ANYTIME (remove from today)
            await supabase
                .from('activity_availability')
                .delete()
                .eq('profile_id', currentUser.id)
                .eq('circle_id', selectedCircle.id)
                .eq('activity_id', activityId.toString());
            
            showNotification('Switched to "Anytime"');
        }
        
        // Refresh the card
        await renderActivities();
        
        // Refresh matches
        await checkForMatches();
        
    } catch (error) {
        console.error('Error setting activity mode:', error);
        showNotification('Error updating availability', 'error');
    }
}

        function toggleActivity(card, activity) {
            lastActivitiesState = [...activities];
            card.classList.toggle('selected');
            const index = activities.findIndex(a => a.id === activity.id);
            if (index > -1) activities.splice(index, 1);
            else activities.push(activity);
        }
        window.handleSearch = (event) => {
    const searchTerm = event.target.value;
    
    if (viewMode === 'grid') {
        renderActivities(searchTerm);
    } else {
        filterSwipeActivities(searchTerm);
    }
}
        window.saveActivities = async function() {
    if (!selectedCircle) return showNotification('Please select a circle first', 'error');

    // SECURITY: Rate limiting - max 10 preference updates per minute
    if (!RateLimiter.checkLimit('save_activities', 10, 60000)) {
        return showNotification('Please wait before saving again.', 'error');
    }

    // Hide the save button immediately to prevent visual shifting
    const saveButton = document.getElementById('grid-save-button');
    if (saveButton) saveButton.style.display = 'none';

    showLoader('Saving preferences...');

    try {
        const selectedActivityIds = activities.map(activity => activity.id);
        
        // Get previously selected activities to find what was deselected
        const previousPrefs = await loadUserPreferences(selectedCircle.id);
        const deselectedActivityIds = previousPrefs.filter(id => !selectedActivityIds.includes(id));
        
        // For each deselected activity, check if user has any events
        for (const activityId of deselectedActivityIds) {
            // Find the match for this activity
            const { data: match } = await supabase
                .from('matches')
                .select('id')
                .eq('circle_id', selectedCircle.id)
                .eq('activity_id', activityId)
                .single();
            
            if (match) {
                // Check if user has any events for this match
                const { data: userEvents } = await supabase
                    .from('event_participants')
                    .select('event_id, events!inner(match_id)')
                    .eq('profile_id', currentUser.id)
                    .eq('events.match_id', match.id);
                
                // If no events, remove user from match participants
                if (!userEvents || userEvents.length === 0) {
                    await supabase
                        .from('match_participants')
                        .delete()
                        .eq('match_id', match.id)
                        .eq('profile_id', currentUser.id);
                }
            }
        }
        
        // Save new preferences
        await saveUserPreferences(selectedCircle.id, selectedActivityIds);
        
        activities.forEach(act => { 
            activityCounts[act.id] = (activityCounts[act.id] || 0) + 1; 
        });
        localStorage.setItem('friendle_activity_counts', JSON.stringify(activityCounts));
        
        await checkForMatches();
        await loadMatches();
        
        hideLoader();
        showPage('matches');
        
    } catch (error) {
        hideLoader();
        // Restore the save button if there's an error
        const saveButton = document.getElementById('grid-save-button');
        if (saveButton) saveButton.style.display = '';
        console.error('Error saving activities:', error);
        showNotification('Error saving preferences', 'error');
    }
}
        window.openSuggestModal = () => {
    document.getElementById('suggest-modal-overlay').style.display = 'flex';
}
        window.closeSuggestModal = () => document.getElementById('suggest-modal-overlay').style.display = 'none';
        window.suggestActivity = async function() {
    const name = document.getElementById('suggest-name').value.trim();
    if (!name) { 
        return showNotification('Please provide an activity name', 'error'); 
    }

    try {
        // Check if we're in circle creation mode (no selectedCircle yet)
        const isCircleCreation = !selectedCircle;
        
        if (isCircleCreation) {
            // Save current selections before re-rendering
            const currentlySelected = new Set(
                Array.from(document.querySelectorAll('#circle-creation-activities-grid .activity-card.selected'))
                    .map(card => card.dataset.activityId)
            );
            
            // Add to default activities temporarily (for this session only)
            const newActivity = {
                id: 'temp_' + Date.now(), // Temporary ID
                name: name,
                emoji: '💡',
                category: 'custom',
                circle_id: null // Will be set when circle is created
            };
            
            defaultActivities.push(newActivity);
            
            showNotification(`Activity "${name}" added and selected!`);
            closeSuggestModal();
            
            // Re-render circle creation activities with previous selections + new one
            await renderCircleCreationActivities(currentlySelected, newActivity.id);
            
        } else {
            // Normal flow - circle already exists
            const { data, error } = await supabase
                .from('activities')
                .insert([{
                    name: name,
                    emoji: '💡',
                    category: 'custom',
                    circle_id: selectedCircle.id
                }])
                .select()
                .single();

            if (error) throw error;
            
            showNotification(`Activity "${name}" added!`);
            closeSuggestModal();
            
            const savedActivityIds = await loadUserPreferences(selectedCircle.id);
            const allActivities = await loadActivities(selectedCircle.id);
            activities = allActivities.filter(activity => savedActivityIds.includes(activity.id));
            
            renderActivities();
        }
    } catch (error) {
        console.error('Error adding custom activity:', error);
        showNotification('Error adding activity', 'error');
    }
}
        
        window.undoLastActivityChange = function() {
            activities = [...lastActivitiesState];
            renderActivities();
            document.getElementById('undo-container').style.display = 'none';
            clearTimeout(undoTimeout);
        }
async function findMatches(circleId) {
    try {
        // Get current user's preferences
        const userPrefs = await loadUserPreferences(circleId);
        if (userPrefs.length === 0) {
            return [];
        }

        const groupMatches = [];

        // For each activity the user likes, find or create a match
        for (const activityId of userPrefs) {
            
            // Check if a match already exists for this activity in this circle
            const { data: existingMatches, error: matchError } = await supabase
                .from('matches')
                .select('id, circle_id, activity_id, created_at')
                .eq('circle_id', circleId)
                .eq('activity_id', activityId);

            if (matchError) {
                console.error('Error checking for existing match:', matchError);
                continue;
            }

            let match = existingMatches?.[0] || null;

            if (!match) {
                // Create new match (but DON'T auto-add user)
                const { data: newMatch, error: createError } = await supabase
                    .from('matches')
                    .insert([{
                        circle_id: circleId,
                        activity_id: activityId
                    }])
                    .select('*')
                    .single();

                if (createError) {
                    console.error('Error creating match:', createError);
                    continue;
                }

                match = newMatch;
            }

            // Get all users who have this activity in their preferences (interested)
            const { data: interestedUsers, error: prefsError } = await supabase
                .from('preferences')
                .select('profile_id, profiles(id, name, avatar)')
                .eq('circle_id', circleId)
                .eq('activity_id', activityId)
                .neq('profile_id', currentUser.id);

            if (prefsError) {
                console.error('Error loading interested users:', prefsError);
                continue;
            }

            // Get who's actually in the general chat
            const { data: chatParticipants, error: chatError } = await supabase
                .from('match_participants')
                .select('profile_id')
                .eq('match_id', match.id);

            if (chatError) {
                console.error('Error loading chat participants:', chatError);
            }

            const chatParticipantIds = new Set(chatParticipants?.map(p => p.profile_id) || []);
            const userInChat = chatParticipantIds.has(currentUser.id);

            // Get activity details
            const activity = activities.find(a => a.id === activityId);
            if (!activity) {
                // Load activity if not in current array
                const { data: activityData } = await supabase
                    .from('activities')
                    .select('*')
                    .eq('id', activityId)
                    .single();
                
                if (activityData) {
                    activities.push(activityData);
                }
            }

            groupMatches.push({
                id: match.id,
                circleId: circleId,
                activity: activity || activities.find(a => a.id === activityId),
                interestedUsers: interestedUsers?.map(u => u.profiles) || [],
                inChatCount: chatParticipants?.length || 0,
                userInChat: userInChat,
                isRead: true // We'll handle notifications differently now
            });
        }

        return groupMatches;
    } catch (error) {
        console.error('Error finding matches:', error);
        return [];
    }
}

// Helper function to join match chat
async function joinMatchChat(matchId) {
    try {
        // Check if already in chat
        const { data: existing } = await supabase
            .from('match_participants')
            .select('profile_id')
            .eq('match_id', matchId)
            .eq('profile_id', currentUser.id)
            .maybeSingle();

        if (existing) {
            console.log('Already in chat');
            return true;
        }

        // Add to match_participants
        const { error } = await supabase
            .from('match_participants')
            .insert([{
                match_id: matchId,
                profile_id: currentUser.id
            }]);

        if (error) throw error;

        console.log('✓ Joined match chat');
        return true;

    } catch (error) {
        console.error('Error joining match chat:', error);
        return false;
    }
}

// Helper function to leave match chat
async function leaveMatchChat(matchId) {
    try {
        const { error } = await supabase
            .from('match_participants')
            .delete()
            .eq('match_id', matchId)
            .eq('profile_id', currentUser.id);
        
        if (error) throw error;
        
        console.log('✓ Left match chat');
        return true;
        
    } catch (error) {
        console.error('Error leaving match chat:', error);
        return false;
    }
}

// Join chat as first person
window.joinMatchChatFirst = async function(matchId) {
    showLoader('Joining chat...');
    
    const success = await joinMatchChat(matchId);
    
    if (success) {
        hideLoader();
        showNotification('You\'re in! Others can now see and join.');
        await loadMatches();
    } else {
        hideLoader();
        showNotification('Error joining chat', 'error');
    }
}

// Skip joining for now
window.skipJoinChat = async function(matchId) {
    // Just close/refresh - user stays interested but not in chat
    showNotification('You can join the chat anytime from here');
}

// Stay Interested - reset inactivity timer
window.stayInterested = async function(matchId) {
    try {
        showLoader('Updating...');

        // Call edge function to update last_interaction_at
        const { data, error } = await supabase.functions.invoke('stay-interested', {
            body: {
                matchId: matchId,
                profileId: currentUser.id
            }
        });

        if (error) throw error;

        hideLoader();
        showNotification('Great! We\'ll keep you in the match.');

        // Reload matches to update UI
        await loadMatches();
    } catch (error) {
        console.error('Error updating interaction:', error);
        hideLoader();
        showNotification('Failed to update. Please try again.', 'error');
    }
}

// Mark as uninterested - remove from match
window.markAsUninterested = async function(matchId, activityId, circleId) {
    try {
        // Confirm with user
        if (!confirm('Are you sure you want to remove this activity from your preferences? You can always add it back later.')) {
            return;
        }

        showLoader('Removing activity...');

        // Check if user has any events for this match
        const { data: userEvents } = await supabase
            .from('event_participants')
            .select('event_id, events!inner(match_id)')
            .eq('profile_id', currentUser.id)
            .eq('events.match_id', matchId);

        // Remove user's preference for this activity
        const { error: prefError } = await supabase
            .from('preferences')
            .delete()
            .eq('profile_id', currentUser.id)
            .eq('circle_id', circleId)
            .eq('activity_id', activityId);

        if (prefError) throw prefError;

        // If no events, remove user from match participants
        if (!userEvents || userEvents.length === 0) {
            const { error: participantError } = await supabase
                .from('match_participants')
                .delete()
                .eq('match_id', matchId)
                .eq('profile_id', currentUser.id);

            if (participantError) throw participantError;
        }

        hideLoader();
        showNotification('Activity removed from your preferences');

        // Reload matches to update UI
        await loadMatches();
    } catch (error) {
        console.error('Error marking as uninterested:', error);
        hideLoader();
        showNotification('Failed to remove activity. Please try again.', 'error');
    }
}

// Join chat as normal (not first)
window.joinMatchChatNormal = async function(matchId) {
    showLoader('Joining chat...');
    
    const success = await joinMatchChat(matchId);
    
    if (success) {
        hideLoader();
        showNotification('Joined chat!');
        await loadMatches();
    } else {
        hideLoader();
        showNotification('Error joining chat', 'error');
    }
}

// Open threaded chat view
window.openMatchChatThreaded = async function(matchId) {
    try {
        console.log('🔄 Opening match chat:', matchId);
        showLoader('Loading chat...');
        
	// Mark match as read
        await markMatchAsRead(matchId);

        // Clean up ALL previous subscriptions
        if (matchMessageSubscription) {
            await supabase.removeChannel(matchMessageSubscription);
            const index = allActiveSubscriptions.indexOf(matchMessageSubscription);
            if (index > -1) allActiveSubscriptions.splice(index, 1);
            matchMessageSubscription = null;
        }
        
        if (eventMessageSubscription) {
            await supabase.removeChannel(eventMessageSubscription);
            const index = allActiveSubscriptions.indexOf(eventMessageSubscription);
            if (index > -1) allActiveSubscriptions.splice(index, 1);
            eventMessageSubscription = null;
        }
        
        // Find the match in local array first
        let match = matches.find(m => m.id === matchId);

        // If not found locally, fetch from database (handles notification deep linking)
        if (!match) {
            console.log('Match not in local array, fetching from database...');
            const { data: matchData, error: matchError } = await supabase
                .from('matches')
                .select(`
                    id,
                    circle_id,
                    activity_id,
                    created_at
                `)
                .eq('id', matchId)
                .single();

            if (matchError || !matchData) {
                hideLoader();
                console.error('Match not found in database:', matchError);
                showNotification('Match not found', 'error');
                return;
            }

            match = matchData;
        }

        // Set context using helper
        setMatchContext(match);
        
        // Get activity details
        let activity = activities.find(a => a.id === match.activity_id);
        if (!activity) {
            const { data: activityData } = await supabase
                .from('activities')
                .select('*')
                .eq('id', match.activity_id)
                .single();
            activity = activityData;
        }
        
        // Get all chat participants
        const { data: participants } = await supabase
            .from('match_participants')
            .select('profile_id, profiles(id, name, avatar)')
            .eq('match_id', matchId);
        
        // Get all events for this match
        const { data: allEvents } = await supabase
            .from('events')
            .select(`
                *,
                event_participants(profile_id, profiles(id, name, avatar))
            `)
            .eq('match_id', matchId)
            .order('scheduled_date', { ascending: true });
        
        // Update header
        document.getElementById('event-activity-name').textContent = 
            `${activity ? activity.emoji : '🎯'} ${activity ? activity.name : 'Activity'} Chat`;
        
        const participantProfiles = participants?.map(p => p.profiles.name) || [];
const participantCount = participants?.length || 1;

let participantDisplay;
if (participantCount === 1) {
    participantDisplay = 'Just you';
} else if (participantCount <= 3) {
    // Show all names
    participantDisplay = participantProfiles.join(', ');
} else {
    // Show first 2 and "X others" (clickable)
    const shown = participantProfiles.slice(0, 2).join(', ');
    const remaining = participantCount - 2;
    const allNames = participantProfiles.join('\\n');
    
    participantDisplay = `${shown}, and <a href="#" onclick="event.preventDefault(); alert('In chat:\\n\\n${allNames}');" style="color: white; text-decoration: underline; cursor: pointer;">${remaining} other${remaining > 1 ? 's' : ''}</a>`;
}

document.getElementById('event-participants').innerHTML = 
    `${participantCount} in chat: ${participantDisplay}`;
        
        // Hide event-specific buttons in general chat
        const generalChatBtn = document.getElementById('open-general-chat-btn');
        const addToCalendarBtn = document.getElementById('add-to-calendar-btn');
        const eventOptionsBtn = document.getElementById('event-options-btn');
        const leaveEventBtn = document.getElementById('leave-event-btn');
        
        if (generalChatBtn) generalChatBtn.style.display = 'none';
        if (addToCalendarBtn) addToCalendarBtn.style.display = 'none';
        if (eventOptionsBtn) eventOptionsBtn.style.display = 'none';
        if (leaveEventBtn) leaveEventBtn.style.display = 'none';
        
// Show mute button for match chats
        const muteChatBtn = document.getElementById('mute-chat-btn');
        if (muteChatBtn) {
            muteChatBtn.style.display = 'inline-block';
            updateMuteButton(matchId, null, null);
        }

        // Hide event details banner in general chat (redundant with event cards)
        document.getElementById('event-details').style.display = 'none';
        
	// Hide add to calendar button (only for event chats)
        const calendarBtn = document.getElementById('add-to-calendar-btn');
        if (calendarBtn) {
            calendarBtn.style.display = 'none';
        }

        // Render threaded chat UI
        await renderThreadedChat(matchId, allEvents || []);
        
        // Set up real-time subscription
        await setupMatchChatSubscription(matchId);
        
        hideLoader();
        showPage('chat');

        // Force scroll to bottom after page is shown (especially for notifications)
        setTimeout(() => forceScrollToBottom(), 300);

    } catch (error) {
        hideLoader();
        console.error('Error opening threaded chat:', error);
        showNotification('Error loading chat', 'error');
    }
}

async function renderThreadedChat(matchId, events) {
    const messagesContainer = document.getElementById('chat-messages');
    messagesContainer.innerHTML = '';

    console.log('🔍 renderThreadedChat called with events:', events);

    // Separate events into upcoming and past
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

    console.log('📅 Today date for comparison:', today);

    const upcomingEvents = events.filter(e => {
        const eventDate = e.scheduled_date ? new Date(e.scheduled_date) : null;
        const isUpcoming = (!e.scheduled_date || eventDate >= today) && e.status === 'scheduled';
        console.log(`Event ${e.id}: date=${e.scheduled_date}, status=${e.status}, isUpcoming=${isUpcoming}`);
        return isUpcoming;
    });
    const pastEvents = events.filter(e =>
        e.scheduled_date && new Date(e.scheduled_date) < today || e.status !== 'scheduled'
    );

    console.log('✅ Upcoming events count:', upcomingEvents.length);
    console.log('📦 Past events count:', pastEvents.length);

    // UPCOMING EVENTS FIRST (pinned at top)
    if (upcomingEvents.length > 0) {
        console.log('📌 Creating UPCOMING EVENTS section with', upcomingEvents.length, 'events');
        const upcomingSection = document.createElement('div');
        upcomingSection.style.cssText = 'margin-bottom: 20px; background: #f8f9fa; padding: 15px; border-radius: 10px;';
        upcomingSection.id = 'upcoming-events-section';

        // Create heading using createElement instead of innerHTML
        const heading = document.createElement('h4');
        heading.style.cssText = 'margin: 0 0 12px 0; font-size: 14px; color: #666; font-weight: 600;';
        heading.textContent = '📌 UPCOMING EVENTS';
        upcomingSection.appendChild(heading);

        console.log('  Heading appended, children count:', upcomingSection.children.length);

        upcomingEvents.forEach((event, index) => {
            console.log(`  Adding event card ${index + 1}/${upcomingEvents.length}:`, event);
            const eventCard = createEventCard(event, matchId);
            console.log('  Event card created:', eventCard);
            console.log('  Event card outerHTML preview:', eventCard.outerHTML.substring(0, 200));
            upcomingSection.appendChild(eventCard);
            console.log('  After appendChild, children count:', upcomingSection.children.length);
        });

        console.log('📦 Final upcomingSection children count:', upcomingSection.children.length);
        messagesContainer.appendChild(upcomingSection);
        console.log('✅ UPCOMING EVENTS section appended to messages container');
        console.log('✅ messagesContainer first child:', messagesContainer.firstChild);
    } else {
        console.log('⚠️ No upcoming events to display');
    }

    // PAST EVENTS SECOND (collapsed)
    if (pastEvents.length > 0) {
        const pastSection = document.createElement('details');
        pastSection.style.cssText = 'margin-bottom: 20px; padding: 10px; background: #f8f9fa; border-radius: 10px;';
        pastSection.innerHTML = `
            <summary style="cursor: pointer; font-size: 14px; color: #666; font-weight: 600; padding: 5px;">
                📂 Past Events (${pastEvents.length})
            </summary>
        `;

        const pastContainer = document.createElement('div');
        pastContainer.style.marginTop = '10px';

        pastEvents.forEach(event => {
            const eventCard = createEventCard(event, matchId, true);
            pastContainer.appendChild(eventCard);
        });

        pastSection.appendChild(pastContainer);
        messagesContainer.appendChild(pastSection);
    }
    
    // Create event button
    const createBtn = document.createElement('button');
    createBtn.className = 'btn btn-secondary';
    createBtn.textContent = '+ Create Event';
    createBtn.style.cssText = 'width: 100%; margin-bottom: 20px; font-size: 14px;';
    createBtn.onclick = () => openCreateEventModal(matchId);
    messagesContainer.appendChild(createBtn);

    // Load and display general messages (this function will add the "GENERAL CHAT" header)
    await loadAndDisplayGeneralMessages(matchId);
    
    // Scroll to bottom after a delay to let images load
    setTimeout(() => {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        console.log('📜 Scrolled to bottom');
    }, 500);
}

function createEventCard(event, matchId, isPast = false) {
    const eventCard = document.createElement('div');
    
    // Check if user has joined this event
    const isUserJoined = event.event_participants?.some(p => p.profile_id === currentUser.id) || false;
    
    eventCard.style.cssText = `
        padding: 12px;
        margin-bottom: 10px;
        background: ${isPast ? '#fafafa' : (isUserJoined ? '#f0f9ff' : '#fff8e1')};
        border-radius: 8px;
        border-left: 4px solid ${isPast ? '#ccc' : (isUserJoined ? '#4CAF50' : '#FFA726')};
        ${isPast ? 'opacity: 0.7;' : ''}
    `;
    
    // Format date
    const dateStr = event.scheduled_date ? 
        new Date(event.scheduled_date).toLocaleDateString('en-US', { 
            weekday: 'short',
            month: 'short', 
            day: 'numeric',
            hour: 'numeric',
            minute: '2-digit'
        }) : 'Date TBD';
    
    // Get participant count
    const participantCount = event.event_participants?.length || 0;
    const participantNames = event.event_participants?.map(p => p.profiles?.name || 'Unknown').slice(0, 3).join(', ') || 'No one yet';
    
    // Count messages for this event
    let messageCount = 0;
    // We'll load this dynamically later, for now just show the thread link
    
    eventCard.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: start; gap: 10px;">
            <div style="flex: 1;">
                <div style="font-weight: 600; font-size: 14px; margin-bottom: 4px;">
                    📅 ${dateStr}
                </div>
                ${event.location ? `
                    <div style="font-size: 13px; color: #666; margin-bottom: 4px;">
                        📍 ${event.location}
                    </div>
                ` : ''}
                ${event.notes ? `
                    <div style="font-size: 12px; color: #666; margin-bottom: 4px;">
                        📝 ${event.notes}
                    </div>
                ` : ''}
                <div style="font-size: 12px; color: #666; margin-top: 6px;">
                    👥 ${participantCount} going${participantCount > 0 ? ': ' + participantNames : ''}
                </div>
            </div>
            <div style="display: flex; flex-direction: column; gap: 6px; min-width: 100px;">
                ${isUserJoined ? `
                    <button onclick="addToCalendar('${event.id}')" class="btn btn-secondary" style="font-size: 12px; padding: 6px 10px; margin: 0; width: 100%;">
                        📅 Add to Calendar
                    </button>
                    ${!isPast ? `
                        <button onclick="openEventChat('${event.id}')" class="btn btn-secondary" style="font-size: 12px; padding: 6px 10px; margin: 0; width: 100%;">
                            💬 Open Event Chat
                        </button>
                    ` : ''}
                ` : `
                    <button onclick="joinEventFromChat('${event.id}', '${matchId}')" class="btn" style="font-size: 12px; padding: 6px 10px; margin: 0; background: #4CAF50; width: 100%;">
                        Join Event
                    </button>
                `}
            </div>
        </div>
    `;
    
    return eventCard;
}

// Message Pagination Helper Functions
function createLoadOlderButton(chatType) {
    const messagesContainer = document.getElementById('chat-messages');
    const existingButton = document.getElementById('load-older-messages-btn');

    // Remove existing button if present
    if (existingButton) {
        existingButton.remove();
    }

    // Check if we have more messages to load
    if (!messagePagination[chatType].hasMore) {
        return;
    }

    const buttonContainer = document.createElement('div');
    buttonContainer.id = 'load-older-messages-btn';
    buttonContainer.style.cssText = `
        padding: 12px;
        text-align: center;
        border-bottom: 1px solid var(--border-color);
        background: var(--bg-secondary);
    `;

    const loadButton = document.createElement('button');
    loadButton.style.cssText = `
        background: var(--primary-color);
        color: white;
        border: none;
        border-radius: 8px;
        padding: 10px 20px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        width: 100%;
        max-width: 200px;
    `;
    loadButton.textContent = messagePagination[chatType].loading ? 'Loading...' : 'Load older messages';
    loadButton.disabled = messagePagination[chatType].loading;
    loadButton.onclick = () => loadOlderMessages(chatType);

    loadButton.onmouseover = function() {
        if (!this.disabled) this.style.background = 'var(--primary-hover)';
    };
    loadButton.onmouseout = function() {
        this.style.background = 'var(--primary-color)';
    };

    buttonContainer.appendChild(loadButton);

    // Insert at the beginning of messages container
    messagesContainer.insertBefore(buttonContainer, messagesContainer.firstChild);
}

async function loadOlderMessages(chatType) {
    if (messagePagination[chatType].loading || !messagePagination[chatType].hasMore) {
        return;
    }

    const messagesContainer = document.getElementById('chat-messages');
    const scrollHeightBefore = messagesContainer.scrollHeight;
    const scrollTopBefore = messagesContainer.scrollTop;

    messagePagination[chatType].loading = true;

    // Update button to show loading state
    const button = document.querySelector('#load-older-messages-btn button');
    if (button) {
        button.textContent = 'Loading...';
        button.disabled = true;
    }

    try {
        let messages, error;
        const offset = messagePagination[chatType].loadedCount;

        if (chatType === 'match') {
            const matchId = currentMatchChat?.id || currentMatchId;
            const result = await supabase
                .from('match_messages')
                .select('*, sender:profiles(id, name, avatar)')
                .eq('match_id', matchId)
                .order('created_at', { ascending: false })
                .range(offset, offset + MESSAGE_PAGE_SIZE - 1);

            messages = result.data;
            error = result.error;

        } else if (chatType === 'event') {
            const context = getCurrentChatContext();
            const result = await supabase
                .from('event_messages')
                .select('*, sender:profiles(id, name, avatar)')
                .eq('event_id', context.id)
                .order('created_at', { ascending: false })
                .range(offset, offset + MESSAGE_PAGE_SIZE - 1);

            messages = result.data;
            error = result.error;

        } else if (chatType === 'circle') {
            const circleId = currentCircleChat?.id;
            const result = await supabase
                .from('circle_messages')
                .select('*, sender:profiles(id, name, avatar)')
                .eq('circle_id', circleId)
                .order('created_at', { ascending: false })
                .range(offset, offset + MESSAGE_PAGE_SIZE - 1);

            messages = result.data;
            error = result.error;
        }

        if (error) throw error;

        // Reverse to show oldest first (since we queried descending)
        if (messages) {
            messages.reverse();
        }

        // Update pagination state
        messagePagination[chatType].loadedCount += messages.length;
        messagePagination[chatType].hasMore = messages.length === MESSAGE_PAGE_SIZE;
        messagePagination[chatType].loading = false;

        // Remove the load button temporarily
        const loadButton = document.getElementById('load-older-messages-btn');
        if (loadButton) loadButton.remove();

        // Get reference to first message for scroll position calculation
        const firstMessageBefore = messagesContainer.querySelector('[data-message-id]');

        // Prepend older messages
        if (messages && messages.length > 0) {
            // Create a document fragment to batch DOM operations
            const fragment = document.createDocumentFragment();
            const tempContainer = document.createElement('div');

            messages.forEach(message => {
                const isOwnMessage = message.sender_id === currentUser.id;
                const messageTime = new Date(message.created_at).toLocaleTimeString('en-US', {
                    hour: 'numeric',
                    minute: '2-digit'
                });

                const context = getCurrentChatContext();
                const messageType = context.type;

                const sanitizedContent = message.is_deleted
                    ? '<span style="font-style: italic;">[Deleted]</span>'
                    : sanitizeHTML(message.content);
                const sanitizedSenderName = sanitizeHTML(message.sender.name);
                const escapedContentForEdit = message.content.replace(/`/g, '\\`').replace(/\$/g, '\\$').replace(/'/g, "\\'");

                const messageDiv = document.createElement('div');
                messageDiv.setAttribute('data-message-id', message.id);
                messageDiv.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    align-items: ${isOwnMessage ? 'flex-end' : 'flex-start'};
                    margin-bottom: 15px;
                    width: 100%;
                `;

                messageDiv.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; ${isOwnMessage ? 'flex-direction: row-reverse;' : ''}">
                        ${renderAvatar(message.sender.avatar, 32)}
                        <span style="font-size: 13px; color: #666; font-weight: 500;">
                            ${isOwnMessage ? 'You' : sanitizedSenderName}
                        </span>
                        <span style="font-size: 11px; color: #999;">
                            ${messageTime}
                        </span>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: flex-start; ${isOwnMessage ? 'flex-direction: row-reverse;' : ''}; max-width: 100%;">
                        <div style="background: ${message.is_deleted ? 'var(--bg-secondary)' : (isOwnMessage ? '#4CAF50' : '#f0f0f0')}; color: ${message.is_deleted ? 'var(--text-secondary)' : (isOwnMessage ? 'white' : 'black')}; padding: 10px 14px; border-radius: 12px; max-width: 280px; word-wrap: break-word; overflow-wrap: break-word;">
                            ${sanitizedContent}
                        </div>
                        ${isOwnMessage && !message.is_deleted ? `
                            <div class="message-actions" style="position: relative;">
                                <button onclick="toggleEventMessageActions('${message.id}')" style="background: none; border: none; color: #aaa; cursor: pointer; font-size: 1.2em; padding: 5px;">⋯</button>
                                <div id="event-menu-${message.id}" class="message-actions-menu">
                                    ${!message.content.includes('<img') && !message.content.includes('<a') ? `<button onclick="editEventMessage('${message.id}', \`${escapedContentForEdit}\`)">✏️ Edit</button>` : ''}
                                    <button onclick="deleteEventMessage('${message.id}')" class="delete-btn">🗑️ Delete</button>
                                </div>
                            </div>
                        ` : ''}
                    </div>
                    <div class="message-reactions-wrapper" style="margin-top: 4px; display: flex; gap: 6px; align-items: center; flex-wrap: wrap;">
                        <button
                            onclick="showReactionPicker('${message.id}', '${messageType}', event)"
                            style="
                                background: none;
                                border: 1px solid var(--border-color);
                                border-radius: 12px;
                                padding: 4px 8px;
                                font-size: 16px;
                                cursor: pointer;
                                color: var(--text-secondary);
                                transition: all 0.2s;
                            "
                            onmouseover="this.style.background='var(--bg-secondary)'"
                            onmouseout="this.style.background='none'"
                            title="Add reaction"
                        >
                            +
                        </button>
                    </div>
                `;

                tempContainer.appendChild(messageDiv);

                // Fetch reactions
                if (messageType !== 'none') {
                    fetchMessageReactions(message.id, messageType).then(() => {
                        updateReactionDisplay(message.id, messageType);
                    });
                }
            });

            // Insert all messages before the first existing message
            if (firstMessageBefore) {
                messagesContainer.insertBefore(tempContainer, firstMessageBefore);
            } else {
                messagesContainer.appendChild(tempContainer);
            }
        }

        // Recreate load button if there are more messages
        if (messagePagination[chatType].hasMore) {
            createLoadOlderButton(chatType);
        }

        // Maintain scroll position - user should stay looking at the same message
        requestAnimationFrame(() => {
            const scrollHeightAfter = messagesContainer.scrollHeight;
            const scrollDiff = scrollHeightAfter - scrollHeightBefore;
            messagesContainer.scrollTop = scrollTopBefore + scrollDiff;
        });

    } catch (error) {
        console.error('Error loading older messages:', error);
        messagePagination[chatType].loading = false;
        showNotification('Failed to load older messages', 'error');

        // Re-enable button
        if (button) {
            button.textContent = 'Load older messages';
            button.disabled = false;
        }
    }
}

async function loadAndDisplayGeneralMessages(matchId, preserveScroll = false, savedScrollPosition = null) {
    try {
        const messagesContainer = document.getElementById('chat-messages');

        // Save scroll position if preserving
        const scrollPos = preserveScroll && !savedScrollPosition ? messagesContainer.scrollTop : savedScrollPosition;

        // Reset pagination state for initial load
        if (!preserveScroll) {
            messagePagination.match = { loadedCount: 0, hasMore: true, loading: false };
        }

        // Load most recent messages (descending order, then reverse)
        const { data: messages, error } = await supabase
            .from('match_messages')
            .select(`
                *,
                sender:profiles(id, name, avatar)
            `)
            .eq('match_id', matchId)
            .order('created_at', { ascending: false })
            .limit(MESSAGE_PAGE_SIZE);

        if (error) throw error;

        // Reverse to show oldest-to-newest
        if (messages) {
            messages.reverse();
        }

        // Update pagination state
        messagePagination.match.loadedCount = messages?.length || 0;
        messagePagination.match.hasMore = messages?.length === MESSAGE_PAGE_SIZE;

        // Preserve upcoming events section, past events section, and create event button before clearing
        const upcomingEventsSection = messagesContainer.querySelector('#upcoming-events-section');
        const pastEventsSection = messagesContainer.querySelector('details'); // Past events use <details>
        const createEventBtn = messagesContainer.querySelector('button.btn-secondary');
        const generalChatHeader = messagesContainer.querySelector('h4'); // General chat header (the last h4)

        console.log('🧹 Preserving sections before clear:', {
            upcomingEvents: !!upcomingEventsSection,
            pastEvents: !!pastEventsSection,
            createBtn: !!createEventBtn,
            header: !!generalChatHeader
        });

        messagesContainer.innerHTML = '';

        // Re-add preserved sections in order
        if (upcomingEventsSection) {
            messagesContainer.appendChild(upcomingEventsSection);
            console.log('✅ Re-added upcoming events section');
        }
        if (pastEventsSection) {
            messagesContainer.appendChild(pastEventsSection);
            console.log('✅ Re-added past events section');
        }
        if (createEventBtn) {
            messagesContainer.appendChild(createEventBtn);
            console.log('✅ Re-added create event button');
        }

        // Add general chat header
        const headerContainer = document.createElement('div');
        headerContainer.style.cssText = 'margin: 20px 0 10px 0; padding-bottom: 8px; border-bottom: 2px solid #e0e0e0;';
        headerContainer.innerHTML = '<h4 style="margin: 0; font-size: 14px; color: #666; font-weight: 600;">💬 GENERAL CHAT</h4>';
        messagesContainer.appendChild(headerContainer);
        console.log('✅ Added general chat header');

        if (!messages || messages.length === 0) {
            const placeholder = document.createElement('p');
            placeholder.style.cssText = 'text-align: center; color: #999; padding: 20px; font-size: 14px;';
            placeholder.textContent = 'No messages yet. Start the conversation!';
            messagesContainer.appendChild(placeholder);
            messagePagination.match.hasMore = false;
            return;
        }

        // Display each message
        messages.forEach(message => {
            appendMessage(message);
        });

        // Add "Load older messages" button if there are more messages
        if (messagePagination.match.hasMore) {
            createLoadOlderButton('match');
        }

        // Scroll handling - preserve position or scroll to bottom
        setTimeout(() => {
            if (preserveScroll && scrollPos !== null) {
                messagesContainer.scrollTop = scrollPos;
                console.log('📜 Restored scroll position to:', scrollPos);
            } else {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        }, 50);

    } catch (error) {
        console.error('Error loading general messages:', error);
    }
}

async function setupMatchChatSubscription(matchId) {
    console.log('🔔 Setting up match chat subscription for:', matchId);
    
    // Clean up existing subscription
    if (matchMessageSubscription) {
        await supabase.removeChannel(matchMessageSubscription);
        const index = allActiveSubscriptions.indexOf(matchMessageSubscription);
        if (index > -1) allActiveSubscriptions.splice(index, 1);
        matchMessageSubscription = null;
    }
    
    // Subscribe to broadcast messages only
    matchMessageSubscription = supabase
        .channel(`match_chat_${matchId}`)
        .on('broadcast', { event: 'new_general_message' }, (payload) => {
            console.log('📨 Broadcast message received:', payload.payload);

            // Don't duplicate messages we sent ourselves
            if (payload.payload.sender_id === currentUser.id) {
                console.log('⏭️ Skipping own message');
                return;
            }

            // Append message to general chat
            const message = {
                id: payload.payload.id,
                sender_id: payload.payload.sender_id,
                content: payload.payload.content,
                created_at: payload.payload.created_at,
                sender: {
                    id: payload.payload.sender_id,
                    name: payload.payload.sender_name,
                    avatar: payload.payload.sender_avatar
                }
            };

            appendMessage(message);

            // Update badge if we're not currently viewing this match
            const currentContext = getCurrentChatContext();
            if (!currentContext || currentContext.id !== payload.payload.match_id) {
                updateNotificationBadge();
            }
        })
        .on('broadcast', { event: 'message_edited' }, (payload) => {
            console.log('✏️ Match message edited:', payload);
            loadAndDisplayGeneralMessages(matchId);
        })
        .on('broadcast', { event: 'message_deleted' }, (payload) => {
            console.log('🗑️ Match message deleted:', payload);
            loadAndDisplayGeneralMessages(matchId);
        })
        .on('broadcast', { event: 'reaction_changed' }, async (payload) => {
            console.log('👍 Match message reaction changed:', payload);
            const messageId = payload.payload.messageId;
            await fetchMessageReactions(messageId, 'match');
            updateReactionDisplay(messageId, 'match');
        })
        .subscribe((status) => {
            console.log('Match chat subscription status:', status);
        });
    
    allActiveSubscriptions.push(matchMessageSubscription);
}

// ========== CIRCLE CHAT FUNCTIONS ==========

window.openCircleChat = async function(circleId) {
    try {
        console.log('🔄 Opening circle chat:', circleId);
        showLoader('Loading circle chat...');

        // Find the circle
        const circle = circles.find(c => c.id === circleId);
        if (!circle) {
            hideLoader();
            showNotification('Circle not found', 'error');
            return;
        }

        // Mark circle as read
        await markCircleAsRead(circleId);

        // Clean up any existing subscriptions
        if (matchMessageSubscription) {
            await supabase.removeChannel(matchMessageSubscription);
            const index = allActiveSubscriptions.indexOf(matchMessageSubscription);
            if (index > -1) allActiveSubscriptions.splice(index, 1);
            matchMessageSubscription = null;
        }

        // Set circle chat context
        setCircleChatContext(circle);

        // Show mute button for circle chats
        const muteChatBtn = document.getElementById('mute-chat-btn');
        if (muteChatBtn) {
            muteChatBtn.style.display = 'inline-block';
            await updateMuteButton(null, null, circleId);
        }

        // Get all circle members
        const { data: members, error: membersError } = await supabase
            .from('circle_members')
            .select(`
                profile_id,
                profiles!inner(id, name, avatar)
            `)
            .eq('circle_id', circleId);

        if (membersError) throw membersError;

        // Update header
        document.getElementById('event-activity-name').textContent = `👥 ${circle.name}`;
        document.getElementById('event-participants').innerHTML = `${members?.length || 0} members in circle`;

        // Render circle chat
        await renderCircleChat(circleId);

        // Setup subscription for real-time messages
        await setupCircleChatSubscription(circleId);

        hideLoader();
        showPage('chat');

        // Force scroll to bottom after page is shown (especially for notifications)
        setTimeout(() => forceScrollToBottom(), 300);

    } catch (error) {
        hideLoader();
        console.error('Error opening circle chat:', error);
        showNotification('Error loading circle chat', 'error');
    }
}

async function renderCircleChat(circleId) {
    const messagesContainer = document.getElementById('chat-messages');
    messagesContainer.innerHTML = '';

    // Header
    const header = document.createElement('div');
    header.style.cssText = 'margin: 20px 0 10px 0; padding-bottom: 8px; border-bottom: 2px solid #e0e0e0;';
    header.innerHTML = '<h4 style="margin: 0; font-size: 14px; color: #666; font-weight: 600;">💬 CIRCLE CHAT</h4>';
    messagesContainer.appendChild(header);

    // Load and display messages
    await loadAndDisplayCircleMessages(circleId);

    // Scroll to bottom
    setTimeout(() => {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }, 100);
}

async function loadAndDisplayCircleMessages(circleId, preserveScroll = false, savedScrollPosition = null) {
    try {
        const messagesContainer = document.getElementById('chat-messages');

        // Save scroll position if preserving
        const scrollPos = preserveScroll && !savedScrollPosition ? messagesContainer.scrollTop : savedScrollPosition;

        // Reset pagination state for initial load
        if (!preserveScroll) {
            messagePagination.circle = { loadedCount: 0, hasMore: true, loading: false };
        }

        // Load most recent messages (descending order, then reverse)
        const { data: messages, error } = await supabase
            .from('circle_messages')
            .select(`
                *,
                sender:profiles(id, name, avatar)
            `)
            .eq('circle_id', circleId)
            .order('created_at', { ascending: false })
            .limit(MESSAGE_PAGE_SIZE);

        if (error) throw error;

        // Reverse to show oldest-to-newest
        if (messages) {
            messages.reverse();
        }

        // Update pagination state
        messagePagination.circle.loadedCount = messages?.length || 0;
        messagePagination.circle.hasMore = messages?.length === MESSAGE_PAGE_SIZE;

        // Clear messages but preserve the header
        const header = messagesContainer.querySelector('h4');
        messagesContainer.innerHTML = '';

        // Re-add header if it existed
        if (header) {
            const headerContainer = document.createElement('div');
            headerContainer.style.cssText = 'margin: 20px 0 10px 0; padding-bottom: 8px; border-bottom: 2px solid #e0e0e0;';
            headerContainer.appendChild(header);
            messagesContainer.appendChild(headerContainer);
        }

        if (!messages || messages.length === 0) {
            const placeholder = document.createElement('p');
            placeholder.style.cssText = 'text-align: center; color: #999; padding: 20px; font-size: 14px;';
            placeholder.textContent = 'No messages yet. Start the conversation!';
            messagesContainer.appendChild(placeholder);
            messagePagination.circle.hasMore = false;
            return;
        }

        // Display each message
        messages.forEach(message => {
            appendMessage(message);
        });

        // Add "Load older messages" button if there are more messages
        if (messagePagination.circle.hasMore) {
            createLoadOlderButton('circle');
        }

        // Scroll handling - preserve position or scroll to bottom
        setTimeout(() => {
            if (preserveScroll && scrollPos !== null) {
                messagesContainer.scrollTop = scrollPos;
                console.log('📜 Restored scroll position to:', scrollPos);
            } else {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        }, 50);

    } catch (error) {
        console.error('Error loading circle messages:', error);
    }
}

async function setupCircleChatSubscription(circleId) {
    console.log('🔔 Setting up circle chat subscription for:', circleId);

    // Clean up existing subscription
    if (matchMessageSubscription) {
        await supabase.removeChannel(matchMessageSubscription);
        const index = allActiveSubscriptions.indexOf(matchMessageSubscription);
        if (index > -1) allActiveSubscriptions.splice(index, 1);
        matchMessageSubscription = null;
    }

    // Subscribe to broadcast messages
    matchMessageSubscription = supabase
        .channel(`circle_chat_${circleId}`)
        .on('broadcast', { event: 'new_circle_message' }, (payload) => {
            console.log('📨 Circle message received:', payload.payload);

            // Don't duplicate messages we sent ourselves
            if (payload.payload.sender_id === currentUser.id) {
                console.log('⏭️ Skipping own message');
                return;
            }

            // Append message to chat
            const message = {
                id: payload.payload.id,
                sender_id: payload.payload.sender_id,
                content: payload.payload.content,
                created_at: payload.payload.created_at,
                sender: {
                    id: payload.payload.sender_id,
                    name: payload.payload.sender_name,
                    avatar: payload.payload.sender_avatar
                }
            };

            appendMessage(message);

            // Update badge if we're not currently viewing this circle chat
            const currentContext = getCurrentChatContext();
            if (!currentContext || currentContext.id !== payload.payload.circle_id) {
                updateNotificationBadge();
            }
        })
        .on('broadcast', { event: 'message_edited' }, (payload) => {
            console.log('✏️ Circle message edited:', payload);
            loadAndDisplayCircleMessages(circleId);
        })
        .on('broadcast', { event: 'message_deleted' }, (payload) => {
            console.log('🗑️ Circle message deleted:', payload);
            loadAndDisplayCircleMessages(circleId);
        })
        .on('broadcast', { event: 'reaction_changed' }, async (payload) => {
            console.log('👍 Circle message reaction changed:', payload);
            const messageId = payload.payload.messageId;
            await fetchMessageReactions(messageId, 'circle');
            updateReactionDisplay(messageId, 'circle');
        })
        .subscribe((status) => {
            console.log('Circle chat subscription status:', status);
        });

    allActiveSubscriptions.push(matchMessageSubscription);
}

async function markCircleAsRead(circleId) {
    try {
        const { error } = await supabase
            .from('circle_members')
            .update({ last_read_at: new Date().toISOString() })
            .eq('circle_id', circleId)
            .eq('profile_id', currentUser.id);

        if (error) throw error;

        console.log('✅ Marked circle as read:', circleId);

        // Refresh circles list to update badges
        if (window.location.hash === '#circles') {
            await renderCircles();
        }

    } catch (error) {
        console.error('Error marking circle as read:', error);
    }
}

// ========== END CIRCLE CHAT FUNCTIONS ==========

// Load a single message with sender info
async function loadSingleMessage(messageId) {
    try {
        const { data: message, error } = await supabase
            .from('match_messages')
            .select(`
                *,
                sender:profiles(id, name, avatar)
            `)
            .eq('id', messageId)
            .single();
        
        if (error) throw error;
        
        if (message) {
            appendGeneralMessage(message);
        }
    } catch (error) {
        console.error('Error loading single message:', error);
    }
}

// View event thread (expand messages within the event card)
window.viewEventThread = async function(eventId) {
    // For now, just open the event chat
    // Later we can make this show inline thread
    openEventChat(eventId);
}

// Join event from within the chat
window.joinEventFromChat = async function(eventId, matchId) {
    try {
        showLoader('Joining event...');
        
        // Add user to event participants
        const { error } = await supabase
            .from('event_participants')
            .insert([{
                event_id: eventId,
                profile_id: currentUser.id,
                status: 'accepted'
            }]);
        
        if (error) throw error;
        
        // Auto-join general chat if not already in it
        await joinMatchChat(matchId);
        
        // Get event details for notification
        const { data: event, error: eventError } = await supabase
            .from('events')
            .select(`
                id,
                scheduled_date,
                activity_id,
                activities(name, emoji),
                event_participants(profile_id)
            `)
            .eq('id', eventId)
            .single();
        
        if (eventError) {
            console.error('Error loading event details:', eventError);
        }
        
        // Send notification to existing participants
        if (event) {
            await sendEventJoinNotification(event);
        }
        
        hideLoader();
        showNotification('Joined event! You can now access the event chat.');
        
        // Refresh the threaded chat view
        const match = matches.find(m => m.id === matchId);
        if (match) {
            const { data: allEvents } = await supabase
                .from('events')
                .select(`
                    *,
                    event_participants(profile_id, profiles(id, name, avatar))
                `)
                .eq('match_id', matchId)
                .order('scheduled_date', { ascending: true });
            
            await renderThreadedChat(matchId, allEvents || []);
        }
        
    } catch (error) {
        hideLoader();
        console.error('Error joining event:', error);
        showNotification('Error joining event', 'error');
    }
}

// Add to Calendar function
window.addToCalendar = async function(eventId) {
    
    // Find the event - try from current context first, then query database
    let event = null;
    
    // Try to find in matches (if we're on matches page)
    if (matches && matches.length > 0) {
        for (const match of matches) {
            if (match.events) {
                event = match.events.find(e => e && e.id === eventId);
                if (event) break;
            }
        }
    }
    
    // If not found, query from database
    if (!event) {
        const { data, error } = await supabase
            .from('events')
            .select('*')
            .eq('id', eventId)
            .single();
        
        if (error || !data) {
            showNotification('Event not found', 'error');
            return;
        }
        event = data;
    }
    
    if (!event) {
        showNotification('Event not found', 'error');
        return;
    }
    
    // Get activity details
    const match = matches.find(m => m.events?.some(e => e.id === eventId));
    
    let activity = match?.activity || activities.find(a => a.id === (match?.activity_id || event.activity_id));
    
    // If still not found, query database
    if (!activity) {
        const { data: activityData } = await supabase
            .from('activities')
            .select('*')
            .eq('id', event.activity_id)
            .single();
        
        activity = activityData;
    }
    
    if (!activity) {
        showNotification('Activity details not found', 'error');
        return;
    }
    
    // Show modal with calendar options
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.style.display = 'flex';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 350px;">
            <span class="close-modal-btn" onclick="this.closest('.modal-overlay').remove()">×</span>
            <div class="modal-header">Add to Calendar</div>
            <button onclick="downloadICSFile('${eventId}')" class="btn" style="width: 100%; margin-bottom: 10px;">
                📥 Download .ics file
            </button>
            <button onclick="openGoogleCalendar('${eventId}')" class="btn btn-secondary" style="width: 100%; margin-bottom: 10px;">
                📧 Google Calendar
            </button>
            <button onclick="downloadICSFile('${eventId}')" class="btn btn-secondary" style="width: 100%;">
                📱 Apple Calendar
            </button>
            <p style="font-size: 12px; color: #666; margin-top: 15px; text-align: center;">
                Apple Calendar: Download the file and open it
            </p>
        </div>
    `;
    document.body.appendChild(modal);
}

// Download .ics file
window.downloadICSFile = async function(eventId) {
    // Find event (same logic as addToCalendar)
    let event = null;
    if (matches && matches.length > 0) {
        for (const match of matches) {
            if (match.events) {
                event = match.events.find(e => e && e.id === eventId);
                if (event) break;
            }
        }
    }
    
    if (!event) {
        const { data } = await supabase
            .from('events')
            .select('*')
            .eq('id', eventId)
            .single();
        event = data;
    }
    
    if (!event) return;
    
    // Find activity
    const match = matches.find(m => m.events?.some(e => e.id === eventId));
    let activity = match?.activity || activities.find(a => a.id === (match?.activity_id || event.activity_id));
    
    if (!activity) {
        const { data: activityData } = await supabase
            .from('activities')
            .select('*')
            .eq('id', event.activity_id)
            .single();
        activity = activityData;
    }
    
    if (!activity) return;
    
    const startDate = new Date(event.scheduled_date);
    const endDate = new Date(startDate.getTime() + 2 * 60 * 60 * 1000); // +2 hours default
    
    // Format dates for .ics (YYYYMMDDTHHMMSS)
    const formatDate = (date) => {
        const year = date.getUTCFullYear();
        const month = String(date.getUTCMonth() + 1).padStart(2, '0');
        const day = String(date.getUTCDate()).padStart(2, '0');
        const hours = String(date.getUTCHours()).padStart(2, '0');
        const minutes = String(date.getUTCMinutes()).padStart(2, '0');
        const seconds = String(date.getUTCSeconds()).padStart(2, '0');
        return `${year}${month}${day}T${hours}${minutes}${seconds}Z`;
    };
    
    const icsContent = [
        'BEGIN:VCALENDAR',
        'VERSION:2.0',
        'PRODID:-//Friendle//Event//EN',
        'BEGIN:VEVENT',
        `UID:${event.id}@friendle.app`,
        `DTSTAMP:${formatDate(new Date())}`,
        `DTSTART:${formatDate(startDate)}`,
        `DTEND:${formatDate(endDate)}`,
        `SUMMARY:${activity.emoji} ${activity.name}`,
        event.location ? `LOCATION:${event.location}` : '',
        event.notes ? `DESCRIPTION:${event.notes}\\n\\nOrganized via Friendle` : 'DESCRIPTION:Organized via Friendle',
        'STATUS:CONFIRMED',
        'END:VEVENT',
        'END:VCALENDAR'
    ].filter(line => line).join('\r\n');
    
    // Create blob and download
    const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `friendle-${activity.name.replace(/\s+/g, '-')}-${event.id}.ics`;
    link.click();
    
    // Close only the calendar modal
    const calendarModals = document.querySelectorAll('.modal-overlay');
    calendarModals.forEach(m => {
        if (m.querySelector('.modal-header')?.textContent === 'Add to Calendar') {
            m.remove();
        }
    });
    
    showNotification('Calendar event downloaded!');
}

// Open in Google Calendar
window.openGoogleCalendar = async function(eventId) {
    // Find event (same logic as addToCalendar)
    let event = null;
    if (matches && matches.length > 0) {
        for (const match of matches) {
            if (match.events) {
                event = match.events.find(e => e && e.id === eventId);
                if (event) break;
            }
        }
    }
    
    if (!event) {
        const { data } = await supabase
            .from('events')
            .select('*')
            .eq('id', eventId)
            .single();
        event = data;
    }
    
    if (!event) return;
    
    // Find activity
    const match = matches.find(m => m.events?.some(e => e.id === eventId));
    let activity = match?.activity || activities.find(a => a.id === (match?.activity_id || event.activity_id));
    
    if (!activity) {
        const { data: activityData } = await supabase
            .from('activities')
            .select('*')
            .eq('id', event.activity_id)
            .single();
        activity = activityData;
    }
    
    if (!activity) return;
    
    const startDate = new Date(event.scheduled_date);
    const endDate = new Date(startDate.getTime() + 2 * 60 * 60 * 1000); // +2 hours
    
    const formatGoogleDate = (date) => {
        const year = date.getUTCFullYear();
        const month = String(date.getUTCMonth() + 1).padStart(2, '0');
        const day = String(date.getUTCDate()).padStart(2, '0');
        const hours = String(date.getUTCHours()).padStart(2, '0');
        const minutes = String(date.getUTCMinutes()).padStart(2, '0');
        const seconds = String(date.getUTCSeconds()).padStart(2, '0');
        return `${year}${month}${day}T${hours}${minutes}${seconds}Z`;
    };
    
    // Build Google Calendar URL
    const googleUrl = new URL('https://calendar.google.com/calendar/render');
    googleUrl.searchParams.set('action', 'TEMPLATE');
    googleUrl.searchParams.set('text', `${activity.emoji} ${activity.name}`);
    googleUrl.searchParams.set('dates', `${formatGoogleDate(startDate)}/${formatGoogleDate(endDate)}`);
    if (event.location) googleUrl.searchParams.set('location', event.location);
    if (event.notes) googleUrl.searchParams.set('details', event.notes + '\n\nOrganized via Friendle');
    
    // Close only the calendar modal
    const calendarModals = document.querySelectorAll('.modal-overlay');
    calendarModals.forEach(m => {
        if (m.querySelector('.modal-header')?.textContent === 'Add to Calendar') {
            m.remove();
        }
    });
    
    // Open in new tab
    window.open(googleUrl.toString(), '_blank');
    
    showNotification('Opening Google Calendar...');
}

// Add to calendar from event chat header
window.addToCalendarFromHeader = function() {
    if (currentEvent && currentEvent.id) {
        addToCalendar(currentEvent.id);
    } else {
        showNotification('No event selected', 'error');
    }
}

// Helper function to check if user is first in match
async function isFirstInMatch(matchId) {
    try {
        const { data: participants, error } = await supabase
            .from('match_participants')
            .select('profile_id')
            .eq('match_id', matchId);
        
        if (error) throw error;
        
        return !participants || participants.length === 0;
        
    } catch (error) {
        console.error('Error checking first in match:', error);
        return false;
    }
}

// Save matches to Supabase
async function saveMatchesToSupabase(matches, circleId) {
    try {
        // Clear existing matches for this user and circle
        await supabase
            .from('matches')
            .delete()
            .eq('circle_id', circleId);

        // Insert new matches
        if (matches.length > 0) {
            const matchData = matches.map(match => ({
                id: match.id,
                circle_id: circleId,
                activity_id: match.activity.id
                // Note: We'll need to modify your matches table structure to store user pairs
            }));

            const { error } = await supabase
                .from('matches')
                .insert(matchData);

            if (error) throw error;
        }
    } catch (error) {
        console.error('Error saving matches:', error);
    }
}
        // Match System
        async function checkForMatches() {
    if (!selectedCircle) return;
    
    console.log('🔍 Checking for matches...');
    
    // Store old matches to detect NEW ones
    const oldMatchIds = new Set(matches.map(m => m.id));
    
    // Find real matches based on preferences
    const foundMatches = await findMatches(selectedCircle.id);
    
    // Update global matches array
    matches = foundMatches;
    
    // Save to localStorage for now (we can migrate this later)
    localStorage.setItem('friendle_matches', JSON.stringify(matches));
    
    updateNotificationBadge();

    // Detect NEW matches (matches that didn't exist before)
    const newMatches = foundMatches.filter(m => !oldMatchIds.has(m.id));
    
    console.log('📊 Match summary:', {
        total: foundMatches.length,
        new: newMatches.length,
        existing: foundMatches.length - newMatches.length
    });
    
    // Send notifications for NEW matches only
    for (const match of newMatches) {
        await sendNewMatchNotification(match);
    }

    if (matches.length > 0) {
        if (newMatches.length > 0) {
            showNotification(`Found ${newMatches.length} new match${newMatches.length > 1 ? 'es' : ''}!`);
        }
    } else {
        showNotification('No matches found yet. Try selecting more activities or invite more friends!');
    }
}

async function sendNewMatchNotification(match) {
    try {
        console.log('📢 Sending new match notification for:', match.activity?.name);

        // Get all users who are interested in this activity (have it in preferences)
        const { data: interestedUsers, error } = await supabase
            .from('preferences')
            .select('profile_id, profiles(id, name, onesignal_player_id, notify_new_matches)')
            .eq('circle_id', match.circle_id)
            .eq('activity_id', match.activity_id || match.activity.id)
            .neq('profile_id', currentUser.id); // Don't notify yourself
        
        if (error) throw error;
        
        if (!interestedUsers || interestedUsers.length === 0) {
            console.log('ℹ️ No other interested users to notify');
            return;
        }
        
        console.log(`📬 Notifying ${interestedUsers.length} interested user(s)`);
        
        // Get names of all interested users (including current user)
        const allInterestedNames = [currentUser.name, ...interestedUsers.map(u => u.profiles.name)];
        
        // Create notification message
        let message = '';
        if (allInterestedNames.length === 2) {
            message = `You matched with ${allInterestedNames.find(n => n !== currentUser.name)} for ${match.activity.emoji} ${match.activity.name}!`;
        } else {
            const otherNames = allInterestedNames.filter(n => n !== currentUser.name).slice(0, 2).join(', ');
            const remaining = allInterestedNames.length - 3; // -3 because we show 2 names + current user
            if (remaining > 0) {
                message = `You matched with ${otherNames}, and ${remaining} other${remaining > 1 ? 's' : ''} for ${match.activity.emoji} ${match.activity.name}!`;
            } else {
                message = `You matched with ${otherNames} for ${match.activity.emoji} ${match.activity.name}!`;
            }
        }
        
        // Send notifications via Edge Function
        const recipientIds = interestedUsers
            .filter(u => u.profiles.onesignal_player_id) // Only users with player IDs
            .map(u => u.profile_id);
        
        if (recipientIds.length === 0) {
            console.log('ℹ️ No users with notification IDs to notify');
            return;
        }
        
        console.log('🚀 Calling send-notification Edge Function');
        
        const { data, error: notifError } = await supabase.functions.invoke('send-notification', {
            body: {
                senderId: currentUser.id,
                recipientIds: recipientIds,
                message: message,
                activityName: `${match.activity.emoji} ${match.activity.name}`,
                chatType: 'match',
                chatId: match.id,
                notificationType: 'new_match'
            }
        });

        if (notifError) {
            console.error('❌ Error sending match notification:', notifError);
        } else {
            console.log('✅ Match notifications sent successfully:', data);
        }
        
    } catch (error) {
        console.error('❌ Error in sendNewMatchNotification:', error);
        // Don't throw - we don't want to block the match creation if notifications fail
    }
}

async function sendEventJoinNotification(event) {
    try {
        console.log('📢 Sending event join notification for:', event.id);

        const activity = event.activities;
        
        // Get existing participants (exclude current user who just joined)
        const existingParticipantIds = event.event_participants
            .map(p => p.profile_id)
            .filter(id => id !== currentUser.id);
        
        if (existingParticipantIds.length === 0) {
            console.log('ℹ️ No existing participants to notify (user is first)');
            return;
        }
        
        // Get profiles with OneSignal IDs
        const { data: profiles, error: profileError } = await supabase
            .from('profiles')
            .select('id, name, onesignal_player_id')
            .in('id', existingParticipantIds)
            .not('onesignal_player_id', 'is', null);
        
        if (profileError) throw profileError;
        
        if (!profiles || profiles.length === 0) {
            console.log('ℹ️ No participants with notification IDs');
            return;
        }
        
        // Format event date
        const eventDate = new Date(event.scheduled_date);
        const dateStr = eventDate.toLocaleDateString('en-US', { 
            weekday: 'short',
            month: 'short', 
            day: 'numeric'
        });
        
        // Create notification message
        const message = `${currentUser.name} is coming to ${activity.emoji} ${activity.name} on ${dateStr}!`;
        
        console.log('📬 Notifying:', message);
        
        // Get recipient IDs for the Edge Function
        const recipientIds = profiles.map(p => p.id);
        
        // Send notification via Edge Function
        const { data, error: notifError } = await supabase.functions.invoke('send-notification', {
            body: {
                senderId: currentUser.id,
                recipientIds: recipientIds,
                message: message,
                activityName: `${activity.emoji} ${activity.name}`,
                chatType: 'event',
                chatId: event.id,
                notificationType: 'event_join'
            }
        });

        if (notifError) {
            console.error('❌ Error sending event join notification:', notifError);
        } else {
            console.log('✅ Event join notifications sent successfully:', data);
        }
        
    } catch (error) {
        console.error('❌ Error in sendEventJoinNotification:', error);
        // Don't throw - we don't want to block event joining if notifications fail
    }
}

async function loadMatches() {
    
    if (!currentUser) return;
    
    showLoader('Loading matches...');
    
    try {
        const userCircles = circles.map(c => c.id);
        
        // Get user's preferences (circle + activity pairs)
        const { data: userPrefs } = await supabase
            .from('preferences')
            .select('activity_id, circle_id')
            .eq('profile_id', currentUser.id)
            .in('circle_id', userCircles);
        
        if (!userPrefs || userPrefs.length === 0) {
            matches = [];
            await displayMatches();
            return;
        }
        
        // Create a Set of "circleId|activityId" strings for filtering
        const prefSet = new Set(userPrefs.map(p => `${p.circle_id}|${p.activity_id}`));
        
        // Get all potential matches
        const activityIds = [...new Set(userPrefs.map(p => p.activity_id))];
        const { data: allMatches, error: matchError } = await supabase
            .from('matches')
            .select('*')
            .in('activity_id', activityIds)
            .in('circle_id', userCircles);
        
        if (matchError) throw matchError;
        
        // Filter to only matches where user has that activity selected in THAT circle
        matches = (allMatches || []).filter(match => 
            prefSet.has(`${match.circle_id}|${match.activity_id}`)
        );
        
        // Get data for each match
        for (let match of matches) {
            // Load activity details if not already in activities array
            let activity = activities.find(a => a.id === match.activity_id);
            if (!activity) {
                const { data: activityData } = await supabase
                    .from('activities')
                    .select('*')
                    .eq('id', match.activity_id)
                    .single();
                
                if (activityData) {
                    activities.push(activityData);
                    activity = activityData;
                }
            }
            match.activity = activity; // Store activity on match object
            
            // Get all users interested (have activity in preferences)
            const { data: interested } = await supabase
                .from('preferences')
                .select('profile_id, profiles(id, name, avatar)')
                .eq('circle_id', match.circle_id)
                .eq('activity_id', match.activity_id);
            
            match.interestedUsers = interested?.map(i => i.profiles) || [];
            match.interestedCount = match.interestedUsers.length;
            
            // Get who's in the chat
            const { data: chatParticipants } = await supabase
                .from('match_participants')
                .select('profile_id, profiles(id, name, avatar)')
                .eq('match_id', match.id);
            
            match.chatParticipants = chatParticipants?.map(p => p.profiles) || [];
            match.inChatCount = match.chatParticipants.length;
            match.userInChat = chatParticipants?.some(p => p.profile_id === currentUser.id) || false;
        }
        
        await displayMatches();
        
    } catch (error) {
        console.error('Error loading matches:', error);
    } finally {
        hideLoader();
        // Update badge count after loading matches
        await updateNotificationBadge();
    }
}

        async function displayMatches() {
    const matchesList = document.getElementById('matches-list');
    const showPastEvents = document.getElementById('show-past-events')?.checked ?? true;
    
    if (!matches || matches.length === 0) {
        matchesList.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon">💫</div>
                <div class="empty-state-title">No Matches Yet</div>
                <div class="empty-state-description">Select some activities to find friends who want to hang out!</div>
                <button class="btn" onclick="showPage('activities')" style="margin-top: 20px;">🎯 Choose Activities</button>
            </div>`;
        return;
    }

    // Get activities marked as available today
    const { data: todayActivities } = await supabase
        .from('activity_availability')
        .select('activity_id')
        .eq('profile_id', currentUser.id)
        .gte('available_until', new Date().toISOString());
    
    const todayActivityIds = new Set(
        (todayActivities || []).map(a => a.activity_id.toString())
    );

    // PERFORMANCE OPTIMIZATION: Batch fetch all data at once instead of N+1 queries
    const matchIds = matches.map(m => m.id);

    // Fetch all match participations at once
    const { data: allMatchParticipations } = await supabase
        .from('match_participants')
        .select('match_id, last_read_at')
        .eq('profile_id', currentUser.id)
        .in('match_id', matchIds);

    // Fetch inactivity warnings for user
    const { data: inactivityWarnings } = await supabase
        .from('inactivity_warnings')
        .select('match_id, profile_id, warned_at')
        .eq('profile_id', currentUser.id)
        .eq('status', 'pending')
        .in('match_id', matchIds);

    const warningsMap = new Map(
        (inactivityWarnings || []).map(w => [w.match_id, w])
    );

    const matchParticipationMap = new Map(
        (allMatchParticipations || []).map(p => [p.match_id, p])
    );

    // Fetch all latest messages for matches at once
    const { data: allLatestMatchMessages } = await supabase
        .from('match_messages')
        .select('match_id, created_at, sender_id')
        .in('match_id', matchIds)
        .order('created_at', { ascending: false });

    // Group messages by match_id and keep only the latest
    const latestMatchMessageMap = new Map();
    (allLatestMatchMessages || []).forEach(msg => {
        if (!latestMatchMessageMap.has(msg.match_id)) {
            latestMatchMessageMap.set(msg.match_id, msg);
        }
    });

    let matchesWithEvents = await Promise.all(
    matches.map(async (match) => {
        // Get all events for this match
        const query = supabase
            .from('events')
            .select(`
                *,
                event_participants(profile_id, status, profiles(id, name, avatar))
            `)
            .eq('match_id', match.id)
            .order('scheduled_date', { ascending: true });

        const { data: allEvents, error } = await query;

        if (error) {
            console.error('Error loading events:', error);
            return { match, events: [], matchUnreadCount: 0 };
        }

        // Get match participation from map (already fetched)
        const matchParticipation = matchParticipationMap.get(match.id);

        // Calculate unread count using cached data
        let matchUnreadCount = 0;
        if (matchParticipation?.last_read_at) {
            const latestMessage = latestMatchMessageMap.get(match.id);
            if (latestMessage &&
                new Date(latestMessage.created_at) > new Date(matchParticipation.last_read_at) &&
                latestMessage.sender_id !== currentUser.id) {
                matchUnreadCount = 1;
            }
        }

        // Get all event IDs for batch fetching
        const eventIds = (allEvents || []).map(e => e.id);

        // Fetch all event participations and messages for this match's events at once
        let eventParticipationMap = new Map();
        let latestEventMessageMap = new Map();

        if (eventIds.length > 0) {
            try {
                const { data: eventParticipations } = await supabase
                    .from('event_participants')
                    .select('event_id, last_read_at')
                    .eq('profile_id', currentUser.id)
                    .in('event_id', eventIds);

                eventParticipationMap = new Map(
                    (eventParticipations || []).map(p => [p.event_id, p])
                );

                const { data: eventMessages } = await supabase
                    .from('event_messages')
                    .select('event_id, created_at, sender_id')
                    .in('event_id', eventIds)
                    .order('created_at', { ascending: false });

                // Group by event_id and keep only latest
                (eventMessages || []).forEach(msg => {
                    if (!latestEventMessageMap.has(msg.event_id)) {
                        latestEventMessageMap.set(msg.event_id, msg);
                    }
                });
            } catch (err) {
                console.log('Event read tracking not available yet - run migration to enable');
            }
        }

        // Mark which events user has joined and calculate unread counts
        const eventsWithUnread = (allEvents || []).map(event => {
            const userParticipation = event.event_participants?.find(p => p.profile_id === currentUser.id);
            const isUserJoined = !!userParticipation;

            // Calculate unread count using cached data
            let eventUnreadCount = 0;
            if (isUserJoined) {
                const eventParticipation = eventParticipationMap.get(event.id);
                if (eventParticipation?.last_read_at) {
                    const latestMessage = latestEventMessageMap.get(event.id);
                    if (latestMessage &&
                        new Date(latestMessage.created_at) > new Date(eventParticipation.last_read_at) &&
                        latestMessage.sender_id !== currentUser.id) {
                        eventUnreadCount = 1;
                    }
                }
            }

            return {
                ...event,
                isUserJoined,
                unreadCount: eventUnreadCount
            };
        });

        return { match, events: eventsWithUnread, matchUnreadCount };
    })
);

// Filter out matches with only past events if toggle is off
if (!showPastEvents) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    matchesWithEvents = matchesWithEvents.filter(({ match, events }) => {
        // Keep if no events exist
        if (!events || events.length === 0) return true;
        
        // Keep if any event is upcoming
        const hasUpcoming = events.some(e => 
            new Date(e.scheduled_date) >= today && e.status === 'scheduled'
        );
        
        return hasUpcoming;
    });
}

    // Note: We no longer filter out matches based on minimum group size
    // Users should see all matches, even if waiting for more people
    // The UI will show a "waiting" state for matches below their minimum

    // Pre-load any missing activities
    const missingActivityIds = new Set();
    matchesWithEvents.forEach(({ match }) => {
        if (!activities.find(a => a.id === match.activity_id)) {
            missingActivityIds.add(match.activity_id);
        }
    });

    // Fetch missing activities
    const missingActivities = [];
    if (missingActivityIds.size > 0) {
        const { data } = await supabase
            .from('activities')
            .select('*')
            .in('id', Array.from(missingActivityIds));
        if (data) missingActivities.push(...data);
    }

    matchesList.innerHTML = matchesWithEvents.map(({ match, events, matchUnreadCount }) => {
        let activity = activities.find(a => a.id === match.activity_id);

        const activityName = activity ? activity.name : 'Unknown Activity';
        const activityEmoji = activity ? activity.emoji : '🎯';

        // Check if user is first
        const isFirst = match.inChatCount === 0;

        // Check for inactivity warning
        const hasWarning = warningsMap.has(match.id);

        // Get interested users display
        const interestedCount = match.interestedCount || 0;
        const interestedNames = match.interestedUsers?.slice(0, 2).map(u => u.name).join(', ') || '';
        const moreCount = interestedCount > 2 ? interestedCount - 2 : 0;
        
        let interestedDisplay = '';
        if (interestedCount === 1) {
            interestedDisplay = 'Just you interested';
        } else if (interestedCount === 2) {
            interestedDisplay = interestedNames;
        } else if (interestedCount > 2) {
            const allNames = match.interestedUsers.map(u => u.name).join('\\n');
            interestedDisplay = `${interestedNames}, and <a href="#" onclick="event.preventDefault(); event.stopPropagation(); alert('People interested:\\n\\n${allNames}');" style="color: #667eea; text-decoration: underline; cursor: pointer;">${moreCount} other${moreCount > 1 ? 's' : ''}</a>`;
        }
        
        // Compare dates at midnight to include events happening today
const now = new Date();
const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

console.log('Filtering events:', events.map(e => ({id: e.id, status: e.status, date: e.scheduled_date})));

const upcomingEvents = events.filter(e => {
    const isScheduled = e.status === 'scheduled';
    const isFuture = new Date(e.scheduled_date) >= today;
    console.log(`Event ${e.id}: status=${e.status}, isScheduled=${isScheduled}, isFuture=${isFuture}`);
    return isScheduled && isFuture;
});

const pastEvents = events.filter(e => 
    e.status !== 'scheduled' || new Date(e.scheduled_date) < today
);

console.log('Upcoming:', upcomingEvents.length, 'Past:', pastEvents.length);

        return `
    <div class="match-card${matchUnreadCount > 0 ? ' unread' : ''}">
    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 20px;">
        <div style="flex: 1; padding-right: 15px;">
    <h3 style="display: flex; align-items: center; gap: 8px;">
        ${activityEmoji} ${activityName}
    </h3>
            <p style="margin: 8px 0 0 0; font-size: 14px; line-height: 1.4;">
                ${interestedCount} ${interestedCount === 1 ? 'person' : 'people'} interested${interestedDisplay ? ': ' + interestedDisplay : ''}
            </p>
            ${match.inChatCount > 0 ? `
                <p style="margin: 4px 0 0 0; color: var(--primary-color); font-size: 13px;">
                    💬 ${match.inChatCount} in chat${match.userInChat ? ' (including you)' : ''}
                </p>
            ` : ''}
        </div>
        <div style="display: flex; flex-direction: column; gap: 10px; min-width: 140px; align-items: flex-end;">
    <span class="circle-tag">
        ${circles.find(c => c.id === match.circle_id)?.name || 'Circle'}
    </span>
    ${isFirst ? `
        <div class="match-info-box">
            <p style="margin: 0 0 10px 0; font-size: 13px; font-weight: 500;">🎉 You're first!</p>
            <p style="margin: 0 0 12px 0; font-size: 12px; line-height: 1.4;">Want to put it out there? Others will see and can join.</p>
            <button onclick="joinMatchChatFirst('${match.id}')" class="btn" style="font-size: 13px; padding: 8px 16px; margin: 0; width: 100%;">
                Join Chat & Coordinate
            </button>
        </div>
    ` : match.userInChat ? `
        ${hasWarning ? `
            <div class="match-info-box warning" style="margin-bottom: 10px;">
                <p style="margin: 0 0 8px 0; font-size: 13px; font-weight: 500;">⚠️ Still interested?</p>
                <p style="margin: 0 0 10px 0; font-size: 12px; line-height: 1.4;">We haven't seen you active in a while. Let us know you're still interested!</p>
                <button onclick="stayInterested('${match.id}')" class="btn" style="font-size: 13px; padding: 10px 16px; width: 100%; background: #ff4d4f;">
                    👍 Yes, I'm Still Interested
                </button>
            </div>
        ` : ''}
        <button onclick="openMatchChatThreaded('${match.id}')" class="btn" style="font-size: 14px; padding: 12px 16px; width: 100%; margin: 0;">
            💬 Open Chat
        </button>
        <button onclick="openCreateEventModal('${match.id}')" class="btn btn-secondary" style="font-size: 13px; padding: 8px 16px; width: 100%; margin: 0;">
            + Create Event
        </button>
    ` : `
        <button onclick="joinMatchChatNormal('${match.id}')" class="btn" style="font-size: 14px; padding: 12px 16px; width: 100%; margin: 0; background: #4CAF50;">
            Join Chat
        </button>
        <p style="font-size: 11px; color: #666; margin: 0; text-align: center; line-height: 1.3;">${match.inChatCount} ${match.inChatCount === 1 ? 'person' : 'people'} already chatting</p>
    `}
    <button onclick="markAsUninterested('${match.id}', '${match.activity_id}', '${match.circle_id}')" class="btn" style="font-size: 12px; padding: 6px 12px; width: 100%; margin: 0; background: #6c757d; opacity: 0.7;">
        🚫 No Longer Interested
    </button>
</div>
    </div>
                
                ${upcomingEvents.length > 0 ? `
    <div style="margin-bottom: 15px;">
    <h4 style="margin: 0 0 12px 0; font-size: 15px; color: #666; font-weight: 600;">Upcoming</h4>
        ${upcomingEvents.map(event => {
            const date = new Date(event.scheduled_date);
            const dateStr = date.toLocaleDateString('en-US', { 
                weekday: 'short', 
                month: 'short', 
                day: 'numeric'
            });
            
            const participantCount = event.event_participants?.length || 0;
            
            return `
                <div class="event-item${event.unreadCount > 0 ? ' unread' : (event.isUserJoined ? '' : ' pending')}" data-unread="${event.unreadCount > 0}" data-joined="${event.isUserJoined}">
                    <div style="display: flex; justify-content: space-between; align-items: center; gap: 10px;">
                        <div style="flex: 1;">
    <div style="font-weight: 500; margin-bottom: 6px; font-size: 15px; display: flex; align-items: center; gap: 6px;">
        📅 ${dateStr}
    </div>
                            ${event.location ? `<div class="event-meta" style="font-size: 13px;">📍 ${event.location}</div>` : ''}
                            <div class="event-meta" style="font-size: 12px; margin-top: 4px;">${participantCount} ${participantCount === 1 ? 'person' : 'people'} ${event.isUserJoined ? 'going' : 'interested'}</div>
                        </div>
                        ${event.isUserJoined ? `
                            <button onclick="event.stopPropagation(); openEventChat('${event.id}');" class="btn btn-secondary" style="font-size: 13px; padding: 6px 12px; width: auto; margin: 0; white-space: nowrap;">
                                💬 Event Chat
                            </button>
                        ` : participantCount === 0 ? `
                            <div style="display: flex; flex-direction: column; gap: 6px;">
                                <button onclick="event.stopPropagation(); joinEvent('${event.id}');" class="btn" style="font-size: 13px; padding: 6px 12px; width: auto; margin: 0; white-space: nowrap; background: #4CAF50;">
                                    ✓ Join Event
                                </button>
                                <button onclick="event.stopPropagation(); deleteEmptyEvent('${event.id}');" class="btn btn-secondary" style="font-size: 11px; padding: 4px 8px; width: auto; margin: 0; white-space: nowrap; background: #dc3545; color: white;">
                                    🗑️ Delete
                                </button>
                            </div>
                        ` : `
                            <button onclick="event.stopPropagation(); joinEvent('${event.id}');" class="btn" style="font-size: 13px; padding: 6px 12px; width: auto; margin: 0; white-space: nowrap; background: #4CAF50;">
                                ✓ Join Event
                            </button>
                        `}
                    </div>
                </div>
            `;
        }).join('')}
    </div>
` : `
                    <div class="empty-event-placeholder">
                        💬 No events scheduled yet - schedule something!
                    </div>
                `}
                
                ${pastEvents.length > 0 ? `
                    <details style="margin-top: 10px;">
                        <summary style="cursor: pointer; color: #666; font-size: 14px;">Past Events (${pastEvents.length})</summary>
                        <div style="margin-top: 8px;">
                            ${pastEvents.map(event => {
                                const date = new Date(event.scheduled_date);
                                const dateStr = date.toLocaleDateString('en-US', { 
                                    month: 'short', 
                                    day: 'numeric'
                                });
                                const statusEmoji = event.status === 'completed' ? '✅' : event.status === 'cancelled' ? '❌' : '📅';
                                
                                return `
    <div class="event-item" style="padding: 8px; margin-bottom: 4px; background: #fafafa; border-radius: 4px; opacity: 0.7; font-size: 13px; display: flex; justify-content: space-between; align-items: center;">
        <div>
            ${statusEmoji} ${dateStr}${event.location ? ` · ${event.location}` : ''}
        </div>
        <button onclick="openEventChat('${event.id}')" class="btn btn-secondary" style="font-size: 12px; padding: 4px 8px; width: auto; margin: 0; opacity: 1;">
            Chat
        </button>
    </div>
`;
                            }).join('')}
                        </div>
                    </details>
                ` : ''}
            </div>
        `;
    }).join('');

    // Update button visibility based on today activities
    matches.forEach(match => {
        const isToday = todayActivityIds.has(match.activity_id.toString());
        const button = document.getElementById(`today-btn-${match.id}`);
        if (button) {
            button.style.display = isToday ? 'none' : 'inline-block';
        }
    });
    
    document.querySelectorAll('.event-item').forEach(item => {
        item.addEventListener('mouseenter', function() {
            this.style.background = '#e8e8e8';
        });
        item.addEventListener('mouseleave', function() {
            if (this.style.opacity === '0.7') {
                // Past events
                this.style.background = '#fafafa';
            } else if (this.dataset.unread === 'true') {
                // Unread events
                this.style.background = '#ccfbf1';
            } else if (this.dataset.joined === 'true') {
                // Joined events
                this.style.background = '#f5f5f5';
            } else {
                // Not joined events
                this.style.background = '#fff8e1';
            }
        });
    });
}

window.joinMatch = async function(matchId) {
    try {
        const match = matches.find(m => m.id === matchId);
        if (!match) return;
        
        // Add user to match participants
        const { error } = await supabase
            .from('match_participants')
            .insert([{ 
                match_id: matchId, 
                profile_id: currentUser.id 
            }]);
        
        if (error) throw error;
        
        showNotification('Joined match! You can now chat and schedule events.');
        
        // Refresh matches to update UI
        await loadMatches();
        
    } catch (error) {
        console.error('Error joining match:', error);
        showNotification('Error joining match', 'error');
    }
}

window.joinEvent = async function(eventId) {
    try {
        showLoader('Joining event...');

        // Add user to event participants
        const { error } = await supabase
            .from('event_participants')
            .insert([{
                event_id: eventId,
                profile_id: currentUser.id,
                status: 'accepted'
            }]);

        if (error) throw error;

        // Get event details for notification
        const { data: event, error: eventError } = await supabase
            .from('events')
            .select(`
                id,
                match_id,
                scheduled_date,
                activity_id,
                activities(name, emoji),
                event_participants(profile_id)
            `)
            .eq('id', eventId)
            .single();

        if (eventError) {
            console.error('Error loading event details:', eventError);
        }

        // Update last_interaction_at for inactivity tracking
        if (event && event.match_id) {
            await supabase
                .from('match_participants')
                .update({ last_interaction_at: new Date().toISOString() })
                .eq('match_id', event.match_id)
                .eq('profile_id', currentUser.id);
        }

        // Send notification to existing participants
        if (event) {
            await sendEventJoinNotification(event);
        }
        
        hideLoader();
        showNotification('Joined event! You can now access the event chat.');
        
        // Refresh matches to update UI
        await loadMatches();
        
    } catch (error) {
        hideLoader();
        console.error('Error joining event:', error);
        showNotification('Error joining event', 'error');
    }
}

window.markActivityAsToday = async function(activityId, matchId) {
    if (!currentUser) return;
    
    try {
        // Find the circle ID from the match
        const match = matches.find(m => m.id === matchId);
        if (!match) return;
        
        // Set activity as available today
        const endOfDay = new Date();
        endOfDay.setHours(23, 59, 59, 999);
        
        await supabase
            .from('activity_availability')
            .upsert({
                profile_id: currentUser.id,
                circle_id: match.circle_id,
                activity_id: activityId.toString(),
                available_until: endOfDay.toISOString()
            }, {
                onConflict: 'profile_id,circle_id,activity_id'
            });
        
        showNotification('Marked as available today!');
        
        // Hide the button immediately
        const button = document.getElementById(`today-btn-${matchId}`);
        if (button) {
            button.style.display = 'none';
        }
        
        // Refresh matches to update participant list
        await loadMatches();
        
    } catch (error) {
        console.error('Error marking activity as today:', error);
        showNotification('Error updating availability', 'error');
    }
}

        window.sendMessage = async function() {
    const input = document.getElementById('message-input');
    if (!input.value.trim()) return;
    
    const messageContent = input.value.trim(); // Capture message FIRST
    
    const context = getCurrentChatContext();
    console.log('💬 Sending message in context:', context.type);
    
    try {
        if (context.type === 'event') {
            // EVENT CHAT
            const { data, error } = await supabase
                .from('event_messages')
                .insert({
                    event_id: context.id,
                    sender_id: currentUser.id,
                    content: messageContent
                })
                .select(`*, sender:profiles(id, name, avatar)`)
                .single();
            
            if (error) throw error;
            
            appendMessage(data);
            
            const channel = supabase.channel(`event_${context.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'new_message',
                payload: {
                    id: data.id,
                    sender_id: currentUser.id,
                    sender_name: currentUser.name,
                    sender_avatar: currentUser.avatar,
                    content: data.content,
                    created_at: data.created_at
                }
            });
            
        } else if (context.type === 'match') {
            // MATCH CHAT
            const { data, error } = await supabase
                .from('match_messages')
                .insert({
                    match_id: context.id,
                    sender_id: currentUser.id,
                    content: messageContent
                })
                .select(`*, sender:profiles(id, name, avatar)`)
                .single();

            if (error) throw error;

            appendMessage(data);

            // Update last_interaction_at for inactivity tracking
            await supabase
                .from('match_participants')
                .update({ last_interaction_at: new Date().toISOString() })
                .eq('match_id', context.id)
                .eq('profile_id', currentUser.id);

            const channel = supabase.channel(`match_chat_${context.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'new_general_message',
                payload: {
                    id: data.id,
                    sender_id: currentUser.id,
                    sender_name: currentUser.name,
                    sender_avatar: currentUser.avatar,
                    content: data.content,
                    created_at: data.created_at
                }
            });

        } else if (context.type === 'circle') {
            // CIRCLE CHAT
            const { data, error } = await supabase
                .from('circle_messages')
                .insert({
                    circle_id: context.id,
                    sender_id: currentUser.id,
                    content: messageContent
                })
                .select(`*, sender:profiles(id, name, avatar)`)
                .single();

            if (error) throw error;

            appendMessage(data);

            const channel = supabase.channel(`circle_chat_${context.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'new_circle_message',
                payload: {
                    id: data.id,
                    sender_id: currentUser.id,
                    sender_name: currentUser.name,
                    sender_avatar: currentUser.avatar,
                    content: data.content,
                    created_at: data.created_at,
                    circle_id: context.id
                }
            });

        } else {
            console.error('❌ No active chat context');
            showNotification('No active chat', 'error');
            return;
        }
        
        // Send push notification via Supabase Edge Function
        try {
            console.log('🔔 Starting notification send process...');
            const context = getCurrentChatContext();
            let recipientIds = [];
            let activityName = 'Chat';
            
            if (context.type === 'event') {
                // Get event participants (excluding sender)
                const { data: participants } = await supabase
                    .from('event_participants')
                    .select('profile_id')
                    .eq('event_id', context.id)
                    .neq('profile_id', currentUser.id);
                
                recipientIds = participants?.map(p => p.profile_id) || [];
                
                // Get activity name
                const activity = activities.find(a => a.id === currentEvent?.activity_id);
                activityName = activity ? `${activity.emoji} ${activity.name}` : 'Event';
                
            } else if (context.type === 'match') {
                // Get match participants (excluding sender)
                const { data: participants } = await supabase
                    .from('match_participants')
                    .select('profile_id')
                    .eq('match_id', context.id)
                    .neq('profile_id', currentUser.id);

                recipientIds = participants?.map(p => p.profile_id) || [];

                // Get activity name
                const match = matches.find(m => m.id === context.id);
                const activity = match?.activity || activities.find(a => a.id === match?.activity_id);
                activityName = activity ? `${activity.emoji} ${activity.name}` : 'Chat';
            } else if (context.type === 'circle') {
                // Get circle members (excluding sender)
                const { data: members } = await supabase
                    .from('circle_members')
                    .select('profile_id')
                    .eq('circle_id', context.id)
                    .neq('profile_id', currentUser.id);

                recipientIds = members?.map(m => m.profile_id) || [];

                // Get circle name
                const circle = circles.find(c => c.id === context.id);
                activityName = circle ? `👥 ${circle.name}` : 'Circle Chat';
            }

            console.log('📬 Recipient IDs (before mute filter):', recipientIds);

            // Filter out users who have muted this chat
            if (recipientIds.length > 0) {
                let muteQuery = supabase
                    .from('muted_chats')
                    .select('profile_id')
                    .in('profile_id', recipientIds);

                if (context.type === 'match') {
                    muteQuery = muteQuery.eq('match_id', context.id);
                } else if (context.type === 'event') {
                    muteQuery = muteQuery.eq('event_id', context.id);
                } else if (context.type === 'circle') {
                    muteQuery = muteQuery.eq('circle_id', context.id);
                }

                const { data: mutedUsers, error: muteError } = await muteQuery;

                if (!muteError && mutedUsers && mutedUsers.length > 0) {
                    const mutedUserIds = mutedUsers.map(u => u.profile_id);
                    recipientIds = recipientIds.filter(id => !mutedUserIds.includes(id));
                    console.log('🔕 Filtered out muted users:', mutedUserIds);
                }
            }

            console.log('📬 Recipient IDs (after mute filter):', recipientIds);

            if (recipientIds.length > 0) {
                console.log('🚀 Calling Edge Function with:', {
                    senderId: currentUser.id,
                    recipientIds: recipientIds,
                    message: messageContent,
                    activityName: activityName,
                    chatType: context.type
                });

                const { data: notifData, error: notifError } = await supabase.functions.invoke('send-notification', {
                    body: {
                        senderId: currentUser.id,
                        recipientIds: recipientIds,
                        message: messageContent,
                        activityName: activityName,
                        chatType: context.type,
                        chatId: context.id,
                        notificationType: 'chat_message'
                    }
                });

                if (notifError) {
                    console.error('❌ Error sending chat notification:', notifError);
                } else {
                    console.log('✅ Chat notification sent successfully:', notifData);
                }
            }
        } catch (notifError) {
            console.error('Error sending notification:', notifError);
            // Don't block message send if notification fails
        }
        
        // Clear input LAST
        input.value = '';
        
    } catch (error) {
        console.error('Error sending message:', error);
        showNotification('Failed to send message', 'error');
    }
}
        
        window.handleMessageKeyPress = e => { if (e.key === 'Enter') sendMessage(); };
        
window.toggleEventMessageActions = function(msgId) {
    const menu = document.getElementById(`event-menu-${msgId}`);
    if (menu) {
        menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
    }
    
    // Close other open menus
    document.querySelectorAll('.message-actions-menu').forEach(m => {
        if (m.id !== `event-menu-${msgId}`) {
            m.style.display = 'none';
        }
    });
}

window.editEventMessage = async function(msgId, currentContent) {
    const menu = document.getElementById(`event-menu-${msgId}`);
    if (menu) menu.style.display = 'none';
    
    if (currentContent.includes('<img') || currentContent.includes('<a')) {
        showNotification('Photos and links cannot be edited, only deleted', 'error');
        return;
    }
    
    const newContent = prompt('Edit your message:', currentContent);

    if (!newContent || newContent.trim() === currentContent.trim()) return;

    const context = getCurrentChatContext();
    console.log('✏️ Editing message in context:', context.type);

    // Save scroll position before reload
    const messagesContainer = document.getElementById('chat-messages');
    const scrollPos = messagesContainer ? messagesContainer.scrollTop : 0;

    try {
        if (context.type === 'event') {
            const { error } = await supabase
                .from('event_messages')
                .update({ content: newContent.trim() })
                .eq('id', msgId)
                .eq('sender_id', currentUser.id);

            if (error) throw error;

            const channel = supabase.channel(`event_${context.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'message_edited',
                payload: { id: msgId, content: newContent.trim() }
            });

            await loadEventMessages(context.id, context.data.created_at, true, scrollPos);

        } else if (context.type === 'match') {
            const { error } = await supabase
                .from('match_messages')
                .update({ content: newContent.trim() })
                .eq('id', msgId)
                .eq('sender_id', currentUser.id);

            if (error) throw error;

            const channel = supabase.channel(`match_chat_${context.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'message_edited',
                payload: { id: msgId, content: newContent.trim() }
            });

            await loadMatchMessages(context.id, true, scrollPos);

        } else if (context.type === 'circle') {
            const { error } = await supabase
                .from('circle_messages')
                .update({ content: newContent.trim() })
                .eq('id', msgId)
                .eq('sender_id', currentUser.id);

            if (error) throw error;

            const channel = supabase.channel(`circle_chat_${context.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'message_edited',
                payload: { id: msgId, content: newContent.trim() }
            });

            await loadAndDisplayCircleMessages(context.id, true, scrollPos);
        }

        showNotification('Message updated');

    } catch (error) {
        console.error('Error editing message:', error);
        showNotification('Failed to edit message', 'error');
    }
}

window.deleteEventMessage = async function(msgId) {
    const menu = document.getElementById(`event-menu-${msgId}`);
    if (menu) menu.style.display = 'none';

    if (!confirm('Delete this message?')) return;

    const context = getCurrentChatContext();
    console.log('🗑️ Soft-deleting message in context:', context.type);

    // Save scroll position before reload
    const messagesContainer = document.getElementById('chat-messages');
    const scrollPos = messagesContainer ? messagesContainer.scrollTop : 0;

    try {
        // SECURITY: Use soft delete instead of hard delete to preserve message history
        if (context.type === 'event') {
            const { error } = await supabase
                .from('event_messages')
                .update({
                    is_deleted: true,
                    deleted_at: new Date().toISOString()
                })
                .eq('id', msgId)
                .eq('sender_id', currentUser.id);

            if (error) throw error;

            const channel = supabase.channel(`event_${context.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'message_deleted',
                payload: { id: msgId }
            });

            // Stay in event chat - just reload the event messages
            await loadEventMessages(context.id, context.data.created_at, true, scrollPos);

        } else if (context.type === 'match') {
            const { error } = await supabase
                .from('match_messages')
                .update({
                    is_deleted: true,
                    deleted_at: new Date().toISOString()
                })
                .eq('id', msgId)
                .eq('sender_id', currentUser.id);

            if (error) throw error;

            const channel = supabase.channel(`match_chat_${context.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'message_deleted',
                payload: { id: msgId }
            });

            // Reload the general chat messages (not the full threaded view)
            await loadAndDisplayGeneralMessages(context.id, true, scrollPos);

        } else if (context.type === 'circle') {
            const { error } = await supabase
                .from('circle_messages')
                .update({
                    is_deleted: true,
                    deleted_at: new Date().toISOString()
                })
                .eq('id', msgId)
                .eq('sender_id', currentUser.id);

            if (error) throw error;

            const channel = supabase.channel(`circle_chat_${context.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'message_deleted',
                payload: { id: msgId }
            });

            await loadAndDisplayCircleMessages(context.id, true, scrollPos);
        }

        showNotification('Message deleted');

    } catch (error) {
        console.error('CAUGHT ERROR in deleteEventMessage:', error);
        console.error('Error details:', error.message, error.code);
        showNotification('Failed to delete message', 'error');
    }
}

// ========== MESSAGE REACTIONS ==========
// Available reaction emojis
const REACTION_EMOJIS = ['👍', '❤️', '😂', '🎉', '😮', '👏'];

// Store reactions for all messages in memory
const messageReactions = new Map(); // messageId -> array of reactions

// Fetch reactions for a specific message
window.fetchMessageReactions = async function(messageId, messageType) {
    const tableName = messageType === 'event' ? 'event_message_reactions' :
                      messageType === 'match' ? 'match_message_reactions' :
                      'circle_message_reactions';

    try {
        const { data, error } = await supabase
            .from(tableName)
            .select('id, emoji, profile_id, created_at, profiles:profile_id(name, avatar)')
            .eq('message_id', messageId);

        if (error) throw error;

        // Store in cache
        messageReactions.set(messageId, data || []);
        return data || [];
    } catch (error) {
        console.error('Error fetching reactions:', error);
        return [];
    }
}

// Toggle a reaction on a message
window.toggleReaction = async function(messageId, emoji, messageType) {
    const tableName = messageType === 'event' ? 'event_message_reactions' :
                      messageType === 'match' ? 'match_message_reactions' :
                      'circle_message_reactions';

    try {
        // Check if user already reacted with this emoji
        const { data: existing, error: fetchError } = await supabase
            .from(tableName)
            .select('id')
            .eq('message_id', messageId)
            .eq('profile_id', currentUser.id)
            .eq('emoji', emoji)
            .maybeSingle();

        if (fetchError) throw fetchError;

        if (existing) {
            // Remove reaction
            const { error: deleteError } = await supabase
                .from(tableName)
                .delete()
                .eq('id', existing.id);

            if (deleteError) throw deleteError;
        } else {
            // Add reaction
            const { error: insertError } = await supabase
                .from(tableName)
                .insert({
                    message_id: messageId,
                    profile_id: currentUser.id,
                    emoji: emoji
                });

            if (insertError) throw insertError;
        }

        // Refresh reactions for this message
        await fetchMessageReactions(messageId, messageType);

        // Broadcast reaction change
        const context = getCurrentChatContext();
        const channelName = messageType === 'event' ? `event_${context.id}` :
                           messageType === 'match' ? `match_chat_${context.id}` :
                           `circle_chat_${context.id}`;

        const channel = supabase.channel(channelName);
        await channel.send({
            type: 'broadcast',
            event: 'reaction_changed',
            payload: { messageId }
        });

        // Update UI
        updateReactionDisplay(messageId, messageType);

    } catch (error) {
        console.error('Error toggling reaction:', error);
        showNotification('Failed to update reaction', 'error');
    }
}

// Show reaction picker for a message
window.showReactionPicker = function(messageId, messageType, event) {
    event.stopPropagation();

    // Close any existing pickers
    document.querySelectorAll('.reaction-picker').forEach(p => p.remove());

    const picker = document.createElement('div');
    picker.className = 'reaction-picker';
    picker.style.cssText = `
        position: absolute;
        background: var(--card-bg, white);
        border: 1px solid var(--border-color, #ddd);
        border-radius: 8px;
        padding: 8px;
        display: flex;
        gap: 4px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        z-index: 1000;
    `;

    REACTION_EMOJIS.forEach(emoji => {
        const button = document.createElement('button');
        button.textContent = emoji;
        button.style.cssText = `
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        `;
        button.onmouseover = () => button.style.background = 'var(--bg-secondary)';
        button.onmouseout = () => button.style.background = 'none';
        button.onclick = async () => {
            await toggleReaction(messageId, emoji, messageType);
            picker.remove();
        };
        picker.appendChild(button);
    });

    // Position picker near the clicked element
    const rect = event.target.getBoundingClientRect();
    picker.style.top = `${rect.top - 50}px`;
    picker.style.left = `${rect.left}px`;

    document.body.appendChild(picker);

    // Close picker when clicking outside
    setTimeout(() => {
        document.addEventListener('click', function closePicker(e) {
            if (!picker.contains(e.target)) {
                picker.remove();
                document.removeEventListener('click', closePicker);
            }
        });
    }, 0);
}

// Render reactions display for a message
window.renderReactions = function(messageId, messageType) {
    const reactions = messageReactions.get(messageId) || [];

    if (reactions.length === 0) {
        return '';
    }

    // Group reactions by emoji
    const grouped = {};
    reactions.forEach(reaction => {
        if (!grouped[reaction.emoji]) {
            grouped[reaction.emoji] = [];
        }
        grouped[reaction.emoji].push(reaction);
    });

    // Create reaction buttons
    const reactionButtons = Object.entries(grouped).map(([emoji, reactionList]) => {
        const count = reactionList.length;
        const userReacted = reactionList.some(r => r.profile_id === currentUser.id);
        const names = reactionList.map(r => r.profiles.name).join(', ');

        return `
            <button
                onclick="toggleReaction('${messageId}', '${emoji}', '${messageType}')"
                onmouseenter="showReactionTooltip(event, '${names.replace(/'/g, "\\'")}')"
                onmouseleave="hideReactionTooltip()"
                style="
                    background: ${userReacted ? 'var(--primary-color)' : 'var(--card-bg)'};
                    color: ${userReacted ? 'white' : 'var(--text-primary)'};
                    border: 1px solid ${userReacted ? 'var(--primary-color)' : 'var(--border-color)'};
                    border-radius: 12px;
                    padding: 4px 8px;
                    font-size: 14px;
                    cursor: pointer;
                    display: inline-flex;
                    align-items: center;
                    gap: 4px;
                    transition: all 0.2s;
                "
                onmouseover="if(!${userReacted}) this.style.background='var(--bg-secondary)'"
                onmouseout="if(!${userReacted}) this.style.background='var(--card-bg)'"
            >
                <span>${emoji}</span>
                <span style="font-size: 12px;">${count}</span>
            </button>
        `;
    }).join('');

    return `
        <div class="message-reactions" style="
            display: flex;
            gap: 6px;
            margin-top: 6px;
            flex-wrap: wrap;
            align-items: center;
        ">
            ${reactionButtons}
        </div>
    `;
}

// Show tooltip with names of people who reacted
let reactionTooltip = null;
window.showReactionTooltip = function(event, names) {
    hideReactionTooltip();

    reactionTooltip = document.createElement('div');
    reactionTooltip.style.cssText = `
        position: fixed;
        background: var(--tooltip-bg, rgba(0, 0, 0, 0.8));
        color: white;
        padding: 6px 10px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 10000;
        pointer-events: none;
        white-space: nowrap;
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
    `;
    reactionTooltip.textContent = names;

    const rect = event.target.getBoundingClientRect();
    reactionTooltip.style.top = `${rect.top - 30}px`;
    reactionTooltip.style.left = `${rect.left}px`;

    document.body.appendChild(reactionTooltip);
}

window.hideReactionTooltip = function() {
    if (reactionTooltip) {
        reactionTooltip.remove();
        reactionTooltip = null;
    }
}

// Update reaction display for a specific message
window.updateReactionDisplay = function(messageId, messageType) {
    const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
    if (!messageElement) return;

    // Find or create reactions container
    let reactionsContainer = messageElement.querySelector('.message-reactions-wrapper');
    if (!reactionsContainer) {
        reactionsContainer = document.createElement('div');
        reactionsContainer.className = 'message-reactions-wrapper';
        messageElement.appendChild(reactionsContainer);
    }

    reactionsContainer.innerHTML = `
        ${renderReactions(messageId, messageType)}
        <button
            onclick="showReactionPicker('${messageId}', '${messageType}', event)"
            style="
                background: none;
                border: 1px solid var(--border-color);
                border-radius: 12px;
                padding: 4px 8px;
                font-size: 16px;
                cursor: pointer;
                color: var(--text-secondary);
                transition: all 0.2s;
            "
            onmouseover="this.style.background='var(--bg-secondary)'"
            onmouseout="this.style.background='none'"
            title="Add reaction"
        >
            +
        </button>
    `;
}

// ========== END MESSAGE REACTIONS ==========

// Global variable to track current event
let currentEvent = null;
let eventMessageSubscription = null;

// Open modal to create new event
function openCreateEventModal(matchId) {
    const match = matches.find(m => m.id === matchId);
    if (!match) return;
    
    document.getElementById('new-event-match-id').value = matchId;
    document.getElementById('create-event-form').reset();
    
    // Set min date to today
    const today = new Date();
    document.getElementById('new-event-date').min = today.toISOString().slice(0, 10);
    
    document.getElementById('create-event-modal').style.display = 'flex';
}

function closeCreateEventModal() {
    document.getElementById('create-event-modal').style.display = 'none';
}

// Create new event
async function createEvent(e) {
    e.preventDefault();
    
    const matchId = document.getElementById('new-event-match-id').value;
    const match = matches.find(m => m.id === matchId);
    
    try {
        // Create the event
        const { data: newEvent, error: eventError } = await supabase
            .from('events')
            .insert({
                match_id: matchId,
                activity_id: match.activity_id,
                circle_id: match.circle_id,
                scheduled_date: document.getElementById('new-event-date').value,
                location: document.getElementById('new-event-location').value || null,
                notes: document.getElementById('new-event-notes').value || null,
                created_by: currentUser.id,
                status: 'scheduled'
            })
            .select()
            .single();
        
        if (eventError) throw eventError;
        
        // Only add the event creator
        const { error: insertError } = await supabase
            .from('event_participants')
            .insert([{
                event_id: newEvent.id,
                profile_id: currentUser.id,
                status: 'accepted'
            }]);

        if (insertError) throw insertError;

        // Update last_interaction_at for inactivity tracking
        await supabase
            .from('match_participants')
            .update({ last_interaction_at: new Date().toISOString() })
            .eq('match_id', matchId)
            .eq('profile_id', currentUser.id);

        closeCreateEventModal();
        
        // Refresh matches to show new event
        await loadMatches();
        
        // Open the new event chat
        openEventChat(newEvent.id);
        
    } catch (error) {
        console.error('Error creating event:', error);
        alert('Failed to create event. Please try again.');
    }
}

// Auto-add new users to upcoming events when they join a match
async function autoAddToUpcomingEvents(matchId, newUserId) {
    try {
        // Check auth status
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        console.log('=== AUTH CHECK ===');
        console.log('Auth error:', authError);
        console.log('Authenticated user ID:', user?.id);
        console.log('Target user ID:', newUserId);
        console.log('Match?', user?.id === newUserId);
        
        if (!user) {
            console.error('No authenticated user - RLS will block all queries');
            return;
        }
        
        console.log('=== AUTO-ADD TO UPCOMING EVENTS ===');
        console.log('Match ID:', matchId);
        console.log('New User ID:', newUserId);
        
        // Find all upcoming events for this match
// Use current date in UTC for comparison
const now = new Date();
const todayUTC = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));

console.log('Querying with match_id:', matchId);
console.log('Querying with date >=', todayUTC.toISOString());

// Try the simplest possible query first
const { data: testQuery, error: testError } = await supabase
    .from('events')
    .select('*')
    .eq('match_id', matchId);

console.log('TEST - Simple query for all events in match:');
console.log('Error:', testError);
console.log('Result:', testQuery);

// Now try with filters
const { data: upcomingEvents, error: eventsError } = await supabase
    .from('events')
    .select('id, scheduled_date, location, status')
    .eq('match_id', matchId)
    .eq('status', 'scheduled')
    .gte('scheduled_date', todayUTC.toISOString());

console.log('Query error:', eventsError);
console.log('Query result:', upcomingEvents);

if (eventsError) throw eventsError;

console.log('Comparison date (today UTC):', todayUTC.toISOString());
console.log('Found upcoming events:', upcomingEvents?.length || 0);

// Also check ALL events for this match to see what exists
const { data: allEvents } = await supabase
    .from('events')
    .select('id, scheduled_date, status')
    .eq('match_id', matchId);

console.log('All events for this match:', allEvents);        
        if (upcomingEvents && upcomingEvents.length > 0) {
            // Add user to all upcoming events
            const participantRecords = upcomingEvents.map(event => ({
                event_id: event.id,
                profile_id: newUserId,
                status: 'accepted'
            }));
            
            const { error: insertError } = await supabase
                .from('event_participants')
                .insert(participantRecords);
            
            if (insertError && insertError.code !== '23505') { // Ignore duplicate key errors
                throw insertError;
            }
            
            console.log(`✓ Added user to ${upcomingEvents.length} upcoming event(s)`);
            
            // Notify user they were added to events
            if (upcomingEvents.length === 1) {
                showNotification(`You've been added to an upcoming event!`);
            } else {
                showNotification(`You've been added to ${upcomingEvents.length} upcoming events!`);
            }
        }
    } catch (error) {
        console.error('Error auto-adding to upcoming events:', error);
    }
}

// Open event chat
async function openEventChat(eventId) {
    try {
        console.log('🔄 Opening event chat:', eventId);
        
        // Clean up ALL previous subscriptions
        if (eventMessageSubscription) {
            await supabase.removeChannel(eventMessageSubscription);
            const index = allActiveSubscriptions.indexOf(eventMessageSubscription);
            if (index > -1) allActiveSubscriptions.splice(index, 1);
            eventMessageSubscription = null;
        }
        
        if (matchMessageSubscription) {
            await supabase.removeChannel(matchMessageSubscription);
            const index = allActiveSubscriptions.indexOf(matchMessageSubscription);
            if (index > -1) allActiveSubscriptions.splice(index, 1);
            matchMessageSubscription = null;
        }
        
        // Load event details
        const { data: event, error: eventError } = await supabase
            .from('events')
            .select(`
                *,
                event_participants(
                    profile_id,
                    status,
                    profiles(id, name, avatar)
                )
            `)
            .eq('id', eventId)
            .single();
        
        if (eventError) throw eventError;
        
// Check if user has joined this event
        const isUserInEvent = event.event_participants?.some(p => p.profile_id === currentUser.id);
        if (!isUserInEvent) {
            showNotification('Please join the event first', 'error');
            return;
        }

        // Set context using helper
        setEventContext(event);
        
        // Show event-specific buttons in event chat
        const generalChatBtn = document.getElementById('open-general-chat-btn');
        const calendarBtn = document.getElementById('add-to-calendar-btn');
        const eventOptionsBtn = document.getElementById('event-options-btn');
        const leaveEventBtn = document.getElementById('leave-event-btn');
        
        if (generalChatBtn) generalChatBtn.style.display = 'inline-block';
        if (calendarBtn) calendarBtn.style.display = 'inline-block';
        if (eventOptionsBtn) eventOptionsBtn.style.display = 'inline-block';
        if (leaveEventBtn) leaveEventBtn.style.display = 'inline-block';

// Show mute button for event chats
        const muteChatBtn = document.getElementById('mute-chat-btn');
        if (muteChatBtn) {
            muteChatBtn.style.display = 'inline-block';
            updateMuteButton(null, eventId, null);
        }

// Get activity details - load from database if not in current activities array
let activity = activities.find(a => a.id === event.activity_id);

// If not found in current activities, load it from database
if (!activity) {
    const { data: activityData, error: activityError } = await supabase
        .from('activities')
        .select('*')
        .eq('id', event.activity_id)
        .single();
    
    if (!activityError && activityData) {
        activity = activityData;
    }
}

// Format event date for header
const headerEventDate = new Date(event.scheduled_date);
const headerDateStr = headerEventDate.toLocaleDateString('en-US', { 
    weekday: 'short',
    month: 'short', 
    day: 'numeric'
});

// Update header with activity name and date
document.getElementById('event-activity-name').textContent = 
    `${activity ? activity.emoji : '🎯'} ${activity ? activity.name : 'Unknown Activity'} - ${headerDateStr}`;

const participants = event.event_participants.map(p => p.profiles.name);
const participantCount = participants.length;

if (participantCount <= 3) {
    // Show all names
    document.getElementById('event-participants').textContent = participants.join(', ');
} else {
    // Show first 2 and "X others" (clickable)
    const shown = participants.slice(0, 2).join(', ');
    const remaining = participantCount - 2;
    const allNames = participants.join('\\n');
    
    document.getElementById('event-participants').innerHTML = 
        `${shown}, and <a href="#" onclick="event.preventDefault(); alert('Participants:\\n\\n${allNames}');" style="color: white; text-decoration: underline; cursor: pointer;">${remaining} other${remaining > 1 ? 's' : ''}</a>`;
}
        
        // Format and display event details
const eventDate = new Date(event.scheduled_date);
const dateStr = eventDate.toLocaleDateString('en-US', { 
    weekday: 'long',
    month: 'long', 
    day: 'numeric',
    year: 'numeric'
});
        
        document.getElementById('event-date').textContent = `📅 ${dateStr}`;
        document.getElementById('event-location').textContent = 
            event.location ? `📍 ${event.location}` : '';
        document.getElementById('event-notes').textContent = 
            event.notes ? `📝 ${event.notes}` : '';
        
        // Load messages (with archive support)
await loadEventMessages(eventId, event.created_at);

        // Mark event as read
        await markEventAsRead(eventId);

        // Set up broadcast subscription for new messages
eventMessageSubscription = supabase
    .channel(`event_${eventId}`)
    .on('broadcast', { event: 'new_message' }, (payload) => {
        console.log('📩 Broadcast message received:', payload);
        
        // Don't duplicate messages we sent ourselves
        if (payload.payload.sender_id === currentUser.id) {
            console.log('⏭️ Skipping own message');
            return;
        }
        
        console.log('🔥 Processing message from another user');
        
        // Create message object with sender info from broadcast
        const message = {
            id: payload.payload.id,
            sender_id: payload.payload.sender_id,
            content: payload.payload.content,
            created_at: payload.payload.created_at,
            sender: {
                id: payload.payload.sender_id,
                name: payload.payload.sender_name,
                avatar: payload.payload.sender_avatar
            }
        };
        
        console.log('Appending message to chat:', message);
        appendMessage(message);
    })
    .on('broadcast', { event: 'message_edited' }, (payload) => {
        console.log('✏️ Message edited:', payload);
        loadEventMessages(currentEvent.id, currentEvent.created_at);
    })
    .on('broadcast', { event: 'message_deleted' }, (payload) => {
        console.log('🗑️ Message deleted:', payload);
        loadEventMessages(currentEvent.id, currentEvent.created_at);
    })
    .on('broadcast', { event: 'reaction_changed' }, async (payload) => {
        console.log('👍 Event message reaction changed:', payload);
        const messageId = payload.payload.messageId;
        await fetchMessageReactions(messageId, 'event');
        updateReactionDisplay(messageId, 'event');
    })
    .subscribe((status) => {
        console.log('Event chat subscription status:', status);
    });

allActiveSubscriptions.push(eventMessageSubscription);

        showPage('chat');

        // Force scroll to bottom after page is shown (especially for notifications)
        setTimeout(() => forceScrollToBottom(), 300);

    } catch (error) {
        console.error('Error loading event chat:', error);
        alert('Failed to load event chat');
    }
}

// Open general match chat from event chat
window.openGeneralChatFromEvent = function() {
    if (!currentEvent) {
        showNotification('No event context', 'error');
        return;
    }
    
    // Find the match ID from current event
    const matchId = currentEvent.match_id;
    
    if (!matchId) {
        showNotification('Cannot find match for this event', 'error');
        return;
    }
    
    // Open the general match chat
    openMatchChatThreaded(matchId);
}

// Load messages for current event
async function loadEventMessages(eventId, eventCreatedAt, preserveScroll = false, savedScrollPosition = null) {
    try {
        const messagesContainer = document.getElementById('chat-messages');

        // Save scroll position if preserving
        const scrollPos = preserveScroll && !savedScrollPosition ? messagesContainer.scrollTop : savedScrollPosition;

        // Reset pagination state for initial load
        if (!preserveScroll) {
            messagePagination.event = { loadedCount: 0, hasMore: true, loading: false };
        }

        // Load most recent messages (descending order, then reverse)
        const { data: messages, error } = await supabase
    .from('event_messages')
    .select(`
        *,
        sender:profiles(id, name, avatar)
    `)
    .eq('event_id', eventId)
    .order('created_at', { ascending: false })
    .limit(MESSAGE_PAGE_SIZE);

        if (error) throw error;

        // Reverse to show oldest-to-newest
        if (messages) {
            messages.reverse();
        }

        messagesContainer.innerHTML = '';

        // Split messages into archived (before event) and current (after event)
        const eventCreatedDate = new Date(eventCreatedAt);
        const archivedMessages = messages.filter(m => new Date(m.created_at) < eventCreatedDate);
        const currentMessages = messages.filter(m => new Date(m.created_at) >= eventCreatedDate);

        // Update pagination state based on current messages
        messagePagination.event.loadedCount = currentMessages?.length || 0;
        messagePagination.event.hasMore = messages?.length === MESSAGE_PAGE_SIZE;

        // Show archived messages toggle if any exist
        if (archivedMessages.length > 0) {
            const archiveToggle = document.createElement('div');
            archiveToggle.style.cssText = `
                padding: 10px;
                background: #f0f0f0;
                border-radius: 8px;
                text-align: center;
                margin-bottom: 15px;
                cursor: pointer;
                color: #666;
                font-size: 14px;
                user-select: none;
            `;
            archiveToggle.innerHTML = `
                <span id="archive-toggle-text">📜 Show ${archivedMessages.length} older message${archivedMessages.length > 1 ? 's' : ''} (before event was created)</span>
            `;
            archiveToggle.onclick = () => toggleArchivedMessages(eventId, eventCreatedAt);
            messagesContainer.appendChild(archiveToggle);

            // Container for archived messages (hidden by default)
            const archivedContainer = document.createElement('div');
            archivedContainer.id = 'archived-messages';
            archivedContainer.style.display = 'none';
            archivedContainer.style.cssText = `
                border-left: 3px solid #ddd;
                padding-left: 10px;
                margin-bottom: 20px;
                opacity: 0.7;
            `;
            messagesContainer.appendChild(archivedContainer);

            // Add archived messages to container
            archivedMessages.forEach(message => {
                appendMessageToContainer(message, archivedContainer);
            });

            // Divider
            const divider = document.createElement('div');
            divider.style.cssText = `
                border-top: 2px solid #ddd;
                margin: 20px 0;
                padding-top: 10px;
                text-align: center;
                color: #999;
                font-size: 13px;
            `;
            divider.innerHTML = '📅 Event Created';
            archivedContainer.appendChild(divider);
        }

        // Show current messages
        if (currentMessages.length === 0 && archivedMessages.length === 0) {
            messagesContainer.innerHTML += '<p style="text-align: center; color: #999; padding: 20px;">No messages yet. Start the conversation!</p>';
            messagePagination.event.hasMore = false;
        } else if (currentMessages.length === 0) {
            const placeholder = document.createElement('p');
            placeholder.style.cssText = 'text-align: center; color: #999; padding: 20px;';
            placeholder.textContent = 'No messages since event was created. Say something!';
            messagesContainer.appendChild(placeholder);
            messagePagination.event.hasMore = false;
        } else {
            currentMessages.forEach(message => appendMessage(message));
        }

        // Add "Load older messages" button if there are more messages
        if (messagePagination.event.hasMore) {
            createLoadOlderButton('event');
        }

        // Scroll handling - preserve position or scroll to bottom
        setTimeout(() => {
            if (preserveScroll && scrollPos !== null) {
                messagesContainer.scrollTop = scrollPos;
                console.log('📜 Restored scroll position to:', scrollPos);
            } else {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                console.log('📜 Scrolled to bottom');
            }
        }, 500);

    } catch (error) {
        console.error('Error loading messages:', error);
    }
}

function toggleArchivedMessages(eventId, eventCreatedAt) {
    const archivedContainer = document.getElementById('archived-messages');
    const toggleText = document.getElementById('archive-toggle-text');
    
    showingArchivedMessages = !showingArchivedMessages;
    
    if (showingArchivedMessages) {
        archivedContainer.style.display = 'block';
        toggleText.textContent = '🔼 Hide older messages';
    } else {
        archivedContainer.style.display = 'none';
        const archivedCount = archivedContainer.querySelectorAll('.message').length - 1; // -1 for divider
        toggleText.textContent = `📜 Show ${archivedCount} older message${archivedCount > 1 ? 's' : ''} (before event was created)`;
    }
}

// SECURITY: Sanitize HTML to prevent XSS attacks while allowing legitimate content
// This function escapes dangerous HTML but allows:
// - Images from Supabase storage
// - Links to Google Maps/Search (app-generated)
function sanitizeHTML(str) {
    if (!str) return '';

    // Pattern 1: Images from Supabase storage
    const supabaseImagePattern = /^<img src="https:\/\/kxsewkjbhxtfqbytftbu\.supabase\.co\/storage\/v1\/object\/public\/chat-photos\/[^"]*"[^>]*>$/;

    // Pattern 2: Links with emojis (📍 for maps, 🔍 for search) - app-generated
    const trustedLinkPattern = /^(📍|🔍)\s*<a href="https:\/\/(www\.google\.com\/maps|www\.google\.com\/search)[^"]*" target="_blank" rel="noopener noreferrer"[^>]*>[^<]*<\/a>$/;

    const trimmed = str.trim();

    if (supabaseImagePattern.test(trimmed) || trustedLinkPattern.test(trimmed)) {
        // This is trusted content from our app - allow it
        return str;
    }

    // For everything else, escape all HTML to prevent XSS
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
}

// Helper function to render avatar HTML (supports both image URLs and emojis)
function renderAvatar(avatar, size = 32) {
    if (!avatar) {
        avatar = '👤'; // Default avatar
    }

    // Check if avatar is an image URL
    if (avatar.startsWith('http')) {
        return `<img src="${avatar}" alt="Avatar" style="width: ${size}px; height: ${size}px; border-radius: 50%; object-fit: cover;">`;
    } else {
        // It's an emoji
        return `<div style="width: ${size}px; height: ${size}px; border-radius: 50%; background: #e0e0e0; display: flex; align-items: center; justify-content: center; font-size: ${size * 0.56}px;">${avatar}</div>`;
    }
}

// Helper function to force scroll to bottom of chat - tries multiple times for reliability
function forceScrollToBottom(attempts = 0) {
    const messagesContainer = document.getElementById('chat-messages');
    if (!messagesContainer) {
        console.warn('No messages container found for scrolling');
        return;
    }

    // Method 1: Scroll using scrollTop
    messagesContainer.scrollTop = messagesContainer.scrollHeight;

    // Method 2: Find last message and scroll it into view
    const messages = messagesContainer.querySelectorAll('.message, div[style*="margin-bottom: 15px"]');
    if (messages.length > 0) {
        const lastMessage = messages[messages.length - 1];
        lastMessage.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }

    console.log(`📜 Force scroll to bottom (attempt ${attempts + 1}), scrollTop: ${messagesContainer.scrollTop}, scrollHeight: ${messagesContainer.scrollHeight}`);

    // Retry up to 3 times with increasing delays to handle async content loading
    if (attempts < 3) {
        setTimeout(() => forceScrollToBottom(attempts + 1), 200 + (attempts * 200));
    }
}

// Helper to append message to specific container
function appendMessageToContainer(message, container) {
    const isOwnMessage = message.sender_id === currentUser.id;
    const messageTime = new Date(message.created_at).toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit'
    });

    // Determine message type from current context
    const context = getCurrentChatContext();
    const messageType = context.type;

    const messageDiv = document.createElement('div');
    messageDiv.className = 'message';
    messageDiv.setAttribute('data-message-id', message.id);
    messageDiv.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: ${isOwnMessage ? 'flex-end' : 'flex-start'};
        margin-bottom: 15px;
    `;

    let onClick = '';
    // SECURITY: Check if message is soft-deleted
    let content = message.is_deleted
        ? '<span style="font-style: italic;">[Deleted]</span>'
        : sanitizeHTML(message.content); // SECURITY: Sanitize to prevent XSS
    let senderName = sanitizeHTML(message.sender.name); // SECURITY: Sanitize sender name

    messageDiv.innerHTML = `
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; ${isOwnMessage ? 'flex-direction: row-reverse;' : ''}">
            ${renderAvatar(message.sender.avatar, 32)}
            <span style="font-size: 13px; color: #666; font-weight: 500;">
                ${isOwnMessage ? 'You' : senderName}
            </span>
            <span style="font-size: 11px; color: #999;">
                ${messageTime}
            </span>
        </div>
        <div style="display: flex; gap: 8px; align-items: flex-start; ${isOwnMessage ? 'flex-direction: row-reverse;' : ''}">
            <div ${onClick} style="
    background: ${message.is_deleted ? 'var(--bg-secondary)' : (isOwnMessage ? '#4CAF50' : '#f0f0f0')};
    color: ${message.is_deleted ? 'var(--text-secondary)' : (isOwnMessage ? 'white' : 'black')};
    padding: 10px 14px;
    border-radius: 12px;
    max-width: 70%;
    word-wrap: break-word;
    overflow-wrap: break-word;
    word-break: normal;
    min-width: fit-content;
">
                ${content}
            </div>
        </div>
        <div class="message-reactions-wrapper" style="margin-top: 4px; display: flex; gap: 6px; align-items: center; flex-wrap: wrap;">
            <button
                onclick="showReactionPicker('${message.id}', '${messageType}', event)"
                style="
                    background: none;
                    border: 1px solid var(--border-color);
                    border-radius: 12px;
                    padding: 4px 8px;
                    font-size: 16px;
                    cursor: pointer;
                    color: var(--text-secondary);
                    transition: all 0.2s;
                "
                onmouseover="this.style.background='var(--bg-secondary)'"
                onmouseout="this.style.background='none'"
                title="Add reaction"
            >
                +
            </button>
        </div>
    `;

    // Add edit/delete for own messages (archived messages are read-only for simplicity)

    container.appendChild(messageDiv);

    // Fetch and display reactions for this message
    if (messageType !== 'none') {
        fetchMessageReactions(message.id, messageType).then(() => {
            updateReactionDisplay(message.id, messageType);
        });
    }
}

function appendMessage(message) {
    const messagesContainer = document.getElementById('chat-messages');

    // Remove placeholder text if it exists
    const placeholder = messagesContainer.querySelector('p');
    if (placeholder && placeholder.textContent.includes('No messages yet')) {
        messagesContainer.innerHTML = '';
    }

    const isOwnMessage = message.sender_id === currentUser.id;
    const messageTime = new Date(message.created_at).toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit'
    });

    // Determine message type from current context
    const context = getCurrentChatContext();
    const messageType = context.type;

    // SECURITY: Sanitize user input to prevent XSS and handle soft-deleted messages
    const sanitizedContent = message.is_deleted
        ? '<span style="font-style: italic;">[Deleted]</span>'
        : sanitizeHTML(message.content);
    const sanitizedSenderName = sanitizeHTML(message.sender.name);
    const escapedContentForEdit = message.content.replace(/`/g, '\\`').replace(/\$/g, '\\$').replace(/'/g, "\\'");

    const messageDiv = document.createElement('div');
    messageDiv.setAttribute('data-message-id', message.id);
    messageDiv.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: ${isOwnMessage ? 'flex-end' : 'flex-start'};
        margin-bottom: 15px;
        width: 100%;
    `;

    messageDiv.innerHTML = `
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; ${isOwnMessage ? 'flex-direction: row-reverse;' : ''}">
            ${renderAvatar(message.sender.avatar, 32)}
            <span style="font-size: 13px; color: #666; font-weight: 500;">
                ${isOwnMessage ? 'You' : sanitizedSenderName}
            </span>
            <span style="font-size: 11px; color: #999;">
                ${messageTime}
            </span>
        </div>
        <div style="display: flex; gap: 8px; align-items: flex-start; ${isOwnMessage ? 'flex-direction: row-reverse;' : ''}; max-width: 100%;">
            <div style="background: ${message.is_deleted ? 'var(--bg-secondary)' : (isOwnMessage ? '#4CAF50' : '#f0f0f0')}; color: ${message.is_deleted ? 'var(--text-secondary)' : (isOwnMessage ? 'white' : 'black')}; padding: 10px 14px; border-radius: 12px; max-width: 280px; word-wrap: break-word; overflow-wrap: break-word;">
    ${sanitizedContent}
</div>
            ${isOwnMessage && !message.is_deleted ? `
    <div class="message-actions" style="position: relative;">
        <button onclick="toggleEventMessageActions('${message.id}')" style="background: none; border: none; color: #aaa; cursor: pointer; font-size: 1.2em; padding: 5px;">⋯</button>
        <div id="event-menu-${message.id}" class="message-actions-menu">
            ${!message.content.includes('<img') && !message.content.includes('<a') ? `<button onclick="editEventMessage('${message.id}', \`${escapedContentForEdit}\`)">✏️ Edit</button>` : ''}
            <button onclick="deleteEventMessage('${message.id}')" class="delete-btn">🗑️ Delete</button>
        </div>
    </div>
` : ''}
        </div>
        <div class="message-reactions-wrapper" style="margin-top: 4px; display: flex; gap: 6px; align-items: center; flex-wrap: wrap;">
            <button
                onclick="showReactionPicker('${message.id}', '${messageType}', event)"
                style="
                    background: none;
                    border: 1px solid var(--border-color);
                    border-radius: 12px;
                    padding: 4px 8px;
                    font-size: 16px;
                    cursor: pointer;
                    color: var(--text-secondary);
                    transition: all 0.2s;
                "
                onmouseover="this.style.background='var(--bg-secondary)'"
                onmouseout="this.style.background='none'"
                title="Add reaction"
            >
                +
            </button>
        </div>
    `;

    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;

    // Fetch and display reactions for this message
    if (messageType !== 'none') {
        fetchMessageReactions(message.id, messageType).then(() => {
            updateReactionDisplay(message.id, messageType);
        });
    }
}

// Send message
async function sendEventMessage(e) {
    e.preventDefault();

    const input = document.getElementById('message-input');
    const content = input.value.trim();

    if (!content) return;

    // SECURITY: Rate limiting - max 20 messages per minute
    if (!RateLimiter.checkLimit('send_message', 20, 60000)) {
        return showNotification('Slow down! You\'re sending messages too quickly.', 'error');
    }

    try {
        // Check if we're in match chat or event chat
        if (currentMatchChat) {
            console.log('Attempting to delete from match_messages');
            console.log('Message ID:', msgId);
            console.log('Sender ID:', currentUser.id);
            
            const { error } = await supabase
                .from('match_messages')
                .delete()
                .eq('id', msgId)
                .eq('sender_id', currentUser.id);
            
            console.log('Delete result - error:', error);
            
            if (error) throw error;
            
            console.log('Delete successful, broadcasting...');
            
            appendMessage(data);
            
            const channel = supabase.channel(`match_chat_${currentMatchChat.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'new_message',
                payload: {
                    id: data.id,
                    sender_id: currentUser.id,
                    sender_name: currentUser.name,
                    sender_avatar: currentUser.avatar,
                    content: data.content,
                    created_at: data.created_at
                }
            });
            
        } else if (currentEvent) {
            // Event chat
            const { data, error } = await supabase
                .from('event_messages')
                .insert({
                    event_id: currentEvent.id,
                    sender_id: currentUser.id,
                    content: content
                })
                .select(`
                    *,
                    sender:profiles(id, name, avatar)
                `)
                .single();
            
            if (error) throw error;
            
            appendMessage(data);
            
            const channel = supabase.channel(`event_${currentEvent.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'new_message',
                payload: {
                    id: data.id,
                    sender_id: currentUser.id,
                    sender_name: currentUser.name,
                    sender_avatar: currentUser.avatar,
                    content: data.content,
                    created_at: data.created_at
                }
            });
        }
        
        input.value = '';
        
    } catch (error) {
        console.error('Error sending message:', error);
        showNotification('Failed to send message', 'error');
    }
}

// Event options functions
function openEventOptionsModal() {
    const modal = document.getElementById('event-options-modal');
    if (modal) {
        modal.style.display = 'flex';
    } else {
        console.error('Event options modal not found');
    }
}

function closeEventOptionsModal() {
    document.getElementById('event-options-modal').style.display = 'none';
}

function editCurrentEvent() {
    closeEventOptionsModal();
    
    // Populate edit form
    const date = new Date(currentEvent.scheduled_date);
    document.getElementById('edit-event-date').value = date.toISOString().slice(0, 10);
    document.getElementById('edit-event-location').value = currentEvent.location || '';
    document.getElementById('edit-event-notes').value = currentEvent.notes || '';
    
    document.getElementById('edit-event-modal').style.display = 'flex';
}

function closeEditEventModal() {
    document.getElementById('edit-event-modal').style.display = 'none';
}

async function saveEventEdits(e) {
    e.preventDefault();
    
    try {
        const { error } = await supabase
            .from('events')
            .update({
                scheduled_date: document.getElementById('edit-event-date').value,
                location: document.getElementById('edit-event-location').value || null,
                notes: document.getElementById('edit-event-notes').value || null
            })
            .eq('id', currentEvent.id);
        
        if (error) throw error;
        
        closeEditEventModal();
        
        // Reload the event
        openEventChat(currentEvent.id);
        
    } catch (error) {
        console.error('Error updating event:', error);
        alert('Failed to update event');
    }
}

async function cancelEvent() {
    if (!confirm('Cancel this event? This will notify all participants.')) return;
    
    try {
        const { error } = await supabase
            .from('events')
            .update({ status: 'cancelled' })
            .eq('id', currentEvent.id);
        
        if (error) throw error;
        
        // Send a system message
        await supabase
            .from('event_messages')
            .insert({
                event_id: currentEvent.id,
                sender_id: currentUser.id,
                content: '❌ This event has been cancelled'
            });
        
        closeEventOptionsModal();
        showPage('matches');
        await loadMatches();
        
    } catch (error) {
        console.error('Error cancelling event:', error);
        alert('Failed to cancel event');
    }
}

async function leaveEvent() {
    if (!confirm('Leave this event? You won\'t receive any more messages.')) return;
    
    try {
        const { error } = await supabase
            .from('event_participants')
            .delete()
            .eq('event_id', currentEvent.id)
            .eq('profile_id', currentUser.id);
        
        if (error) throw error;
        
        closeEventOptionsModal();
        showPage('matches');
        await loadMatches();
        
    } catch (error) {
        console.error('Error leaving event:', error);
        alert('Failed to leave event');
    }
}

async function deleteEvent() {
    if (!confirm('Delete this event permanently? This will remove it for all participants and cannot be undone.')) return;
    
    // Only event creator can delete
    if (currentEvent.created_by !== currentUser.id) {
        alert('Only the event creator can delete this event');
        return;
    }
    
    try {
        const { error } = await supabase
            .from('events')
            .delete()
            .eq('id', currentEvent.id);
        
        if (error) throw error;
        
        closeEventOptionsModal();
        showPage('matches');
        
        // Small delay to ensure database update propagates
        await new Promise(resolve => setTimeout(resolve, 500));
        
        await loadMatches();
        
    } catch (error) {
        console.error('Error deleting event:', error);
        alert('Failed to delete event');
    }
}

async function deleteEmptyEvent(eventId) {
    if (!confirm('Delete this empty event?')) return;
    
    try {
        showLoader('Deleting event...');
        
        const { error } = await supabase
            .from('events')
            .delete()
            .eq('id', eventId);
        
        if (error) throw error;
        
        hideLoader();
        showNotification('Event deleted');
        await loadMatches();
        
    } catch (error) {
        hideLoader();
        console.error('Error deleting empty event:', error);
        showNotification('Failed to delete event', 'error');
    }
}

async function loadMatchMessages(matchId, preserveScroll = false, savedScrollPosition = null) {
    try {
        // Make sure currentMatchId is set
        if (!currentMatchId) {
            currentMatchId = matchId;
        }

        // Make sure currentMatchChat is set
        if (!currentMatchChat) {
            currentMatchChat = matches.find(m => m.id === matchId);
        }

        const messagesContainer = document.getElementById('chat-messages');

        // Save scroll position if preserving
        const scrollPos = preserveScroll && !savedScrollPosition ? messagesContainer.scrollTop : savedScrollPosition;

        // Reset pagination state for initial load
        if (!preserveScroll) {
            messagePagination.match = { loadedCount: 0, hasMore: true, loading: false };
        }

        // Load most recent messages (descending order, then reverse)
        const { data: messages, error } = await supabase
    .from('match_messages')
    .select(`
        *,
        sender:profiles(id, name, avatar)
    `)
    .eq('match_id', matchId)
    .order('created_at', { ascending: false })
    .limit(MESSAGE_PAGE_SIZE);

        if (error) throw error;

        // Reverse to show oldest-to-newest
        if (messages) {
            messages.reverse();
        }

        // Update pagination state
        messagePagination.match.loadedCount = messages?.length || 0;
        messagePagination.match.hasMore = messages?.length === MESSAGE_PAGE_SIZE;

        messagesContainer.innerHTML = '';

        if (messages.length === 0) {
            messagesContainer.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">No messages yet. Start planning your activity!</p>';
            messagePagination.match.hasMore = false;
        } else {
            messages.forEach(message => appendMessage(message));
        }

        // Add "Load older messages" button if there are more messages
        if (messagePagination.match.hasMore) {
            createLoadOlderButton('match');
        }

        // Scroll handling - preserve position or scroll to bottom
        if (preserveScroll && scrollPos !== null) {
            messagesContainer.scrollTop = scrollPos;
            console.log('📜 Restored scroll position to:', scrollPos);
        } else {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

    } catch (error) {
        console.error('Error loading match messages:', error);
    }
}
 

       
        // Image compression helper
function compressImage(file, maxWidth = 1200, quality = 0.8) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = () => reject(new Error('Failed to read file'));
        
        reader.onload = (e) => {
            const img = new Image();
            img.onerror = () => reject(new Error('Failed to load image'));
            
            img.onload = () => {
                const canvas = document.createElement('canvas');
                let width = img.width;
                let height = img.height;
                
                // Calculate new dimensions
                if (width > maxWidth) {
                    height = (height * maxWidth) / width;
                    width = maxWidth;
                }
                
                canvas.width = width;
                canvas.height = height;
                
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
                
                // Convert to blob
                canvas.toBlob((blob) => {
                    if (!blob) {
                        reject(new Error('Failed to compress image'));
                        return;
                    }
                    
                    // Create new file from blob
                    const compressedFile = new File([blob], file.name, {
                        type: 'image/jpeg',
                        lastModified: Date.now()
                    });
                    
                    resolve(compressedFile);
                }, 'image/jpeg', quality);
            };
            
            img.src = e.target.result;
        };
        
        reader.readAsDataURL(file);
    });
}

// Attachments & Modals
window.sharePhoto = function() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.capture = 'environment';
    
    input.onchange = async function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const context = getCurrentChatContext();
        
        if (context.type === 'none') {
            return showNotification('No active chat to send photo to', 'error');
        }
        
        console.log('📸 Sharing photo in context:', context.type);
        
        showLoader('Compressing image...');
        
        try {
            const compressedFile = await compressImage(file);
            
            if (compressedFile.size > 5 * 1024 * 1024) {
                hideLoader();
                return showNotification('Photo too large even after compression. Please try a smaller image.', 'error');
            }
            
            showLoader('Uploading photo...');
            const fileExt = file.name.split('.').pop();
            const fileName = `${currentUser.id}/${Date.now()}.${fileExt}`;
            
            const { data, error } = await supabase.storage
                .from('chat-photos')
                .upload(fileName, compressedFile, {
                    cacheControl: '3600',
                    upsert: false
                });
            
            if (error) throw error;
            
            const { data: urlData } = supabase.storage
                .from('chat-photos')
                .getPublicUrl(fileName);
            
            const photoUrl = urlData.publicUrl;
            
            if (context.type === 'event') {
                // EVENT CHAT (check this first!)
                const { data: messageData, error: messageError } = await supabase
                    .from('event_messages')
                    .insert({
                        event_id: context.id,
                        sender_id: currentUser.id,
                        content: `<img src="${photoUrl}" style="max-width: 200px; border-radius: 10px; cursor: pointer;" onclick="openImageModal('${photoUrl}')">`
                    })
                    .select(`*, sender:profiles(id, name, avatar)`)
                    .single();
                
                if (messageError) throw messageError;
                
                appendMessage(messageData);
                
                const channel = supabase.channel(`event_${context.id}`);
                await channel.send({
                    type: 'broadcast',
                    event: 'new_message',
                    payload: {
                        id: messageData.id,
                        sender_id: currentUser.id,
                        sender_name: currentUser.name,
                        sender_avatar: currentUser.avatar,
                        content: messageData.content,
                        created_at: messageData.created_at
                    }
                });
                
            } else if (context.type === 'match') {
                // MATCH CHAT
                const { data: messageData, error: messageError } = await supabase
                    .from('match_messages')
                    .insert({
                        match_id: context.id,
                        sender_id: currentUser.id,
                        content: `<img src="${photoUrl}" style="max-width: 100%; max-height: 300px; width: auto; height: auto; display: block; border-radius: 10px; cursor: pointer;" onclick="openImageModal('${photoUrl}')">`
                    })
                    .select(`*, sender:profiles(id, name, avatar)`)
                    .single();

                if (messageError) throw messageError;

                appendMessage(messageData);

                const channel = supabase.channel(`match_chat_${context.id}`);
                await channel.send({
                    type: 'broadcast',
                    event: 'new_message',
                    payload: {
                        id: messageData.id,
                        sender_id: currentUser.id,
                        sender_name: currentUser.name,
                        sender_avatar: currentUser.avatar,
                        content: messageData.content,
                        created_at: messageData.created_at
                    }
                });
            } else if (context.type === 'circle') {
                // CIRCLE CHAT
                const { data: messageData, error: messageError } = await supabase
                    .from('circle_messages')
                    .insert({
                        circle_id: context.id,
                        sender_id: currentUser.id,
                        content: `<img src="${photoUrl}" style="max-width: 100%; max-height: 300px; width: auto; height: auto; display: block; border-radius: 10px; cursor: pointer;" onclick="openImageModal('${photoUrl}')">`
                    })
                    .select(`*, sender:profiles(id, name, avatar)`)
                    .single();

                if (messageError) throw messageError;

                appendMessage(messageData);

                const channel = supabase.channel(`circle_chat_${context.id}`);
                await channel.send({
                    type: 'broadcast',
                    event: 'new_circle_message',
                    payload: {
                        id: messageData.id,
                        sender_id: currentUser.id,
                        sender_name: currentUser.name,
                        sender_avatar: currentUser.avatar,
                        content: messageData.content,
                        created_at: messageData.created_at
                    }
                });
            }
            
            hideLoader();
            showNotification('Photo shared!');
            
        } catch (error) {
            hideLoader();
            console.error('Error uploading photo:', error);
            showNotification('Failed to upload photo. Please try again.', 'error');
        }
    };
    
    input.click();
}

// Match notification functions
let currentMatchNotification = null;

function showMatchNotification(activity, matchId, otherUsers) {
    currentMatchNotification = matchId;
    
    // Set activity emoji
    document.getElementById('match-notification-activity').textContent = activity.emoji + ' ' + activity.name;
    
    // Set message based on whether others are interested
    let messageHTML = '';
    if (otherUsers && otherUsers.length > 0) {
        if (otherUsers.length === 1) {
            messageHTML = `${otherUsers[0].name} is also interested! Start chatting to plan something.`;
        } else if (otherUsers.length === 2) {
            messageHTML = `${otherUsers[0].name} and ${otherUsers[1].name} are also interested! Start planning together.`;
        } else {
            const hiddenUsers = otherUsers.slice(2);
            const hiddenNames = hiddenUsers.map(u => u.name).join(', ');
            messageHTML = `${otherUsers[0].name}, ${otherUsers[1].name}, and <a href="#" onclick="event.preventDefault(); alert('Also interested:\\n\\n${hiddenNames}');" style="color: #667eea; text-decoration: underline; cursor: pointer;">${otherUsers.length - 2} other${otherUsers.length - 2 > 1 ? 's' : ''}</a> are interested! Let's make it happen.`;
        }
    } else {
        messageHTML = `You're the first one interested! Others in your circle will see this and can join.`;
    }
    
    document.getElementById('match-notification-text').innerHTML = messageHTML;
    document.getElementById('match-notification-modal').style.display = 'flex';
}

window.closeMatchNotification = function() {
    document.getElementById('match-notification-modal').style.display = 'none';
    currentMatchNotification = null;
}

window.joinMatchFromNotification = async function() {
    if (!currentMatchNotification) {
        closeMatchNotification();
        return;
    }
    
    showLoader('Joining match...');
    
    try {
        // Add user to match participants
        const { error } = await supabase
            .from('match_participants')
            .insert([{ 
                match_id: currentMatchNotification, 
                profile_id: currentUser.id 
            }]);
        
        if (error) {
            // If error is duplicate key (user already joined), that's fine
            if (error.code !== '23505') {
                throw error;
            }
        }
        
        closeMatchNotification();
        hideLoader();
        
        // Reload matches and go to matches page
        await loadMatches();
        showPage('matches');
        
        showNotification('Joined match! You can now chat and schedule events.');
        
    } catch (error) {
        hideLoader();
        closeMatchNotification();
        console.error('Error joining match:', error);
        showNotification('Error joining match', 'error');
    }
}

function openLocationPermissionModal() {
    document.getElementById('location-permission-modal').style.display = 'flex';
}

function closeLocationPermissionModal() {
    document.getElementById('location-permission-modal').style.display = 'none';
}

async function requestLocationPermission() {
    closeLocationPermissionModal();
    
    // Request permission by attempting to get location
    navigator.geolocation.getCurrentPosition(
        (position) => {
            showNotification('Location access enabled!');
            // Store that we have permission
            localStorage.setItem('location_permission_granted', 'true');
        },
        (error) => {
            if (error.code === error.PERMISSION_DENIED) {
                alert('Location access was denied. Please enable it in your browser settings:\n\n1. Click the lock/info icon in the address bar\n2. Find "Location" permissions\n3. Change to "Allow"');
            } else {
                showNotification('Could not access location. Please try again.', 'error');
            }
        }
    );
}

async function checkLocationPermission() {
    // Check if browser supports permissions API
    if (!navigator.permissions) {
        // Fallback: just check if geolocation exists
        return navigator.geolocation ? 'prompt' : 'unsupported';
    }
    
    try {
        const result = await navigator.permissions.query({ name: 'geolocation' });
        return result.state; // 'granted', 'denied', or 'prompt'
    } catch (error) {
        // Safari doesn't support permissions.query for geolocation
        return 'prompt';
    }
}

        window.shareLocation = async function() {
    if (!navigator.geolocation) {
        return showNotification('Geolocation not supported on this device', 'error');
    }
    
    const context = getCurrentChatContext();
    
    if (context.type === 'none') {
        return showNotification('No active chat to share location', 'error');
    }
    
    const permission = await checkLocationPermission();
    
    if (permission === 'denied') {
        alert('Location access is blocked. Please enable it in your browser settings:\n\n1. Click the lock/info icon in the address bar\n2. Find "Location" permissions\n3. Change to "Allow"\n4. Reload the page');
        return;
    }
    
    if (permission === 'prompt') {
        openLocationPermissionModal();
        return;
    }
    
    console.log('📍 Sharing location in context:', context.type);
    
    navigator.geolocation.getCurrentPosition(
        async (pos) => {
            const lat = pos.coords.latitude;
            const lng = pos.coords.longitude;
            const mapsUrl = `https://www.google.com/maps?q=${lat},${lng}`;
            
            try {
                if (context.type === 'event') {
                    // EVENT CHAT
                    const { data, error } = await supabase
                        .from('event_messages')
                        .insert({
                            event_id: context.id,
                            sender_id: currentUser.id,
                            content: `📍 <a href="${mapsUrl}" target="_blank" rel="noopener noreferrer" style="color: #1e90ff; text-decoration: underline; font-weight: 500;">View Location on Map</a>`
                        })
                        .select(`*, sender:profiles(id, name, avatar)`)
                        .single();
                    
                    if (error) throw error;
                    
                    appendMessage(data);
                    
                    const channel = supabase.channel(`event_${context.id}`);
                    await channel.send({
                        type: 'broadcast',
                        event: 'new_message',
                        payload: {
                            id: data.id,
                            sender_id: currentUser.id,
                            sender_name: currentUser.name,
                            sender_avatar: currentUser.avatar,
                            content: data.content,
                            created_at: data.created_at
                        }
                    });
                    
                } else if (context.type === 'match') {
                    // MATCH CHAT
                    const { data, error } = await supabase
                        .from('match_messages')
                        .insert({
                            match_id: context.id,
                            sender_id: currentUser.id,
                            content: `📍 <a href="${mapsUrl}" target="_blank" rel="noopener noreferrer" style="color: #1e90ff; text-decoration: underline; font-weight: 500;">View Location on Map</a>`
                        })
                        .select(`*, sender:profiles(id, name, avatar)`)
                        .single();

                    if (error) throw error;

                    appendMessage(data);

                    const channel = supabase.channel(`match_chat_${context.id}`);
                    await channel.send({
                        type: 'broadcast',
                        event: 'new_general_message',
                        payload: {
                            id: data.id,
                            sender_id: currentUser.id,
                            sender_name: currentUser.name,
                            sender_avatar: currentUser.avatar,
                            content: data.content,
                            created_at: data.created_at
                        }
                    });
                } else if (context.type === 'circle') {
                    // CIRCLE CHAT
                    const { data, error } = await supabase
                        .from('circle_messages')
                        .insert({
                            circle_id: context.id,
                            sender_id: currentUser.id,
                            content: `📍 <a href="${mapsUrl}" target="_blank" rel="noopener noreferrer" style="color: #1e90ff; text-decoration: underline; font-weight: 500;">View Location on Map</a>`
                        })
                        .select(`*, sender:profiles(id, name, avatar)`)
                        .single();

                    if (error) throw error;

                    appendMessage(data);

                    const channel = supabase.channel(`circle_chat_${context.id}`);
                    await channel.send({
                        type: 'broadcast',
                        event: 'new_circle_message',
                        payload: {
                            id: data.id,
                            sender_id: currentUser.id,
                            sender_name: currentUser.name,
                            sender_avatar: currentUser.avatar,
                            content: data.content,
                            created_at: data.created_at
                        }
                    });
                }
                
                showNotification('Location shared!');
                
            } catch (error) {
                console.error('Error sharing location:', error);
                showNotification('Failed to share location. Please try again.', 'error');
            }
        },
        () => showNotification('Could not get location', 'error')
    );
}
        window.openImageModal = src => { document.getElementById('modal-image').src = src; document.getElementById('image-modal-overlay').style.display = 'flex'; };
        window.closeImageModal = () => document.getElementById('image-modal-overlay').style.display = 'none';
        window.openMap = (lat, lng) => window.open(`https://www.google.com/maps?q=${lat},${lng}`, '_blank');
window.findNearbyPlaces = async function() {
            if (!navigator.geolocation) {
                return showNotification('Geolocation not supported on this device', 'error');
            }
            
            const context = getCurrentChatContext();
            
            if (context.type === 'none') {
                return showNotification('This feature is only available in chats', 'error');
            }
            
            const permission = await checkLocationPermission();
            
            if (permission === 'denied') {
                alert('Location access is blocked. Please enable it in your browser settings:\n\n1. Click the lock/info icon in the address bar\n2. Find "Location" permissions\n3. Change to "Allow"\n4. Reload the page');
                return;
            }
            
            if (permission === 'prompt') {
                openLocationPermissionModal();
                return;
            }
            
            console.log('🔍 Finding nearby places in context:', context.type);
            
            showNotification('Finding nearby places...');
            
            navigator.geolocation.getCurrentPosition(
                async (pos) => {
                    const lat = pos.coords.latitude;
                    const lng = pos.coords.longitude;
                    
                    const activity = activities.find(a => a.id === context.data.activity_id);
                    const activityName = activity ? activity.name : 'restaurants';
                    
                    const searchUrl = `https://www.google.com/maps/search/${encodeURIComponent(activityName)}/@${lat},${lng},15z`;
                    
                    try {
    if (context.type === 'event') {
        // EVENT CHAT
        const { data, error } = await supabase
            .from('event_messages')
            .insert({
                event_id: context.id,
                sender_id: currentUser.id,
                content: `🔍 <a href="${searchUrl}" target="_blank" rel="noopener noreferrer" style="color: #667eea; text-decoration: underline; font-weight: 500;">Find nearby ${activityName} spots</a>`
            })
            .select(`*, sender:profiles(id, name, avatar)`)
            .single();
        
        if (error) throw error;
        
        appendMessage(data);
        
        const channel = supabase.channel(`event_${context.id}`);
        await channel.send({
            type: 'broadcast',
            event: 'new_message',
            payload: {
                id: data.id,
                sender_id: currentUser.id,
                sender_name: currentUser.name,
                sender_avatar: currentUser.avatar,
                content: data.content,
                created_at: data.created_at
            }
        });
        
    } else if (context.type === 'match') {
        // MATCH CHAT
        const { data, error } = await supabase
            .from('match_messages')
            .insert({
                match_id: context.id,
                sender_id: currentUser.id,
                content: `🔍 <a href="${searchUrl}" target="_blank" rel="noopener noreferrer" style="color: #667eea; text-decoration: underline; font-weight: 500;">Find nearby ${activityName} spots</a>`
            })
            .select(`*, sender:profiles(id, name, avatar)`)
            .single();

        if (error) throw error;

        appendMessage(data);

        const channel = supabase.channel(`match_chat_${context.id}`);
        await channel.send({
            type: 'broadcast',
            event: 'new_general_message',
            payload: {
                id: data.id,
                sender_id: currentUser.id,
                sender_name: currentUser.name,
                sender_avatar: currentUser.avatar,
                content: data.content,
                created_at: data.created_at
            }
        });
    } else if (context.type === 'circle') {
        // CIRCLE CHAT
        const { data, error } = await supabase
            .from('circle_messages')
            .insert({
                circle_id: context.id,
                sender_id: currentUser.id,
                content: `🔍 <a href="${searchUrl}" target="_blank" rel="noopener noreferrer" style="color: #667eea; text-decoration: underline; font-weight: 500;">Find nearby ${activityName} spots</a>`
            })
            .select(`*, sender:profiles(id, name, avatar)`)
            .single();

        if (error) throw error;

        appendMessage(data);

        const channel = supabase.channel(`circle_chat_${context.id}`);
        await channel.send({
            type: 'broadcast',
            event: 'new_circle_message',
            payload: {
                id: data.id,
                sender_id: currentUser.id,
                sender_name: currentUser.name,
                sender_avatar: currentUser.avatar,
                content: data.content,
                created_at: data.created_at
            }
        });
    }
    
    showNotification('Search link shared!');
} catch (error) {
                        console.error('Error sharing nearby places:', error);
                        showNotification('Failed to share search. Please try again.', 'error');
                    }
                },
                (error) => {
                    let errorMessage = 'Could not get location';
                    if (error.code === error.PERMISSION_DENIED) {
                        errorMessage = 'Location permission denied. Please enable location access in your browser settings.';
                    } else if (error.code === error.POSITION_UNAVAILABLE) {
                        errorMessage = 'Location information unavailable. Please try again.';
                    } else if (error.code === error.TIMEOUT) {
                        errorMessage = 'Location request timed out. Please try again.';
                    }
                    showNotification(errorMessage, 'error');
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        }
        
// Legacy function - badges are now shown on individual match cards
async function updateNotificationBadge() {
    // No-op: Badges are now displayed on individual match cards instead of nav tab
    console.log('Badge updates now handled per-card in displayMatches');
}

async function markMatchAsRead(matchId) {
    try {
        // Update last_read_at to now
        const { error } = await supabase
            .from('match_participants')
            .update({ last_read_at: new Date().toISOString() })
            .eq('match_id', matchId)
            .eq('profile_id', currentUser.id);

        if (error) throw error;

        console.log('✅ Marked match as read:', matchId);

        // Refresh match list to update badges
        if (window.location.hash === '#matches') {
            await loadMatches();
        }

    } catch (error) {
        console.error('Error marking match as read:', error);
    }
}

async function markEventAsRead(eventId) {
    try {
        // Update last_read_at to now (backwards compatible if column doesn't exist)
        const { error } = await supabase
            .from('event_participants')
            .update({ last_read_at: new Date().toISOString() })
            .eq('event_id', eventId)
            .eq('profile_id', currentUser.id);

        if (error) {
            // Silently fail if column doesn't exist yet
            if (error.code === '42703') {
                console.log('Event read tracking not available yet - run migration to enable');
                return;
            }
            throw error;
        }

        console.log('✅ Marked event as read:', eventId);

        // Refresh match list to update badges
        if (window.location.hash === '#matches') {
            await loadMatches();
        }

    } catch (error) {
        console.error('Error marking event as read:', error);
    }
}

// Calculate unread badge for a specific match
async function getMatchUnreadCount(matchId, lastReadAt) {
    try {
        if (!lastReadAt) return 0;

        // Get latest message in this match
        const { data: latestMessage, error } = await supabase
            .from('match_messages')
            .select('created_at, sender_id')
            .eq('match_id', matchId)
            .order('created_at', { ascending: false })
            .limit(1)
            .maybeSingle();

        if (error) {
            console.error('Error checking match messages:', error);
            return 0;
        }

        // If there's a message newer than last_read_at and it's not from current user
        if (latestMessage &&
            new Date(latestMessage.created_at) > new Date(lastReadAt) &&
            latestMessage.sender_id !== currentUser.id) {
            return 1;
        }

        return 0;
    } catch (error) {
        console.error('Error getting match unread count:', error);
        return 0;
    }
}

// Calculate unread badge for a specific event
async function getEventUnreadCount(eventId, lastReadAt) {
    try {
        if (!lastReadAt) return 0;

        // Get latest message in this event
        const { data: latestMessage, error } = await supabase
            .from('event_messages')
            .select('created_at, sender_id')
            .eq('event_id', eventId)
            .order('created_at', { ascending: false })
            .limit(1)
            .maybeSingle();

        if (error) {
            console.error('Error checking event messages:', error);
            return 0;
        }

        // If there's a message newer than last_read_at and it's not from current user
        if (latestMessage &&
            new Date(latestMessage.created_at) > new Date(lastReadAt) &&
            latestMessage.sender_id !== currentUser.id) {
            return 1;
        }

        return 0;
    } catch (error) {
        console.error('Error getting event unread count:', error);
        return 0;
    }
}

// Calculate unread badge for a specific circle
async function getCircleUnreadCount(circleId, lastReadAt) {
    try {
        if (!lastReadAt) return 0;

        // Get latest message in this circle
        const { data: latestMessage, error } = await supabase
            .from('circle_messages')
            .select('created_at, sender_id')
            .eq('circle_id', circleId)
            .order('created_at', { ascending: false })
            .limit(1)
            .maybeSingle();

        if (error) {
            console.error('Error checking circle messages:', error);
            return 0;
        }

        // If there's a message newer than last_read_at and it's not from current user
        if (latestMessage &&
            new Date(latestMessage.created_at) > new Date(lastReadAt) &&
            latestMessage.sender_id !== currentUser.id) {
            return 1;
        }

        return 0;
    } catch (error) {
        console.error('Error getting circle unread count:', error);
        return 0;
    }
}

        window.showPage = async function(pageId) {
    // Clean up subscriptions when leaving chat
if (pageId !== 'chat') {
    if (eventMessageSubscription) {
        supabase.removeChannel(eventMessageSubscription);
        const index1 = allActiveSubscriptions.indexOf(eventMessageSubscription);
        if (index1 > -1) allActiveSubscriptions.splice(index1, 1);
        eventMessageSubscription = null;
        currentEvent = null;
    }
    if (matchMessageSubscription) {
        supabase.removeChannel(matchMessageSubscription);
        const index2 = allActiveSubscriptions.indexOf(matchMessageSubscription);
        if (index2 > -1) allActiveSubscriptions.splice(index2, 1);
        matchMessageSubscription = null;
        currentMatchChat = null;
    }
    currentMatchId = null; // Clear match ID when leaving chat
    document.getElementById('event-details').style.display = 'block';
}
    
    localStorage.setItem('friendle_current_page', pageId);
    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
    document.getElementById(pageId).classList.add('active');
    document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
    document.querySelector(`.nav-item[onclick="showPage('${pageId}')"]`)?.classList.add('active');
    
    if (pageId === 'circles') renderCircles();
if (pageId === 'activities') {
    await populateCircleSelector();
    // If in swipe mode and circle is selected, initialize swipe view
    if (viewMode === 'swipe' && selectedCircle) {
        await initializeSwipeView();
    }
}
if (pageId === 'matches') {
    await loadMatches();
}
if (pageId === 'settings') {
    initAdvancedSettings();
}
}
        // Export user data for GDPR compliance
        window.exportData = async function() {
            try {
                const user = supabase.auth.getUser ? await supabase.auth.getUser() : null;
                const userId = user?.data?.user?.id;

                // Gather all user data
                const exportData = {
                    exportDate: new Date().toISOString(),
                    user: JSON.parse(localStorage.getItem('friendle_user') || 'null'),
                    preferences: {
                        lastCircle: localStorage.getItem('friendle_last_circle'),
                        activityCounts: JSON.parse(localStorage.getItem('friendle_activity_counts') || '{}'),
                        matches: JSON.parse(localStorage.getItem('friendle_matches') || '[]')
                    }
                };

                // Fetch user's circles and activities from Supabase if logged in
                if (userId) {
                    const { data: circles } = await supabase
                        .from('circles')
                        .select('*')
                        .eq('user_id', userId);

                    const { data: activities } = await supabase
                        .from('activities')
                        .select('*')
                        .eq('user_id', userId);

                    exportData.circles = circles || [];
                    exportData.activities = activities || [];
                }

                // Create and download JSON file
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `friendle-data-export-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                alert('Your data has been exported successfully!');
            } catch (error) {
                console.error('Export error:', error);
                alert('Failed to export data. Please try again.');
            }
        };

        // Delete all local data
        window.resetApp = () => {
            const confirmed = confirm(
                'DELETE ALL YOUR DATA?\n\n' +
                'This will permanently delete:\n' +
                '• All your circles and groups\n' +
                '• All your activities and matches\n' +
                '• All your preferences and settings\n' +
                '• Your profile information\n\n' +
                'This action CANNOT be undone!\n\n' +
                'Are you absolutely sure you want to continue?'
            );

            if (confirmed) {
                const doubleCheck = confirm(
                    'FINAL WARNING!\n\n' +
                    'You are about to delete everything. This is your last chance to cancel.\n\n' +
                    'Click OK to delete all data, or Cancel to keep your data.'
                );

                if (doubleCheck) {
                    localStorage.clear();
                    alert('All data has been deleted. The app will now reload.');
                    location.reload();
                }
            }
        };

        // Toggle Advanced Settings section
        window.toggleAdvancedSettings = function() {
            const content = document.getElementById('advanced-settings-content');
            const arrow = document.getElementById('advanced-settings-arrow');
            const isExpanded = content.style.maxHeight && content.style.maxHeight !== '0px';

            if (isExpanded) {
                // Collapse
                content.style.maxHeight = '0';
                arrow.style.transform = 'rotate(0deg)';
                localStorage.setItem('advanced_settings_expanded', 'false');
            } else {
                // Expand - set to scrollHeight to animate smoothly
                content.style.maxHeight = content.scrollHeight + 'px';
                arrow.style.transform = 'rotate(180deg)';
                localStorage.setItem('advanced_settings_expanded', 'true');
            }
        };

        // Initialize Advanced Settings state on page load
        window.initAdvancedSettings = function() {
            const isExpanded = localStorage.getItem('advanced_settings_expanded') === 'true';
            if (isExpanded) {
                const content = document.getElementById('advanced-settings-content');
                const arrow = document.getElementById('advanced-settings-arrow');
                content.style.maxHeight = content.scrollHeight + 'px';
                arrow.style.transform = 'rotate(180deg)';
            }
        };
        
        // Invite System
        window.showInviteModal = function(circleId) {
            const baseUrl = window.location.href.split('?')[0];
            const inviteToken = `invite_${circleId}_${Date.now()}`;
            const inviteLink = `${baseUrl}?invite_token=${inviteToken}`;
            document.getElementById('invite-link').value = inviteLink;
            document.getElementById('invite-modal-overlay').style.display = 'flex';
        }
        window.closeInviteModal = () => document.getElementById('invite-modal-overlay').style.display = 'none';
        window.copyInviteLink = function() {
            const linkInput = document.getElementById('invite-link');
            linkInput.select();
            document.execCommand('copy');
            showNotification('Link copied to clipboard!');
        }
        function processInvite() {
            const token = sessionStorage.getItem('pending_invite');
            if (token && currentUser) {
                const allCircles = JSON.parse(localStorage.getItem('friendle_circles') || '[]');
                const circleId = parseInt(token.split('_')[1]);
                const circle = allCircles.find(c => c.id === circleId);
                if (circle && !circle.members.some(m => m.id === currentUser.id)) {
                    circle.members.push(currentUser);
                    localStorage.setItem('friendle_circles', JSON.stringify(allCircles));
                    circles = allCircles; // Make sure our in-memory list is updated
                    showNotification(`Invite accepted! You've joined "${circle.name}".`);
                }
                sessionStorage.removeItem('pending_invite');
                renderCircles(); // Re-render to show the new circle membership
            }
}

 async function initApp() {
    // Check if this is a password recovery flow (from email link)
    const hashParams = new URLSearchParams(window.location.hash.substring(1));
    const isPasswordRecovery = hashParams.get('type') === 'recovery';

    if (isPasswordRecovery) {
        // Show loader with recovery message
        showLoader('Processing password reset...');
        // Show auth page immediately so user doesn't see other content
        document.getElementById('auth').classList.add('active');
        // The onAuthStateChange listener will handle showing the password reset form
        // when the PASSWORD_RECOVERY event fires
        return;
    }

    // Show loader immediately while checking auth
    showLoader('Loading...');

    const urlParams = new URLSearchParams(window.location.search);
    const inviteCode = urlParams.get('invite_code');

    // Store invite code for after authentication
    if (inviteCode) {
        sessionStorage.setItem('pending_invite_code', inviteCode);
    }
    // Note: We'll clean up URL later, after checking for chat parameters

    // Check for existing Supabase auth session
    const { data: { session } } = await supabase.auth.getSession();

    if (session) {
        // User is authenticated, load their profile
        try {
            const { data: profileData, error } = await supabase
                .from('profiles')
                .select('*')
                .eq('id', session.user.id)
                .single();

            if (error) throw error;

            currentUser = profileData;

            // Load default activities AFTER authentication is confirmed
            // This ensures RLS policies allow the query to succeed
            await loadDefaultActivities();
            
            if ('Notification' in window && Notification.permission === 'default') {
    // Show friendly custom prompt before browser prompt
    showNotificationPrompt();
}
            
            // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser);

            await renderCircles();
            window.appState.circlesLoaded = true;
            console.log('✅ Circles loaded, updating app state');

            await loadMatches();
            window.appState.matchesLoaded = true;
            console.log('✅ Matches loaded, updating app state');

            await updateNotificationBadge();

            // Mark app as fully initialized and data loaded
            window.appState.initialized = true;
            window.appState.dataLoaded = true;
            console.log('✅ App fully initialized:', JSON.stringify(window.appState));

            const lastPage = localStorage.getItem('friendle_current_page') || 'activities';
            
            // Check if we should open a chat from notification click
            const openChatId = urlParams.get('openChat');
            const openChatType = urlParams.get('chatType');

            console.log('🔍 Checking for chat to open:', { openChatId, openChatType, matches: matches?.length });

            if (openChatId && openChatType) {
                console.log('✅ Found chat to open from notification!');
                console.log('   - Chat Type:', openChatType);
                console.log('   - Chat ID:', openChatId);
                console.log('   - Matches loaded:', matches?.length || 0);

                // Clean up URL (remove all query parameters)
                window.history.replaceState({}, document.title, window.location.pathname);

                // DON'T show any other page - let the chat function handle the page display
                // This prevents race conditions where we might navigate away

                // Wait for everything to be ready, then open chat (critical for iOS)
                console.log('⏳ Waiting for app to be fully ready before opening chat from URL...');
                try {
                    await window.waitForAppReady(30000); // 30 second timeout for slower devices
                    console.log('✅ App ready, opening chat from URL');

                    // Add retry logic for robustness
                    const maxRetries = 3;
                    for (let attempt = 1; attempt <= maxRetries; attempt++) {
                        try {
                            console.log(`🚀 Attempt ${attempt}/${maxRetries}: Opening chat...`, openChatType, openChatId);

                            if (openChatType === 'match') {
                                await openMatchChatThreaded(openChatId);
                            } else if (openChatType === 'event') {
                                await openEventChat(openChatId);
                            } else if (openChatType === 'circle') {
                                await openCircleChat(openChatId);
                            }

                            console.log('✅ Chat opened successfully on attempt', attempt);
                            break; // Success, exit retry loop

                        } catch (error) {
                            console.error(`❌ Attempt ${attempt} failed:`, error);
                            if (attempt < maxRetries) {
                                const delayMs = 500 * Math.pow(2, attempt - 1);
                                console.log(`⏳ Waiting ${delayMs}ms before retry...`);
                                await new Promise(resolve => setTimeout(resolve, delayMs));
                            } else {
                                throw error; // Final attempt failed
                            }
                        }
                    }
                } catch (error) {
                    console.error('❌ Error opening chat from notification:', error);
                    console.error('❌ Error stack:', error.stack);
                    console.error('❌ App state at error:', window.appState);
                    // On error, show matches page as fallback
                    showPage('matches');
                    showNotification('Could not open chat. Please try again from the Matches tab.', 'error');
                }
            } else {
                // Don't restore chat page on full refresh - go to matches instead
                if (lastPage === 'chat') {
                    showPage('matches');
                } else {
                    showPage(lastPage);
                }
            }
            
            updateProfile();
            await processInviteCode();

            hideLoader(); // Hide loader after everything loads

            // Track visit for PWA install prompt
            trackPWAVisit();

            // Show PWA install prompt after a delay (if conditions are met)
            setTimeout(() => {
                showPWAPrompt();
            }, 2000);
            
        } catch (error) {
            console.error('Error loading profile:', error);
            await supabase.auth.signOut();
            hideLoader();
            showOnboarding();
        }
    } else {
        // No authenticated session
        currentUser = null;
        // SECURITY: Clear all stored user data
        SecureStorage.clearAll();

        // Check if there are chat parameters from notification click
        const openChatId = urlParams.get('openChat');
        const openChatType = urlParams.get('chatType');

        if (openChatId && openChatType) {
            // Store them for after login
            sessionStorage.setItem('pending_chat_id', openChatId);
            sessionStorage.setItem('pending_chat_type', openChatType);
            console.log('📌 Stored pending chat for after login:', { openChatId, openChatType });

            // Clean up URL parameters
            window.history.replaceState({}, document.title, window.location.pathname);
        }

        hideLoader();
        showOnboarding();
    }
}

async function showOnboarding() {
    // Check if there's a pending invite
    const inviteCode = sessionStorage.getItem('pending_invite_code');
    
    if (inviteCode) {
        // Show invite context
        document.getElementById('invite-context').style.display = 'block';
        document.getElementById('generic-pitch').style.display = 'none';
        document.getElementById('onboarding-cta').textContent = 'Join Circle';
        
        // Try to load circle name
        try {
            const { data: circle, error } = await supabase
                .from('circles')
                .select('name')
                .eq('code', inviteCode)
                .single();
            
            if (circle) {
                document.getElementById('invite-circle-name').textContent = `"${circle.name}"`;
            } else {
                document.getElementById('invite-circle-name').textContent = 'this circle';
            }
        } catch (error) {
            console.error('Error loading circle name:', error);
            document.getElementById('invite-circle-name').textContent = 'this circle';
        }
    } else {
        // Show generic pitch
        document.getElementById('invite-context').style.display = 'none';
        document.getElementById('generic-pitch').style.display = 'block';
        document.getElementById('onboarding-cta').textContent = 'Get Started';
    }
    
    showPage('onboarding');
}

// Pull-to-Refresh functionality
let pullStartY = 0;
let pullMoveY = 0;
let isPulling = false;
let pullThreshold = 150; // Much higher threshold - need a very deliberate pull
let pullStartThreshold = 60; // Don't even show indicator until 60px pull
let pullStartTime = 0;
let minPullDuration = 200; // Must pull for at least 200ms to prevent accidental triggers

function initPullToRefresh() {
    const indicator = document.getElementById('pull-refresh-indicator');
    const icon = document.getElementById('pull-refresh-icon');
    const text = document.getElementById('pull-refresh-text');
    
    document.addEventListener('touchstart', (e) => {
        // Only allow pull at top of page AND in scrollable containers
        const target = e.target;
        const scrollableParent = target.closest('.page, .chat-messages');
        
        if (scrollableParent) {
            // Check if at top of scrollable container
            if (scrollableParent.scrollTop === 0 && window.scrollY === 0) {
                pullStartY = e.touches[0].clientY;
                pullStartTime = Date.now();
                isPulling = true;
            }
        }
    });
    
    document.addEventListener('touchmove', (e) => {
        if (!isPulling) return;
        
        pullMoveY = e.touches[0].clientY;
        const pullDistance = pullMoveY - pullStartY;
        
        // Only respond to downward pulls that exceed the start threshold
        if (pullDistance > pullStartThreshold) {
            // Prevent default scroll only when we're actually pulling
            const target = e.target;
            const scrollableParent = target.closest('.page, .chat-messages');
            if (scrollableParent && scrollableParent.scrollTop === 0 && window.scrollY === 0) {
                e.preventDefault();
            }
            
            // Calculate indicator position (with much more resistance)
            const indicatorTop = Math.min((pullDistance - pullStartThreshold) * 0.25, 60);
            indicator.style.top = (indicatorTop - 60) + 'px';
            
            // Update icon and text based on pull distance
            if (pullDistance > pullThreshold) {
                icon.textContent = '↻';
                icon.style.transform = 'rotate(180deg)';
                text.textContent = 'Release to refresh';
                text.style.color = '#667eea';
            } else {
                icon.textContent = '↓';
                icon.style.transform = 'rotate(0deg)';
                text.textContent = 'Pull to refresh';
                text.style.color = '#666';
            }
        }
    }, { passive: false });
    
    document.addEventListener('touchend', async (e) => {
        if (!isPulling) return;
        
        const pullDistance = pullMoveY - pullStartY;
        const pullDuration = Date.now() - pullStartTime;
        
        // Only trigger if pulled far enough AND held long enough
        if (pullDistance > pullThreshold && pullDuration > minPullDuration) {
            // Trigger refresh
            icon.textContent = '⟳';
            icon.style.animation = 'spin 1s linear infinite';
            text.textContent = 'Refreshing...';
            
            // Determine which page to refresh
            const activePage = document.querySelector('.page.active').id;
            
            try {
                if (activePage === 'matches') {
                    await loadMatches();
                } else if (activePage === 'circles') {
                    await renderCircles();
                } else if (activePage === 'activities') {
                    await renderActivities();
                }
                
                // Brief success state
                icon.textContent = '✓';
                icon.style.animation = 'none';
                icon.style.transform = 'rotate(0deg)'; // Reset rotation for checkmark
                text.textContent = 'Refreshed!';
                
                setTimeout(() => {
                    resetPullIndicator();
                }, 500);
            } catch (error) {
                console.error('Error refreshing:', error);
                resetPullIndicator();
            }
        } else {
            // Didn't pull far enough - reset
            resetPullIndicator();
        }
        
        isPulling = false;
        pullStartY = 0;
        pullMoveY = 0;
    });
}

function resetPullIndicator() {
    const indicator = document.getElementById('pull-refresh-indicator');
    const icon = document.getElementById('pull-refresh-icon');
    const text = document.getElementById('pull-refresh-text');
    
    indicator.style.top = '-60px';
    icon.textContent = '↓';
    icon.style.transform = 'rotate(0deg)';
    icon.style.animation = 'none';
    text.textContent = 'Pull to refresh';
    text.style.color = '#666';
}

// Global error handlers - catch unexpected errors
window.addEventListener('error', (event) => {
    console.error('Global error caught:', event.error);
    
    // Don't show notification for script loading errors (external resources)
    if (event.message && event.message.includes('Script error')) {
        return;
    }
    
    // Show user-friendly error message
    showNotification('Something went wrong. Please refresh the page if issues persist.', 'error');
    
    // Hide any active loaders
    hideLoader();
});

window.addEventListener('unhandledrejection', (event) => {
    console.error('Unhandled promise rejection:', event.reason);
    
    // Show user-friendly error message
    showNotification('An error occurred. Please try again.', 'error');
    
    // Hide any active loaders
    hideLoader();
    
    // Prevent default browser console error
    event.preventDefault();
});

// Detect network connectivity issues
window.addEventListener('online', () => {
    showNotification('Connection restored!');
});

window.addEventListener('offline', () => {
    showNotification('No internet connection. Some features may not work.', 'error');
    hideLoader(); // Hide any pending loaders
});

// ✅ Run after DOM is ready
document.addEventListener("DOMContentLoaded", () => {
  console.log("DOM ready, attaching avatar clicks...");
  
  // Initialize pull-to-refresh
  initPullToRefresh();

  const avatars = document.querySelectorAll(".avatar-option");
  console.log("Found avatars:", avatars.length);

    avatars.forEach(option => {
    option.addEventListener("click", () => {
      console.log("Avatar clicked:", option.dataset.avatar);
      avatars.forEach(o => o.classList.remove("selected"));
      option.classList.add("selected");

      // If this is in the registration form, clear any uploaded photo and reset preview
      if (option.closest('#register-form')) {
        window.registerPhotoFile = null;
        const preview = document.getElementById('register-profile-preview');
        const display = document.getElementById('register-avatar-display');
        if (preview && display) {
          preview.style.backgroundImage = '';
          display.innerHTML = option.dataset.avatar;
          display.style.fontSize = '50px';
        }
      }
    });
  });

// Create event form submission
document.getElementById('create-event-form').addEventListener('submit', createEvent);

// Edit event form submission
document.getElementById('edit-event-form').addEventListener('submit', saveEventEdits);

window.openManageActivitiesModal = async function() {
    if (!selectedCircle) return;
    
    try {
        // Get circle-level visibility settings
const { data: circleActivities, error: visibilityError } = await supabase
    .from('circle_activities')
    .select('activity_id, is_visible')
    .eq('circle_id', selectedCircle.id);

if (visibilityError) throw visibilityError;

// Build visibility map - activities not in map use defaults (core=visible, extended=hidden)
const visibilityMap = {};
circleActivities?.forEach(ca => {
    visibilityMap[ca.activity_id] = ca.is_visible;
});
        
        const grid = document.getElementById('manage-activities-grid');
        
        // Create sections for core, extended, and custom activities
        grid.innerHTML = `
    <div style="margin-bottom: 30px;">
        <h3 style="margin-bottom: 15px; color: #555; font-size: 1.1em; font-weight: 600; border-bottom: 1px solid #f0f0f0; padding-bottom: 5px;">Core Activities</h3>
        <div class="activities-grid" id="core-activities-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;"></div>
    </div>
    <div style="margin-bottom: 30px;">
        <h3 style="margin-bottom: 15px; color: #555; font-size: 1.1em; font-weight: 600; border-bottom: 1px solid #f0f0f0; padding-bottom: 5px;">Additional Activities</h3>
        <div class="activities-grid" id="extended-activities-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;"></div>
    </div>
    <div>
        <h3 style="margin-bottom: 15px; color: #555; font-size: 1.1em; font-weight: 600; border-bottom: 1px solid #f0f0f0; padding-bottom: 5px;">Custom Activities</h3>
        <div id="custom-activities-list" style="display: flex; flex-direction: column; gap: 10px;"></div>
    </div>
`;
        
        const coreGrid = document.getElementById('core-activities-grid');
const extendedGrid = document.getElementById('extended-activities-grid');

// Get core activities from defaultActivities array
const coreActivitiesArray = defaultActivities.filter(a => coreActivityIds.includes(a.id));

// Populate core activities
if (coreActivitiesArray.length === 0) {
    coreGrid.innerHTML = '<p style="color: #999; font-size: 14px; padding: 20px; text-align: center; grid-column: 1/-1;">No default core activities available. The database needs to be seeded.</p>';
} else {
    coreActivitiesArray.forEach(activity => {
        const card = document.createElement('div');
        // Core activities visible by default unless explicitly set otherwise
        const isVisible = visibilityMap.hasOwnProperty(activity.id)
            ? visibilityMap[activity.id]
            : true;
        card.className = `activity-card ${isVisible ? 'selected' : ''}`;
        card.onclick = () => toggleActivityVisibility(card, activity.id);
        card.dataset.activityId = activity.id;
        card.innerHTML = `
            <div class="activity-emoji">${activity.emoji || '🎯'}</div>
            <div class="activity-name">${activity.name}</div>
        `;
        coreGrid.appendChild(card);
    });
}

// Get extended activities from defaultActivities array
const extendedActivitiesArray = defaultActivities.filter(a => extendedActivityIds.includes(a.id));

// Populate extended activities
if (extendedActivitiesArray.length === 0) {
    extendedGrid.innerHTML = '<p style="color: #999; font-size: 14px; padding: 20px; text-align: center; grid-column: 1/-1;">No additional activities available.</p>';
} else {
    extendedActivitiesArray.forEach(activity => {
        const card = document.createElement('div');
        // Extended activities hidden by default unless explicitly set otherwise
        const isVisible = visibilityMap.hasOwnProperty(activity.id)
            ? visibilityMap[activity.id]
            : false;
        card.className = `activity-card ${isVisible ? 'selected' : ''}`;
        card.onclick = () => toggleActivityVisibility(card, activity.id);
        card.dataset.activityId = activity.id;
        card.innerHTML = `
            <div class="activity-emoji">${activity.emoji || '🎯'}</div>
            <div class="activity-name">${activity.name}</div>
        `;
        extendedGrid.appendChild(card);
    });
}

        // Load and display custom activities
        const { data: customActivities, error: customError } = await supabase
            .from('activities')
            .select('*')
            .eq('circle_id', selectedCircle.id)
            .order('name');
        
        if (customError) {
            console.error('Error loading custom activities:', customError);
        }
        
        const customList = document.getElementById('custom-activities-list');
        
        if (!customActivities || customActivities.length === 0) {
            customList.innerHTML = '<p style="color: #999; font-size: 14px; padding: 10px; text-align: center;">No custom activities yet. Use "Suggest a New Activity" to add one.</p>';
        } else {
            customActivities.forEach(activity => {
                const item = document.createElement('div');
                item.style.cssText = `
                    display: flex;
                    gap: 10px;
                    align-items: center;
                    padding: 12px;
                    background: #f8f9fa;
                    border-radius: 8px;
                    border: 2px solid #e1e5e9;
                `;
               item.innerHTML = `
    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
        <span style="font-size: 1.5em;">${activity.emoji}</span>
        <span style="flex: 1; font-weight: 500;">${activity.name}</span>
    </div>
    <div style="display: flex; gap: 6px;">
        <button onclick="event.stopPropagation(); editCustomActivity('${activity.id}', \`${activity.name.replace(/`/g, '\\`')}\`, '${activity.emoji}')" class="btn btn-secondary btn-small" style="margin: 0; padding: 6px 10px; font-size: 0.8em; flex: 1;">✏️ Edit</button>
        <button onclick="event.stopPropagation(); deleteCustomActivity('${activity.id}', \`${activity.name.replace(/`/g, '\\`')}\`);" class="btn btn-secondary btn-small" style="margin: 0; padding: 6px 10px; font-size: 0.8em; background: #dc3545; color: white; flex: 1;">🗑️ Delete</button>
    </div>
`;
                customList.appendChild(item);
            });
        }
        
        document.getElementById('manage-activities-modal-overlay').style.display = 'flex';
        
    } catch (error) {
        console.error('Error loading manage activities modal:', error);
    }
}

window.closeManageActivitiesModal = () => {
    document.getElementById('manage-activities-modal-overlay').style.display = 'none';
}

window.editCustomActivity = async function(activityId, currentName, currentEmoji) {
    const newName = prompt('Edit activity name:', currentName);
    
    if (!newName || newName.trim() === currentName) {
        return; // User cancelled or no change
    }
    
    try {
        showLoader('Updating activity...');
        
        const { error } = await supabase
            .from('activities')
            .update({ name: newName.trim() })
            .eq('id', activityId)
            .eq('circle_id', selectedCircle.id); // Safety check - only edit activities in this circle
        
        if (error) throw error;
        
        hideLoader();
        showNotification('Activity updated!');
        
        // Refresh the modal
        openManageActivitiesModal();
        
        // Refresh activities if on activities page
        if (document.getElementById('activities').classList.contains('active')) {
            renderActivities();
        }
        
    } catch (error) {
        hideLoader();
        console.error('Error editing activity:', error);
        showNotification('Error updating activity', 'error');
    }
}

window.deleteCustomActivity = async function(activityId, activityName) {
    if (!confirm(`Delete "${activityName}"?\n\nThis will remove it for all circle members and delete any associated preferences.`)) {
        return;
    }
    
    try {
        showLoader('Deleting activity...');
        
        // First delete any preferences for this activity
        const { error: prefError } = await supabase
            .from('preferences')
            .delete()
            .eq('activity_id', activityId)
            .eq('circle_id', selectedCircle.id);
        
        if (prefError) throw prefError;
        
        // Then delete the activity itself
        const { error: activityError } = await supabase
            .from('activities')
            .delete()
            .eq('id', activityId)
            .eq('circle_id', selectedCircle.id); // Safety check
        
        if (activityError) throw activityError;
        
        // Remove from local activities array if present
        const index = activities.findIndex(a => a.id === activityId);
        if (index > -1) {
            activities.splice(index, 1);
        }
        
        hideLoader();
        showNotification('Activity deleted!');
        
        // Refresh the modal
        openManageActivitiesModal();
        
        // Refresh activities if on activities page
        if (document.getElementById('activities').classList.contains('active')) {
            renderActivities();
        }
        
    } catch (error) {
        hideLoader();
        console.error('Error deleting activity:', error);
        showNotification('Error deleting activity', 'error');
    }
}

window.toggleActivityVisibility = function(card, activityId) {
    card.classList.toggle('selected');
}

window.saveActivityVisibility = async function() {
    try {
        // Get selected activities from modal
        const selectedCards = document.querySelectorAll('#manage-activities-grid .activity-card.selected');
        const selectedIds = Array.from(selectedCards).map(card => card.dataset.activityId);
        
        // Get all activity IDs
        const allActivityIds = [...coreActivityIds, ...extendedActivityIds];
        
        // Prepare upsert data for all activities
        const visibilityData = allActivityIds.map(activityId => ({
            circle_id: selectedCircle.id,
            activity_id: activityId,
            is_visible: selectedIds.includes(activityId)
        }));
        
        // Upsert to circle_activities table
        const { error } = await supabase
            .from('circle_activities')
            .upsert(visibilityData, { 
                onConflict: 'circle_id,activity_id'
            });
        
        if (error) throw error;
        
        showNotification('Activity preferences updated for all circle members!');
        closeManageActivitiesModal();
        renderActivities();
    } catch (error) {
        console.error('Error saving activity visibility:', error);
        showNotification('Error saving changes', 'error');
    }
};

// Edge-based swipe navigation between pages
(function initEdgeSwipeNavigation() {
    const pageOrder = ['circles', 'activities', 'matches', 'settings'];
    const EDGE_THRESHOLD = 50; // pixels from edge to initiate swipe
    const SWIPE_THRESHOLD = 80; // minimum swipe distance to trigger navigation

    let touchStartX = 0;
    let touchStartY = 0;
    let touchCurrentX = 0;
    let touchCurrentY = 0;
    let isEdgeSwipe = false;
    let isSwiping = false;

    const appContainer = document.querySelector('.app-container');

    if (!appContainer) {
        console.error('🚫 Edge swipe: app-container not found');
        return;
    }

    console.log('✅ Edge swipe navigation initialized');
    console.log('   Edge threshold:', EDGE_THRESHOLD + 'px');
    console.log('   Swipe threshold:', SWIPE_THRESHOLD + 'px');

    // Touch events
    appContainer.addEventListener('touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        touchCurrentX = touchStartX;
        touchCurrentY = touchStartY;

        // Simple edge detection - check if touch is within threshold of viewport edges
        const viewportWidth = window.innerWidth;

        if (touchStartX <= EDGE_THRESHOLD || touchStartX >= viewportWidth - EDGE_THRESHOLD) {
            isEdgeSwipe = true;
            isSwiping = false;
            console.log('👆 Edge touch at x=' + touchStartX + ', viewport=' + viewportWidth);
        } else {
            isEdgeSwipe = false;
        }
    }, { passive: true });

    appContainer.addEventListener('touchmove', (e) => {
        if (!isEdgeSwipe) return;

        touchCurrentX = e.touches[0].clientX;
        touchCurrentY = e.touches[0].clientY;
        const deltaX = touchCurrentX - touchStartX;
        const deltaY = touchCurrentY - touchStartY;

        // Only process if swipe is mostly horizontal
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
            if (!isSwiping) {
                isSwiping = true;
            }

            // Prevent scrolling during horizontal swipe
            e.preventDefault();

            // Apply visual feedback
            const activePage = document.querySelector('.page.active');
            if (activePage) {
                const visualFeedback = Math.min(Math.abs(deltaX) / 3, 60);
                const direction = deltaX > 0 ? 1 : -1;
                activePage.style.transform = `translateX(${direction * visualFeedback}px)`;
                activePage.style.transition = 'none';
                activePage.style.opacity = Math.max(0.7, 1 - (visualFeedback / 200));
            }
        }
    }, { passive: false });

    appContainer.addEventListener('touchend', (e) => {
        if (!isEdgeSwipe) return;

        const deltaX = touchCurrentX - touchStartX;
        const deltaY = touchCurrentY - touchStartY;
        const activePage = document.querySelector('.page.active');

        console.log('👆 Touch end - deltaX=' + deltaX + ', deltaY=' + deltaY + ', isSwiping=' + isSwiping);

        // Reset visual feedback
        if (activePage) {
            activePage.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out';
            activePage.style.transform = '';
            activePage.style.opacity = '';
        }

        // Navigate if swipe was horizontal enough and exceeded threshold
        if (isSwiping && Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > SWIPE_THRESHOLD) {
            const currentPageId = localStorage.getItem('friendle_current_page') || 'circles';
            const currentIndex = pageOrder.indexOf(currentPageId);

            console.log('🔄 Navigating from page ' + currentPageId + ' (index ' + currentIndex + ')');

            let targetIndex;
            if (deltaX > 0) {
                // Swiped right - go to previous page
                targetIndex = currentIndex - 1;
            } else {
                // Swiped left - go to next page
                targetIndex = currentIndex + 1;
            }

            // Navigate if target page exists
            if (targetIndex >= 0 && targetIndex < pageOrder.length) {
                const targetPage = pageOrder[targetIndex];
                console.log('➡️ Navigating to: ' + targetPage);
                showPage(targetPage);
            } else {
                console.log('⚠️ No page at index ' + targetIndex);
            }
        } else {
            console.log('⚠️ Swipe not triggered - deltaX=' + Math.abs(deltaX) + ', threshold=' + SWIPE_THRESHOLD);
        }

        isEdgeSwipe = false;
        isSwiping = false;
    }, { passive: true });

    // Mouse events for desktop testing
    let isMouseDragging = false;
    let mouseStartX = 0;
    let mouseStartY = 0;
    let mouseCurrentX = 0;

    appContainer.addEventListener('mousedown', (e) => {
        mouseStartX = e.clientX;
        mouseStartY = e.clientY;
        mouseCurrentX = mouseStartX;

        const viewportWidth = window.innerWidth;

        if (mouseStartX <= EDGE_THRESHOLD || mouseStartX >= viewportWidth - EDGE_THRESHOLD) {
            isMouseDragging = true;
            isEdgeSwipe = true;
            console.log('🖱️ Edge mouse down at x=' + mouseStartX + ', viewport=' + viewportWidth);
        }
    });

    document.addEventListener('mousemove', (e) => {
        if (!isMouseDragging) return;

        mouseCurrentX = e.clientX;
        const deltaX = mouseCurrentX - mouseStartX;

        if (Math.abs(deltaX) > 10) {
            const activePage = document.querySelector('.page.active');
            if (activePage) {
                const visualFeedback = Math.min(Math.abs(deltaX) / 3, 60);
                const direction = deltaX > 0 ? 1 : -1;
                activePage.style.transform = `translateX(${direction * visualFeedback}px)`;
                activePage.style.transition = 'none';
                activePage.style.opacity = Math.max(0.7, 1 - (visualFeedback / 200));
            }
        }
    });

    document.addEventListener('mouseup', (e) => {
        if (!isMouseDragging) return;

        const deltaX = mouseCurrentX - mouseStartX;
        const activePage = document.querySelector('.page.active');

        console.log('🖱️ Mouse up - deltaX=' + deltaX);

        if (activePage) {
            activePage.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out';
            activePage.style.transform = '';
            activePage.style.opacity = '';
        }

        if (Math.abs(deltaX) > SWIPE_THRESHOLD) {
            const currentPageId = localStorage.getItem('friendle_current_page') || 'circles';
            const currentIndex = pageOrder.indexOf(currentPageId);

            console.log('🔄 Mouse navigating from: ' + currentPageId);

            let targetIndex;
            if (deltaX > 0) {
                targetIndex = currentIndex - 1;
            } else {
                targetIndex = currentIndex + 1;
            }

            if (targetIndex >= 0 && targetIndex < pageOrder.length) {
                const targetPage = pageOrder[targetIndex];
                console.log('➡️ Mouse navigating to: ' + targetPage);
                showPage(targetPage);
            }
        } else {
            console.log('⚠️ Mouse swipe too short - deltaX=' + Math.abs(deltaX));
        }

        isMouseDragging = false;
        isEdgeSwipe = false;
    });
})();

  initApp(); // start the app
});   // ✅ closes document.addEventListener("DOMContentLoaded", ...)

    </script>

    <!-- Camera Modal -->
    <div id="camera-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 10000; justify-content: center; align-items: center;">
        <div style="position: relative; max-width: 90%; max-height: 90%; display: flex; flex-direction: column; align-items: center;">
            <div style="position: relative; background: #000; border-radius: 12px; overflow: hidden;">
                <video id="camera-video" autoplay playsinline style="max-width: 100%; max-height: 70vh; display: block;"></video>
                <canvas id="camera-canvas" style="display: none;"></canvas>
            </div>
            <div style="margin-top: 20px; display: flex; gap: 15px;">
                <button class="btn" onclick="capturePhoto()" style="padding: 12px 24px; font-size: 1em;">📸 Capture</button>
                <button class="btn btn-secondary" onclick="closeCameraModal()" style="padding: 12px 24px; font-size: 1em;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Photo Menu Popup -->
    <div id="photo-menu" style="display: none; position: fixed; z-index: 9999; background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px; box-shadow: var(--shadow-lg); overflow: hidden; min-width: 180px;">
        <div onclick="handlePhotoMenuAction('camera')" style="padding: 12px 16px; cursor: pointer; border-bottom: 1px solid var(--border-color); transition: background 0.2s;" onmouseover="this.style.background='var(--hover-bg)'" onmouseout="this.style.background='transparent'">
            <div style="display: flex; align-items: center; gap: 10px;">
                <span style="font-size: 1.2em;">📷</span>
                <span style="color: var(--text-primary);">Take Photo</span>
            </div>
        </div>
        <div onclick="handlePhotoMenuAction('upload')" style="padding: 12px 16px; cursor: pointer; border-bottom: 1px solid var(--border-color); transition: background 0.2s;" onmouseover="this.style.background='var(--hover-bg)'" onmouseout="this.style.background='transparent'">
            <div style="display: flex; align-items: center; gap: 10px;">
                <span style="font-size: 1.2em;">📁</span>
                <span style="color: var(--text-primary);">Upload Photo</span>
            </div>
        </div>
        <div id="photo-menu-remove" onclick="handlePhotoMenuAction('remove')" style="padding: 12px 16px; cursor: pointer; transition: background 0.2s; display: none;" onmouseover="this.style.background='var(--hover-bg)'" onmouseout="this.style.background='transparent'">
            <div style="display: flex; align-items: center; gap: 10px;">
                <span style="font-size: 1.2em;">🗑️</span>
                <span style="color: var(--text-primary);">Remove Photo</span>
            </div>
        </div>
    </div>

    <!-- Avatar Selection Modal -->
    <div id="avatar-selection-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 10000; justify-content: center; align-items: center;" onclick="closeAvatarSelectionModal()">
        <div style="background: var(--card-bg); border-radius: 12px; padding: 30px; max-width: 400px; width: 90%;" onclick="event.stopPropagation()">
            <h3 style="margin: 0 0 20px 0; text-align: center; color: var(--text-primary);">Choose an Avatar</h3>
            <div class="avatar-grid" id="avatar-selection-grid" style="margin-bottom: 20px;">
                <div class="avatar-option" data-avatar="😊">😊</div><div class="avatar-option" data-avatar="🌟">🌟</div><div class="avatar-option" data-avatar="🦄">🦄</div><div class="avatar-option" data-avatar="🐨">🐨</div>
                <div class="avatar-option" data-avatar="🎮">🎮</div><div class="avatar-option" data-avatar="🎨">🎨</div><div class="avatar-option" data-avatar="⚡">⚡</div><div class="avatar-option" data-avatar="🌙">🌙</div>
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="btn" onclick="confirmAvatarSelection()" style="flex: 1;">Confirm</button>
                <button class="btn btn-secondary" onclick="closeAvatarSelectionModal()" style="flex: 1;">Cancel</button>
            </div>
        </div>
    </div>

</body>
</html>