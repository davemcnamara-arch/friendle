<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Friendle - Who's in?</title>
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#5b4fc7">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Light Mode Colors */
            --primary-gradient-start: #5b4fc7;
            --primary-gradient-end: #6d3a9f;
            --primary-color: #5b4fc7;
            --primary-hover: #4d41a8;
            --bg-color: #ffffff;
            --bg-secondary: #f8f9fb;
            --text-primary: #1a1a1a;
            --text-secondary: #666666;
            --text-tertiary: #999999;
            --border-color: #e5e7eb;
            --border-hover: #d1d5db;
            --card-bg: #ffffff;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 20px;
            --transition-speed: 0.2s;
        }

        body.dark-mode {
            --primary-gradient-start: #6d5acf;
            --primary-gradient-end: #7d4aaf;
            --primary-color: #7866d9;
            --primary-hover: #8a7ae3;
            --bg-color: #0f0f11;
            --bg-secondary: #1a1a1e;
            --text-primary: #e5e5e7;
            --text-secondary: #a8a8aa;
            --text-tertiary: #6e6e70;
            --border-color: #2a2a2e;
            --border-hover: #3a3a3e;
            --card-bg: #1a1a1e;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.6);
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, var(--primary-gradient-start) 0%, var(--primary-gradient-end) 100%);
            color: var(--text-primary);
            transition: background var(--transition-speed) ease, color var(--transition-speed) ease;
        }

        .app-container {
            max-width: 400px;
            margin: 0 auto;
            background: var(--bg-color);
            height: 100%;
            position: relative;
            box-shadow: var(--shadow-xl);
            display: flex;
            flex-direction: column;
            transition: background var(--transition-speed) ease;
        }

        .page {
            display: none;
            padding: 20px;
            flex: 1;
            overflow-y: auto;
        }

        .page.active {
            display: block;
        }

        .page#chat.active {
            display: flex;
            flex-direction: column;
            padding: 0;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            overflow: hidden;
            padding: 8px 0;
        }

        .logo {
            font-size: 2.5em;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary-gradient-start), var(--primary-gradient-end));
            background-size: 100% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            display: inline-block;
            line-height: 1.3;
            position: relative;
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
            padding: 0;
        }

        .tagline {
            color: var(--text-secondary);
            font-size: 0.9em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-primary);
        }

        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 12px 14px;
            border: 2px solid var(--border-color);
            border-radius: var(--radius-md);
            font-size: 16px;
            font-family: inherit;
            background: var(--bg-color);
            color: var(--text-primary);
            transition: border-color var(--transition-speed), box-shadow var(--transition-speed);
        }

        .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(91, 79, 199, 0.1);
        }
        
        #activity-search {
            margin-bottom: 20px;
        }

        .btn {
            width: 100%;
            padding: 14px 20px;
            background: linear-gradient(135deg, var(--primary-gradient-start), var(--primary-gradient-end));
            color: white;
            border: none;
            border-radius: var(--radius-md);
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform var(--transition-speed), box-shadow var(--transition-speed), filter var(--transition-speed);
            margin: 10px 0;
            font-family: inherit;
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: var(--shadow-lg);
            filter: brightness(1.05);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--border-hover);
            box-shadow: var(--shadow-md);
            filter: none;
        }
        
        .btn-small {
            width: auto;
            padding: 10px 20px;
            font-size: 0.9em;
            margin-top: 0;
        }

        .avatar-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .avatar-option {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid var(--border-color);
            cursor: pointer;
            transition: all var(--transition-speed);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            background: var(--bg-secondary);
        }

        .avatar-option:hover {
            transform: scale(1.08);
            border-color: var(--primary-color);
        }

        .avatar-option.selected {
            border-color: var(--primary-color);
            background: linear-gradient(135deg, var(--primary-gradient-start), var(--primary-gradient-end));
            color: white;
            box-shadow: var(--shadow-md);
        }

        .profile-picture-container {
            position: relative;
            width: 120px;
            height: 120px;
            margin: 0 auto 20px;
            cursor: pointer;
        }

        .profile-picture {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            object-fit: cover;
            border: 4px solid var(--border-color);
            background: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            transition: all var(--transition-speed);
        }

        .profile-picture:hover {
            border-color: var(--primary-color);
            transform: scale(1.05);
        }

        .profile-picture-small {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--border-color);
            background: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            flex-shrink: 0;
        }

        .profile-picture-overlay {
            position: absolute;
            bottom: 0;
            right: 0;
            background: var(--primary-color);
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            border: 3px solid var(--bg-color);
            transition: all var(--transition-speed);
        }

        .profile-picture-overlay:hover {
            background: var(--primary-hover);
            transform: scale(1.1);
        }

        .avatar-display {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }

        .avatar-display.emoji {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            background: var(--bg-secondary);
        }

        .circle-card {
            background: var(--card-bg);
            border-radius: var(--radius-lg);
            padding: 20px;
            margin: 15px 0;
            border: 2px solid var(--border-color);
            transition: all var(--transition-speed);
            box-shadow: var(--shadow-sm);
        }

        .circle-card.unread {
            border: 2px solid #14b8a6;
            background: #ccfbf1;
        }

        body.dark-mode .circle-card.unread {
            background: #134e4a;
        }

        .circle-card .main-content {
            cursor: pointer;
        }

        .circle-card-header:hover {
            opacity: 0.8;
        }

        .circle-name {
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--text-primary);
        }

        .circle-members {
            color: var(--text-secondary);
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .circle-code {
            background: var(--bg-secondary);
            padding: 10px;
            border-radius: var(--radius-sm);
            font-size: 0.8em;
            color: var(--text-secondary);
            text-align: center;
            margin-top: 10px;
            border: 1px solid var(--border-color);
        }

        .circle-code strong {
            letter-spacing: 2px;
            font-size: 1.1em;
            color: var(--primary-color);
            font-weight: 600;
        }

        .circle-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            gap: 12px;
        }

        .circle-card-header-left {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
            min-width: 0;
        }

        .circle-card-header-right {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
        }

        .circle-expand-icon {
            font-size: 1.2em;
            transition: transform 0.2s ease;
            color: var(--text-secondary);
        }

        .circle-card.expanded .circle-expand-icon {
            transform: rotate(180deg);
        }

        .circle-card-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .circle-card.expanded .circle-card-content {
            max-height: 500px;
            margin-top: 15px;
        }

        .circle-new-message-badge {
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 600;
            white-space: nowrap;
            background: #14b8a6;
            color: white;
            transition: background 0.2s ease;
            cursor: pointer;
        }

        .circle-new-message-badge:hover {
            background: #0f9488;
        }

        .activities-grid, .frequent-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .section-title {
            font-size: 1.1em;
            font-weight: 600;
            color: var(--text-primary);
            margin: 20px 0 10px;
            padding-bottom: 8px;
            border-bottom: 2px solid var(--border-color);
        }

        .activity-card {
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all var(--transition-speed);
            position: relative;
            box-shadow: var(--shadow-sm);
        }

        .activity-card:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-lg);
            border-color: var(--primary-color);
        }

        .activity-card.selected {
            background: linear-gradient(135deg, var(--primary-gradient-start), var(--primary-gradient-end));
            color: white;
            border-color: var(--primary-color);
            box-shadow: var(--shadow-md);
        }

        .activity-interest-badge {
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 1.2em;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        body.dark-mode .activity-card {
            background: #1a1a1e !important;
            border-color: #2a2a2e !important;
        }

        body.dark-mode .activity-card:hover {
            border-color: var(--primary-color) !important;
            box-shadow: var(--shadow-lg) !important;
        }

        body.dark-mode .activity-card.selected {
            background: linear-gradient(135deg, var(--primary-gradient-start), var(--primary-gradient-end)) !important;
        }

        .activity-emoji {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .activity-name {
            font-weight: 600;
            font-size: 0.9em;
            color: var(--text-primary);
        }

        /* Match Cards */
        /* Match Circle Group Styles */
        .match-circle-group {
            margin-bottom: 20px;
            background: var(--card-bg);
            border-radius: 12px;
            box-shadow: var(--shadow-sm);
            border: 2px solid var(--border-color);
            transition: all 0.3s ease;
        }

        .match-circle-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            cursor: pointer;
            user-select: none;
            transition: background 0.2s ease;
            border-radius: 12px;
        }

        .match-circle-header:hover {
            background: var(--bg-secondary);
        }

        .match-circle-name {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .match-circle-header-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .match-circle-count {
            font-size: 14px;
            color: var(--text-secondary);
            padding: 4px 10px;
            background: var(--bg-secondary);
            border-radius: 10px;
        }

        .match-circle-badge {
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 600;
            white-space: nowrap;
        }

        .match-circle-badge.highlighted {
            background: #ffeb3b;
            color: #000;
        }

        .match-circle-badge.warning {
            background: #ff4d4f;
            color: white;
        }

        .match-circle-badge.unread {
            background: #14b8a6;
            color: white;
        }

        .match-circle-expand-icon {
            font-size: 1.2em;
            transition: transform 0.2s ease;
            color: var(--text-secondary);
        }

        .match-circle-group.expanded .match-circle-expand-icon {
            transform: rotate(180deg);
        }

        .match-circle-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .match-circle-group.expanded .match-circle-content {
            max-height: 5000px;
            padding: 0 15px 15px 15px;
        }

        /* Highlighted state (yellow - highest priority) */
        .match-circle-group.highlighted {
            background: #fffbea;
            border: 2px solid #ffeb3b;
        }

        body.dark-mode .match-circle-group.highlighted {
            background: #2a2415;
            border: 2px solid #ffeb3b;
        }

        /* Warning state (red - second priority) */
        .match-circle-group.has-warning {
            background: #fff1f0;
            border: 2px solid #ff4d4f;
        }

        body.dark-mode .match-circle-group.has-warning {
            background: #2a1a1a;
            border: 2px solid #ff4d4f;
        }

        /* Unread state (teal - third priority) */
        .match-circle-group.unread {
            background: #ccfbf1;
            border: 2px solid #14b8a6;
        }

        body.dark-mode .match-circle-group.unread {
            background: #134e4a;
            border: 2px solid #14b8a6;
        }

        .match-card {
            margin-bottom: 15px;
            background: var(--card-bg);
            border-radius: 12px;
            box-shadow: var(--shadow-sm);
            position: relative;
            border: 1px solid var(--border-color);
        }

        /* Collapsible match card styles */
        .match-card summary {
            padding: 18px 24px;
            cursor: pointer;
            list-style: none;
            user-select: none;
            display: flex;
            align-items: center;
            width: 100%;
            transition: background 0.2s ease;
        }

        .match-card summary::-webkit-details-marker {
            display: none;
        }

        .match-card summary:hover {
            background: var(--bg-secondary);
            border-radius: 12px;
        }

        .match-card[open] summary {
            border-bottom: 1px solid var(--border-color);
            border-radius: 12px 12px 0 0;
        }

        .match-card-content {
            padding: 20px;
            animation: slideDown 0.2s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

        .match-summary-header {
            display: flex;
            flex-direction: column;
            width: 100%;
            gap: 12px;
        }

        .match-summary-top-line {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            width: 100%;
            gap: 16px;
        }

        .match-summary-activity {
            font-size: 20px;
            font-weight: 700;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-self: start;
            gap: 8px;
        }

        .match-summary-stats {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 13px;
            color: var(--text-secondary);
            flex-wrap: wrap;
        }

        .match-summary-right {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-shrink: 0;
        }

        .match-summary-stat {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 6px 12px;
            background: var(--bg-secondary);
            border-radius: 12px;
            white-space: nowrap;
            font-size: 13px;
        }

        .match-summary-badge {
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 13px;
            font-weight: 600;
            white-space: nowrap;
        }

        .match-summary-badge.unread {
            background: #14b8a6;
            color: white;
            transition: background 0.2s ease;
        }

        .match-summary-badge.unread:hover {
            background: #0f9488;
        }

        .match-summary-badge.warning {
            background: #ff4d4f;
            color: white;
        }

        .match-summary-circle {
            font-size: 13px;
            padding: 6px 12px;
            background: var(--primary-color);
            color: white;
            border-radius: 12px;
            white-space: nowrap;
            flex-shrink: 0;
            justify-self: center;
        }

        .dropdown-indicator {
            font-size: 20px;
            color: var(--text-primary);
            font-weight: 700;
            transition: transform 0.2s ease;
            flex-shrink: 0;
            justify-self: end;
        }

        .match-card[open] .dropdown-indicator {
            transform: rotate(180deg);
        }

        /* Responsive styles for mobile */
        @media (max-width: 768px) {
            .match-summary-activity {
                font-size: 18px;
            }

            .match-summary-circle {
                font-size: 11px;
                padding: 3px 8px;
            }

            .dropdown-indicator {
                font-size: 16px;
            }

            .match-summary-stats {
                gap: 8px;
            }
        }

        /* Teal shading for unread messages */
        .match-card.unread {
            background: #ccfbf1;
            border: 2px solid #14b8a6;
        }

        body.dark-mode .match-card.unread {
            background: #134e4a;
            border: 2px solid #14b8a6;
        }

        /* Red shading for inactivity warnings */
        .match-card.has-warning {
            background: #fff1f0;
            border: 2px solid #ff4d4f;
        }

        body.dark-mode .match-card.has-warning {
            background: #2a1a1a;
            border: 2px solid #ff4d4f;
        }

        /* Both unread and warning - prioritize warning (red) */
        .match-card.unread.has-warning {
            background: #fff1f0;
            border: 2px solid #ff4d4f;
        }

        body.dark-mode .match-card.unread.has-warning {
            background: #2a1a1a;
            border: 2px solid #ff4d4f;
        }

        .match-card h3 {
            margin: 0 0 4px 0;
            font-size: 20px;
            color: var(--text-primary);
        }

        .match-card p {
            color: var(--text-secondary);
        }

        .match-info-box {
            background: var(--bg-secondary);
            border: 2px solid var(--primary-color);
            border-radius: 10px;
            padding: 12px;
            text-align: center;
        }

        .match-info-box.warning {
            background: #fff1f0;
            border-color: #ff4d4f;
        }

        body.dark-mode .match-info-box.warning {
            background: #2a1a1a;
            border-color: #ff4d4f;
        }

        .match-info-box p {
            color: var(--text-primary);
        }

        .event-item {
            padding: 15px;
            margin-bottom: 10px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
            position: relative;
        }

        .event-item.pending {
            background: #fff8e1;
            border-left-color: #FFA726;
        }

        body.dark-mode .event-item.pending {
            background: #2a2415;
        }

        .event-item.unread {
            background: #ccfbf1;
            border: 2px solid #14b8a6;
        }

        body.dark-mode .event-item.unread {
            background: #134e4a;
        }

        /* Dark mode styles for upcoming events section */
        body.dark-mode #upcoming-events-section {
            background: var(--bg-secondary) !important;
        }

        body.dark-mode #upcoming-events-section h4 {
            color: var(--text-secondary) !important;
        }

        /* Dark mode styles for event cards */
        body.dark-mode #upcoming-events-section > div[style*="padding: 12px"] {
            background: var(--card-bg) !important;
            border-left-color: var(--primary-color) !important;
        }

        /* Dark mode - joined event cards (blue background becomes darker with primary accent) */
        body.dark-mode #upcoming-events-section > div[style*="rgb(240, 249, 255)"] {
            background: #1a1a2e !important;
            border-left-color: var(--primary-color) !important;
        }

        /* Dark mode - non-joined event cards (yellow background becomes darker neutral) */
        body.dark-mode #upcoming-events-section > div[style*="rgb(255, 248, 225)"] {
            background: var(--card-bg) !important;
            border-left-color: #ff9800 !important;
        }

        /* Dark mode - past event cards */
        body.dark-mode details[style*="background: #f8f9fa"] > div > div[style*="padding: 12px"] {
            background: #1a1a1a !important;
            border-left-color: #4a4a4a !important;
        }

        /* Dark mode - past events section */
        body.dark-mode details[style*="background: #f8f9fa"] {
            background: var(--bg-secondary) !important;
        }

        body.dark-mode details[style*="background: #f8f9fa"] summary {
            color: var(--text-secondary) !important;
        }

        /* Dark mode - event card text colors */
        body.dark-mode #upcoming-events-section div[style*="color: #666"] {
            color: var(--text-secondary) !important;
        }

        body.dark-mode #upcoming-events-section div[style*="font-weight: 600"] {
            color: var(--text-primary) !important;
        }

        /* Dark mode - past event card text colors */
        body.dark-mode details div[style*="color: #666"] {
            color: var(--text-tertiary) !important;
        }

        .event-item div {
            color: var(--text-primary);
        }

        .event-item .event-meta {
            color: var(--text-secondary);
        }

        .circle-tag {
            padding: 4px 10px;
            background: var(--bg-secondary);
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .empty-event-placeholder {
            padding: 15px;
            background: var(--bg-secondary);
            border-radius: 6px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 14px;
            border: 1px dashed var(--border-color);
        }

        /* Events Page Styles */
        .event-period {
            margin-bottom: 25px;
            background: var(--card-bg);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-color);
        }

        .event-period-header {
            padding: 16px 20px;
            cursor: pointer;
            list-style: none;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s ease;
            font-weight: 600;
            font-size: 14px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .event-period-header::-webkit-details-marker {
            display: none;
        }

        .event-period-header:hover {
            background: var(--bg-secondary);
            border-radius: var(--radius-lg);
        }

        .event-period[open] .event-period-header {
            border-bottom: 1px solid var(--border-color);
            border-radius: var(--radius-lg) var(--radius-lg) 0 0;
        }

        .event-period-chevron {
            display: inline-block;
            transition: transform 0.2s ease;
            font-size: 10px;
        }

        .event-period[open] .event-period-chevron {
            transform: rotate(90deg);
        }

        .event-period-content {
            padding: 0;
        }

        .event-card {
            margin: 0;
            padding: 18px 20px;
            background: var(--card-bg);
            border-bottom: 1px solid var(--border-color);
            transition: all 0.2s ease;
        }

        .event-card:last-child {
            border-bottom: none;
            border-radius: 0 0 var(--radius-lg) var(--radius-lg);
        }

        .events-empty-state {
            text-align: center;
            padding: 60px 20px;
        }

        .events-empty-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }

        .events-empty-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 10px;
        }

        .events-empty-message {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 24px;
        }

        .bulk-controls {
            background: var(--bg-secondary);
            padding: 15px;
            border-radius: var(--radius-md);
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }

        .bulk-controls h4 {
            margin-bottom: 10px;
            color: var(--text-primary);
        }

        .bulk-btn {
            display: inline-block;
            padding: 8px 14px;
            margin: 5px 5px 5px 0;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-xl);
            font-size: 0.85em;
            cursor: pointer;
            transition: all var(--transition-speed);
            color: var(--text-primary);
        }

        .bulk-btn:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            transform: translateY(-1px);
        }

        /* Modern Toggle Switch */
        .toggle-container {
            margin-bottom: 20px;
            padding: 16px;
            background: var(--card-bg);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
            transition: all var(--transition-speed);
        }

        .toggle-container:hover {
            border-color: var(--border-hover);
            box-shadow: var(--shadow-sm);
        }

        .toggle-label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            user-select: none;
        }

        .toggle-text {
            flex: 1;
        }

        .toggle-title {
            font-weight: 600;
            font-size: 15px;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .toggle-description {
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .toggle-switch {
            position: relative;
            width: 48px;
            height: 28px;
            flex-shrink: 0;
            margin-left: 16px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--border-color);
            transition: 0.3s;
            border-radius: 28px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .toggle-switch input:checked + .toggle-slider {
            background: linear-gradient(135deg, var(--primary-gradient-start), var(--primary-gradient-end));
        }

        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        .toggle-switch input:focus + .toggle-slider {
            box-shadow: 0 0 0 3px rgba(91, 79, 199, 0.1);
        }

        /* Empty States */
        .empty-state {
            text-align: center;
            padding: 60px 30px;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 4em;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-state-title {
            font-size: 1.2em;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .empty-state-description {
            font-size: 0.95em;
            line-height: 1.5;
            color: var(--text-secondary);
        }

        /* Loading Spinner */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        .btn-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }

        /* Mobile Optimizations */
        @media (max-width: 480px) {
            .btn, .btn-secondary {
                padding: 16px 20px;
                font-size: 16px;
                min-height: 48px; /* Better touch targets */
            }

            .activity-card {
                padding: 24px;
                min-height: 120px;
            }

            .toggle-switch {
                width: 52px;
                height: 32px;
            }

            .toggle-slider:before {
                height: 24px;
                width: 24px;
            }

            .toggle-switch input:checked + .toggle-slider:before {
                transform: translateX(20px);
            }

            .nav-item {
                padding: 8px 0;
            }

            .nav-icon {
                font-size: 1.4em !important;
            }
        }

        /* Smooth scrolling */
        * {
            -webkit-overflow-scrolling: touch;
        }

        /* Prevent text selection on double-tap */
        .activity-card, .circle-card, .nav-item, .btn, .bulk-btn {
            -webkit-tap-highlight-color: rgba(91, 79, 199, 0.1);
            -webkit-touch-callout: none;
            user-select: none;
        }

        /* Allow text selection in inputs and textareas */
        input, textarea, .message-bubble {
            -webkit-touch-callout: default;
            user-select: text;
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .chat-header {
            background: linear-gradient(135deg, var(--primary-gradient-start), var(--primary-gradient-end));
            color: white;
            padding: 15px;
            flex-shrink: 0;
        }

        .chat-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: white;
            color: var(--primary-color);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 10px;
        }
        
        .scheduled-event-banner {
            padding: 10px;
            background-color: #e6f7ff;
            border-bottom: 1px solid #91d5ff;
            text-align: center;
            font-size: 0.9em;
            color: #0050b3;
            flex-shrink: 0;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: var(--bg-secondary);
        }

        .message {
            margin: 15px 0;
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .message-actions {
    position: relative;
}

.message-actions-btn {
    background: none;
    border: none;
    color: #aaa;
    cursor: pointer;
    font-size: 1.2em;
    padding: 5px;
}

.message-actions-menu {
    position: absolute;
    bottom: 25px;
    right: 0;
    background: var(--card-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    display: none;
    width: 100px;
    z-index: 10;
}

.message-actions-menu button {
    display: block;
    width: 100%;
    padding: 10px;
    background: none;
    border: none;
    text-align: left;
    cursor: pointer;
    color: var(--text-primary);
}

.message-actions-menu button:hover {
    background: var(--border-hover);
}

/* Delete button in menu - red color with good contrast */
.message-actions-menu button.delete-btn {
    color: #ef4444;
}

.message-actions-menu button.delete-btn:hover {
    background: rgba(239, 68, 68, 0.1);
}

        .message.own {
            flex-direction: row-reverse;
        }
        
        .message.system {
            justify-content: center;
            font-size: 0.8em;
            color: #888;
            margin: 20px 0;
        }

        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--primary-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            font-weight: bold;
            flex-shrink: 0;
        }

        .message-content {
            max-width: 80%;
        }

        .message-sender {
            font-size: 0.8em;
            color: var(--text-tertiary);
            margin-bottom: 4px;
            padding: 0 12px;
        }

        .message.own .message-content {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .message-bubble {
            background: var(--card-bg);
            padding: 12px 15px;
            border-radius: var(--radius-lg);
            position: relative;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-color);
        }

        .message.own .message-bubble {
            background: linear-gradient(135deg, var(--primary-gradient-start), var(--primary-gradient-end));
            color: white;
            border-color: transparent;
        }

        .message-photo {
            max-width: 200px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .message-photo:hover {
            transform: scale(1.05);
        }

        .message-location {
            background: #e8f4fd;
            border: 1px solid #bee5eb;
            padding: 10px;
            border-radius: 10px;
            cursor: pointer;
        }
        
        .message-actions {
            position: relative;
        }

        .message-actions-btn {
            background: none;
            border: none;
            color: #aaa;
            cursor: pointer;
            font-size: 1.2em;
            padding: 5px;
        }
        
        .message-actions-menu {
            position: absolute;
            bottom: 25px;
            right: 0;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: none;
            width: 100px;
            z-index: 10;
        }

        .message-actions-menu button {
            display: block;
            width: 100%;
            padding: 10px;
            background: none;
            border: none;
            text-align: left;
            cursor: pointer;
            color: var(--text-primary);
        }
        .message-actions-menu button:hover {
            background: var(--border-hover);
        }

        .chat-input {
            background: white;
            padding: 15px;
            border-top: 1px solid #ddd;
            flex-shrink: 0;
        }

        .chat-input textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 20px;
            outline: none;
            min-height: 42px;
            max-height: 150px;
            resize: none;
            overflow-y: auto;
            font-family: inherit;
            font-size: inherit;
            line-height: 1.5;
            margin-bottom: 10px;
            box-sizing: border-box;
        }

        .chat-input-button-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            justify-content: flex-start;
        }
        
        .attachment-btn {
            background: #f8f9fa;
            border: none;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 1.2em;
        }
        
        .attachment-btn:hover {
            background: #e9ecef;
        }

        body.dark-mode .chat-input {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
        }

        body.dark-mode .chat-input textarea {
            background: var(--bg-color);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }

        body.dark-mode .attachment-btn {
            background: var(--bg-color);
        }

        body.dark-mode .attachment-btn:hover {
            background: var(--border-color);
        }

        .attachment-btn.loading {
            position: relative;
            pointer-events: none;
            opacity: 0.6;
        }

        .attachment-btn.loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            animation: attachment-spinner 0.8s linear infinite;
        }

        body.dark-mode .attachment-btn.loading::after {
            border-color: var(--border-color);
            border-top-color: #3498db;
        }

        @keyframes attachment-spinner {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
        }

        .send-btn {
            margin: 0;
        }

        .bottom-nav {
            position: relative;
            width: 100%;
            background: var(--card-bg);
            border-top: 1px solid var(--border-color);
            display: flex;
            justify-content: space-around;
            padding: 15px 0;
            flex-shrink: 0;
            transition: background var(--transition-speed);
        }

        .nav-item {
            text-align: center;
            cursor: pointer;
            transition: all var(--transition-speed);
            flex: 1;
            position: relative;
            color: var(--text-secondary);
        }

        .nav-item:hover {
            transform: translateY(-2px);
        }
        
        .notification-badge {
    position: absolute;
    top: -5px;
    right: calc(50% - 20px);
    min-width: 18px;
    height: 18px;
    background-color: #14b8a6;
    border-radius: 10px;
    border: 2px solid white;
    display: none;
    align-items: center;
    justify-content: center;
    font-size: 11px;
    font-weight: bold;
    color: white;
    padding: 0 4px;
}

.notification-badge.has-count {
    display: flex;
}

        .nav-item.active {
            color: var(--primary-color);
            background: rgba(91, 79, 199, 0.1);
            border-radius: 12px;
            margin: 0 4px;
        }

        .nav-item .nav-icon {
            font-size: 1.2em;
            margin-bottom: 5px;
        }

        .nav-item .nav-label {
            font-size: 0.7em;
            font-weight: 600;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(4px);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-content {
    	background: var(--bg-color);
    	padding: 25px;
    	border-radius: var(--radius-lg);
    	max-width: 90%;
    	width: 350px;
    	max-height: 90vh;
    	overflow-y: auto;
    	box-shadow: var(--shadow-xl);
    	border: 1px solid var(--border-color);
	}

        /* Tutorial Modal Styles */
        .tutorial-modal {
            animation: slideUp 0.3s ease-out;
        }

        .tutorial-header {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border-color);
        }

        .tutorial-header h2 {
            font-size: 1.4em;
            font-weight: 700;
        }

        .tutorial-progress {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            justify-content: center;
        }

        .tutorial-step-indicator {
            height: 4px;
            flex: 1;
            background: var(--border-color);
            border-radius: 2px;
            transition: background-color 0.3s ease;
        }

        .tutorial-step-indicator.active {
            background: var(--primary-color);
        }

        .tutorial-content {
            min-height: 200px;
            margin-bottom: 20px;
        }

        .tutorial-step {
            animation: fadeIn 0.3s ease-in;
        }

        .tutorial-step h3 {
            font-size: 1.2em;
            font-weight: 600;
            color: var(--text-color);
        }

        .tutorial-step p {
            font-size: 1em;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .tutorial-buttons {
            display: flex;
            gap: 10px;
            justify-content: space-between;
            align-items: center;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        /* PWA Install Banner */
        .pwa-install-banner {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, var(--primary-gradient-start) 0%, var(--primary-gradient-end) 100%);
            color: white;
            padding: 16px 20px;
            box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1500;
            transform: translateY(100%);
            transition: transform 0.3s ease-in-out;
            max-width: 400px;
            margin: 0 auto;
        }

        .pwa-install-banner.show {
            transform: translateY(0);
        }

        .pwa-banner-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .pwa-banner-icon {
            font-size: 32px;
            flex-shrink: 0;
        }

        .pwa-banner-text {
            flex: 1;
        }

        .pwa-banner-title {
            font-weight: 600;
            font-size: 15px;
            margin-bottom: 4px;
        }

        .pwa-banner-subtitle {
            font-size: 13px;
            opacity: 0.9;
            line-height: 1.3;
        }

        .pwa-banner-buttons {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .pwa-banner-btn {
            flex: 1;
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pwa-banner-btn-primary {
            background: white;
            color: var(--primary-color);
        }

        .pwa-banner-btn-primary:hover {
            transform: scale(1.02);
            box-shadow: 0 2px 8px rgba(255, 255, 255, 0.3);
        }

        .pwa-banner-btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            backdrop-filter: blur(10px);
        }

        .pwa-banner-btn-secondary:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .pwa-banner-close {
            position: absolute;
            top: 8px;
            right: 8px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            opacity: 0.7;
            padding: 4px;
            line-height: 1;
        }

        .pwa-banner-close:hover {
            opacity: 1;
        }

        /* iOS specific styles */
        .pwa-ios-instructions {
            background: var(--card-bg);
            color: var(--text-primary);
            padding: 20px;
            border-radius: var(--radius-lg);
            margin-top: 12px;
            font-size: 13px;
            line-height: 1.6;
            border: 1px solid var(--border-color);
        }

        .pwa-ios-step {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .pwa-ios-step-number {
            background: var(--primary-color);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 12px;
            flex-shrink: 0;
        }
        
        .modal-image-content {
            background: transparent;
            padding: 0;
            box-shadow: none;
        }

        .modal-image {
            width: 100%;
            height: auto;
            border-radius: 10px;
        }

        .image-actions {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
        }

        .image-action-btn {
            cursor: pointer;
            font-size: 1.3em;
            color: white;
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 8px;
            transition: background 0.2s;
            user-select: none;
        }

        .image-action-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .image-action-btn:active {
            transform: scale(0.95);
        }

        .close-modal {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 2em;
            cursor: pointer;
            z-index: 2001;
        }
        
        .modal-content .close-modal-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.5em;
            color: var(--text-tertiary);
            cursor: pointer;
            transition: color var(--transition-speed);
        }

        .modal-content .close-modal-btn:hover {
            color: var(--text-primary);
        }

        .modal-header {
            font-size: 1.4em;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        /* Collapsible Section Styles */
        .collapsible-section {
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-color);
            transition: all var(--transition-speed) ease;
        }

        .collapsible-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px;
            cursor: pointer;
            background: var(--bg-secondary);
            transition: background var(--transition-speed) ease;
            user-select: none;
        }

        .collapsible-header:hover {
            background: var(--border-color);
        }

        .collapsible-header.active {
            background: var(--primary-color);
            color: white;
        }

        .collapsible-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            font-size: 1em;
        }

        .collapsible-icon {
            transition: transform var(--transition-speed) ease;
            font-size: 0.8em;
        }

        .collapsible-header.active .collapsible-icon {
            transform: rotate(180deg);
        }

        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .collapsible-content.active {
            max-height: 1000px;
        }

        .collapsible-body {
            padding: 15px;
        }

        .undo-container {
    position: fixed;
    bottom: 70px;
    left: 50%;
    transform: translateX(-50%);
    width: calc(100% - 40px);
    max-width: 360px;
    background-color: #333;
    color: white;
    padding: 15px;
    border-radius: 10px;
    display: none;
    justify-content: space-between;
    align-items: center;
    z-index: 1001; /* Higher than the save button */
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

        .undo-btn {
            background: none;
            border: none;
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
        }

.sticky-save {
    position: fixed;
    bottom: 80px;
    left: 50%;
    transform: translateX(-50%);
    width: calc(100% - 40px);
    max-width: 360px;
    z-index: 100;
    box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
}

.sticky-save:hover {
    transform: translateX(-50%) translateY(-2px);
    box-shadow: 0 3px 15px rgba(102, 126, 234, 0.4);
}

#manage-activities-grid {
    max-height: 400px;
    overflow-y: auto;
    margin-bottom: 20px;
}

.message-timestamp {
            color: #999;
            font-size: 0.7em;
            margin-left: 8px;
        }

#manage-activities-grid .activities-grid {
    display: grid !important;
    grid-template-columns: repeat(3, 1fr) !important;
    gap: 10px;
    margin-bottom: 20px;
}

#manage-activities-grid h3 {
    font-size: 1em;
    font-weight: 600;
    color: #555;
    margin: 15px 0 10px 0;
    padding-bottom: 5px;
    border-bottom: 1px solid #f0f0f0;
}

#manage-activities-grid h3:first-child {
    margin-top: 0;
}

#manage-activities-modal-overlay .modal-content {
    max-height: 80vh;
    overflow-y: auto;
}

#manage-activities-grid .activity-card {
    padding: 8px !important;
    font-size: 0.75em !important;
    min-height: 60px !important;
    max-height: 60px !important;
    width: 100% !important;
}

#manage-activities-grid .activity-emoji {
    font-size: 1.1em !important;
    margin-bottom: 4px !important;
}

#manage-activities-grid .activity-name {
    font-size: 0.75em !important;
    line-height: 1.1 !important;
    margin: 0 !important;
}

#manage-activities-modal-overlay #manage-activities-grid {
    display: block !important;
    grid-template-columns: unset !important;
}

.custom-activity-item {
    display: flex;
    gap: 10px;
    align-items: center;
    padding: 12px;
    background: #f8f9fa;
    border-radius: 8px;
    border: 2px solid #e1e5e9;
}

body.dark-mode .custom-activity-item {
    background: var(--card-bg);
    border-color: var(--border-color);
}

/* Dark mode styles for consensus notification feature */
body.dark-mode .consensus-notification-section {
    background: #2a2a2a !important;
    border-color: #444 !important;
}

body.dark-mode .consensus-notification-section p {
    color: #aaa !important;
}

body.dark-mode .consensus-notification-section label {
    color: #ddd !important;
}

body.dark-mode .consensus-notification-badge {
    background: #1a3a4a !important;
    color: #88c0d0 !important;
    border-color: #2e5266 !important;
}

/* Poll Styles */
.poll-container {
    background: #f8f9fa;
}

.poll-sender-name {
    color: #333;
}

.poll-sender-label {
    color: #666;
}

.poll-question {
    color: #222;
}

.poll-vote-count {
    color: #666;
}

.poll-timestamp {
    color: #999;
}

.poll-option-btn {
    background: white;
    color: #333;
    border: 2px solid #ddd;
}

.poll-option-btn.selected {
    background: #007bff;
    color: white;
    border-color: #007bff;
}

.poll-option-btn:not(.selected):hover {
    background: #f0f0f0;
}

.consensus-notification-badge {
    background: #e7f3ff;
    color: #004085;
    border: 1px solid #b8daff;
}

/* Dark mode - Polls */
body.dark-mode .poll-container {
    background: #2d3748;
}

body.dark-mode .poll-sender-name {
    color: #e2e8f0;
}

body.dark-mode .poll-sender-label {
    color: #a0aec0;
}

body.dark-mode .poll-question {
    color: #f7fafc;
}

body.dark-mode .poll-vote-count {
    color: #a0aec0;
}

body.dark-mode .poll-timestamp {
    color: #718096;
}

body.dark-mode .poll-option-btn {
    background: #1a202c;
    color: #e2e8f0;
    border-color: #4a5568;
}

body.dark-mode .poll-option-btn.selected {
    background: #3182ce;
    color: white;
    border-color: #3182ce;
}

body.dark-mode .poll-option-btn:not(.selected):hover {
    background: #2d3748;
}

/* Poll Notification Section in Modal */
.poll-notification-section {
    background: #f8f9fa;
    border: 1px solid #e0e0e0;
}

.poll-notification-description {
    color: #666;
}

.poll-notification-threshold-label {
    color: #555;
}

/* Dark mode - Poll Notification Section in Modal */
body.dark-mode .poll-notification-section {
    background: #2d3748;
    border-color: #4a5568;
}

body.dark-mode .poll-notification-description {
    color: #a0aec0;
}

body.dark-mode .poll-notification-threshold-label {
    color: #cbd5e0;
}

body.dark-mode .poll-notification-label {
    color: #e2e8f0;
}

    </style>
<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
<script>
  const SUPABASE_URL = "https://kxsewkjbhxtfqbytftbu.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt4c2V3a2piaHh0ZnFieXRmdGJ1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg4NTE4ODQsImV4cCI6MjA3NDQyNzg4NH0.-A-7VOQWOaQqYOO6NxiKxGywddfS-pmwvzHISJqz2AQ";

  // Initialize Supabase client with error handling
  // Don't declare - just assign to avoid conflicts with non-configurable globals
  try {
    if (!window.supabase) {
      console.error(' Supabase library not loaded');
      throw new Error('Supabase library not loaded');
    }
    // Assign directly without declaration to avoid redeclaration errors
    supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    if (!supabase) {
      console.error(' Failed to create Supabase client');
      throw new Error('Failed to create Supabase client');
    }
    console.log(' Supabase client initialized successfully');
  } catch (error) {
    console.error(' Error initializing Supabase:', error);
    // Create a minimal fallback to prevent undefined errors
    supabase = {
      auth: {
        getSession: () => Promise.resolve({ data: { session: null }, error: new Error('Supabase not initialized') }),
        onAuthStateChange: () => ({ data: { subscription: { unsubscribe: () => {} } } })
      }
    };
  }

  // Add global Supabase error handler
  if (supabase && supabase.auth) {
    supabase.auth.onAuthStateChange((event, session) => {
    console.log('Auth state changed:', event);

    if (event === 'SIGNED_OUT') {
      console.log('User signed out');
    } else if (event === 'TOKEN_REFRESHED') {
      console.log('Token refreshed');
    } else if (event === 'USER_UPDATED') {
      console.log('User updated');
    } else if (event === 'PASSWORD_RECOVERY') {
      console.log('Password recovery detected - showing reset form');
      // Ensure we show the password reset form regardless of app state
      // Use setTimeout to ensure DOM is ready and avoid race conditions
      setTimeout(() => {
        showPasswordResetModal();
      }, 100);
    }
    });
  }
</script>

<script src="https://cdn.onesignal.com/sdks/web/v16/OneSignalSDK.page.js" defer></script>
<script>
  // Samsung Internet and browser detection utilities
  function isSamsungInternet() {
    const ua = window.navigator.userAgent;
    return ua.indexOf('SamsungBrowser') > -1 || ua.indexOf('SAMSUNG') > -1;
  }

  // Detect if running as WebAPK (installed PWA on Android)
  function isWebAPK() {
    const ua = window.navigator.userAgent;
    // WebAPKs often have specific identifiers in the user agent
    const isStandalone = window.matchMedia('(display-mode: standalone)').matches;
    const isAndroid = /Android/.test(ua);
    const isSamsung = isSamsungInternet();

    // Check if document.referrer contains android-app://
    const hasAndroidReferrer = document.referrer.startsWith('android-app://');

    return isAndroid && (isSamsung || hasAndroidReferrer) && isStandalone;
  }

  function getBrowserInfo() {
    const ua = window.navigator.userAgent;
    let browserName = 'Unknown';
    let browserVersion = 'Unknown';

    if (ua.indexOf('SamsungBrowser') > -1) {
      browserName = 'Samsung Internet';
      const match = ua.match(/SamsungBrowser\/([0-9.]+)/);
      if (match) browserVersion = match[1];
    } else if (ua.indexOf('Chrome') > -1 && ua.indexOf('Edg') === -1) {
      browserName = 'Chrome';
      const match = ua.match(/Chrome\/([0-9.]+)/);
      if (match) browserVersion = match[1];
    } else if (ua.indexOf('Firefox') > -1) {
      browserName = 'Firefox';
      const match = ua.match(/Firefox\/([0-9.]+)/);
      if (match) browserVersion = match[1];
    } else if (ua.indexOf('Safari') > -1 && ua.indexOf('Chrome') === -1) {
      browserName = 'Safari';
      const match = ua.match(/Version\/([0-9.]+)/);
      if (match) browserVersion = match[1];
    } else if (ua.indexOf('Edg') > -1) {
      browserName = 'Edge';
      const match = ua.match(/Edg\/([0-9.]+)/);
      if (match) browserVersion = match[1];
    }

    return { browserName, browserVersion, userAgent: ua };
  }

  // Store browser info globally for debugging
  window.browserInfo = getBrowserInfo();
  window.isWebAPK = isWebAPK();

  // Log browser info for Samsung debugging
  if (isSamsungInternet()) {
    console.log(' SAMSUNG INTERNET DETECTED');
    console.log(' Browser Info:', window.browserInfo);
    console.log(' Display Mode:', window.matchMedia('(display-mode: standalone)').matches ? 'Standalone (PWA)' : 'Browser');
    console.log(' WebAPK Mode:', window.isWebAPK ? 'YES - Running as WebAPK' : 'NO - Running in browser');
    console.log(' Referrer:', document.referrer);
  }

  window.OneSignalDeferred = window.OneSignalDeferred || [];
  OneSignalDeferred.push(async function(OneSignal) {
    try {
      // Enhanced initialization with Samsung-specific logging
      console.log(' Initializing OneSignal...');
      console.log(' Browser:', window.browserInfo.browserName, window.browserInfo.browserVersion);
      console.log(' Platform:', navigator.platform);
      console.log(' Is PWA:', window.matchMedia('(display-mode: standalone)').matches);

      // Configure notification categories for Android (WebAPK)
      const notificationCategories = [
        {
          id: 'friendle_messages',
          name: 'Messages',
          description: 'Chat messages and activity updates'
        },
        {
          id: 'friendle_matches',
          name: 'Matches',
          description: 'New activity matches'
        },
        {
          id: 'friendle_events',
          name: 'Events',
          description: 'Event joins and updates'
        }
      ];

      await OneSignal.init({
        appId: "67c70940-dc92-4d95-9072-503b2f5d84c8",
        allowLocalhostAsSecureOrigin: true,
        serviceWorkerParam: { scope: '/' },
        serviceWorkerPath: '/OneSignalSDKWorker.js',
        // Add additional config for better Samsung compatibility
        notifyButton: {
          enable: false // We handle our own notification prompts
        },
        // Add notification categories for Android WebAPK support
        notificationClickHandlerMatch: 'origin',
        notificationClickHandlerAction: 'focus',
        // For WebAPKs, ensure proper Android notification channels
        android_notification_channel: {
          id: 'friendle_default',
          name: 'Friendle Notifications',
          description: 'All Friendle notifications',
          importance: 4 // IMPORTANCE_HIGH
        }
      });

      // Log WebAPK-specific info
      if (window.isWebAPK) {
        console.log(' WEBAPK: Initialized OneSignal with Android notification channels');
        console.log(' WEBAPK: Categories configured:', notificationCategories.length);
      }
      console.log(' OneSignal initialized successfully');

      // Samsung-specific diagnostics
      if (isSamsungInternet()) {
        console.log(' SAMSUNG: Checking notification permission...');
        const permission = await OneSignal.Notifications.permission;
        console.log(' SAMSUNG: Permission state:', permission);

        const isPushSupported = await OneSignal.Notifications.isPushSupported();
        console.log(' SAMSUNG: Push supported:', isPushSupported);

        const isSubscribed = OneSignal.User.PushSubscription.optedIn;
        console.log(' SAMSUNG: Is subscribed:', isSubscribed);

        const playerId = OneSignal.User.PushSubscription.id;
        console.log(' SAMSUNG: Player ID:', playerId);

        const token = OneSignal.User.PushSubscription.token;
        console.log(' SAMSUNG: Push token:', token ? 'Present' : 'Missing');
      }

      // Save player ID immediately if user is logged in
      try {
        const { data: { session } } = await supabase.auth.getSession();
        const playerId = OneSignal.User.PushSubscription.id;

        if (session?.user?.id && playerId) {
          console.log(' Saving initial OneSignal player ID:', playerId);

          const { error } = await supabase
            .from('profiles')
            .update({ onesignal_player_id: playerId })
            .eq('id', session.user.id);

          if (error) throw error;

          console.log(' Initial OneSignal Player ID saved successfully');
        }
      } catch (error) {
        console.error(' Error saving initial Player ID:', error);
      }
    } catch (error) {
      console.error(' OneSignal initialization error:', error);
    }

    // NOTE: We do NOT add a foregroundWillDisplay listener because:
    // 1. It intercepts notifications but Web SDK v16 has no display() method
    // 2. The service worker handles all notification display automatically
    // 3. Having this listener prevents notifications from showing

    // Handle notification clicks - mostly handled by service worker
    // This fires when app is in foreground
    // Must not be async to avoid blocking OneSignal's internal message passing
    OneSignal.Notifications.addEventListener('click', (event) => {
      console.log(' Page: Notification clicked (foreground handler)', event);
      console.log(' Page: Notification data:', event.notification);
      console.log(' Page: Additional data:', event.notification.additionalData);

      const data = event.notification.additionalData || event.notification.data || {};
      console.log(' Page: Extracted data:', data);

      // Handle navigation asynchronously without blocking the event handler
      // This prevents "message channel closed" errors in OneSignal's internal messaging
      (async () => {
        // When app is in foreground, navigate directly in-app
        if (window.currentUser && data && data.chatType && data.chatId) {
          console.log(' Page: User authenticated, navigating in-app to:', data.chatType, data.chatId);

          try {
            // Wait for app to be ready before navigating (critical for iOS)
            console.log(' Page: Waiting for app to be ready before navigation...');
            await window.waitForAppReady(15000); // 15 second timeout
            console.log(' Page: App is ready, proceeding with navigation');

            // Set previousPage based on chat type so back button leads to the correct page
            let chatPreviousPage = 'matches';
            if (data.chatType === 'match') {
              chatPreviousPage = 'matches';
            } else if (data.chatType === 'event') {
              chatPreviousPage = 'events';
            } else if (data.chatType === 'circle') {
              chatPreviousPage = 'circles';
            }
            localStorage.setItem('friendle_previous_page', chatPreviousPage);
            console.log(' Page: Set previousPage for back button:', chatPreviousPage);

            // Navigate directly to the chat
            if (data.chatType === 'match') {
              // Match chat deprecated - redirect to matches page
              await loadMatches();
              showPage('matches');
            } else if (data.chatType === 'event') {
              await openEventChat(data.chatId);
            } else if (data.chatType === 'circle') {
              await openCircleChat(data.chatId);
            }
            console.log(' Page: Successfully navigated to chat in-app');
          } catch (error) {
            console.error(' Page: Error navigating to chat:', error);
            console.error(' Page: Error stack:', error.stack);
            console.error(' Page: App state at error:', window.appState);
            // Fallback to showing matches page
            showPage('matches');
            showNotification('Unable to open chat. Please try again.', 'error');
          }
        } else {
          console.log(' Page: User not authenticated or no chat data, service worker will handle');
          // Service worker will handle the navigation via URL parameters
        }
      })();
    });
    
    // Save Player ID to database when user is logged in
    OneSignal.User.PushSubscription.addEventListener('change', async function(event) {
      const playerId = event.current.id;

      if (!playerId) {
        console.log(' No player ID in subscription change event');
        if (isSamsungInternet()) {
          console.log(' SAMSUNG: Subscription change event fired but no player ID');
          console.log(' SAMSUNG: Event details:', JSON.stringify(event, null, 2));
        }
        return;
      }

      console.log(' OneSignal subscription changed, player ID:', playerId);

      // Samsung-specific subscription diagnostics
      if (isSamsungInternet()) {
        console.log(' SAMSUNG: Subscription change event details:');
        console.log(' SAMSUNG: - Player ID:', playerId);
        console.log(' SAMSUNG: - Token:', event.current.token ? 'Present' : 'Missing');
        console.log(' SAMSUNG: - Opted In:', event.current.optedIn);
        console.log(' SAMSUNG: - Full event:', JSON.stringify(event.current, null, 2));
      }

      try {
        // Get current session from Supabase
        const { data: { session } } = await supabase.auth.getSession();

        if (!session?.user?.id) {
          console.log(' No active session, cannot save player ID');
          return;
        }

        console.log(' Saving OneSignal player ID to database for user:', session.user.id);

        // Update database with player ID
        const { error } = await supabase
          .from('profiles')
          .update({ onesignal_player_id: playerId })
          .eq('id', session.user.id);

        if (error) throw error;

        console.log(' OneSignal Player ID saved successfully:', playerId);

        // Update in-memory user object if it exists
        if (window.currentUser) {
          window.currentUser.onesignal_player_id = playerId;
        }
      } catch (error) {
        console.error(' Error saving Player ID:', error);
      }
    });
  });
</script>
</head>
<body>
    <div class="app-container">
        <div id="pages-container" style="flex: 1; overflow-y: auto; position: relative;">
<div id="onboarding" class="page active">
    <div class="header">
        <div class="logo"> Friendle</div>
        <div class="tagline" id="onboarding-tagline">Who's in?</div>
    </div>
    
    <div id="onboarding-content" style="padding: 20px;">
        <!-- Invite context (shown when invite_code exists) -->
        <div id="invite-context" style="display: none; text-align: center; margin-bottom: 30px;">
            <div style="font-size: 1.2em; font-weight: 600; margin-bottom: 10px;">
                You've been invited to join
            </div>
            <div id="invite-circle-name" style="font-size: 1.5em; font-weight: bold; color: #667eea; margin-bottom: 20px;">
                Loading...
            </div>
        </div>
        
        <!-- Generic pitch (shown when no invite_code) -->
        <div id="generic-pitch" style="margin-bottom: 30px;">
            <div style="font-size: 1.1em; line-height: 1.6; color: #555;">
                <p style="margin-bottom: 15px;">Stop coordinating plans through endless group chat messages.</p>
                <p style="margin-bottom: 15px;">With Friendle:</p>
                <ul style="list-style: none; padding-left: 0;">
    <li style="margin-bottom: 10px;"> Share what activities you're interested in</li>
    <li style="margin-bottom: 10px;"> See who else wants to do the same things and make it happen</li>
</ul>
            </div>
        </div>
        
        <button class="btn" id="onboarding-cta" onclick="showWelcomeFromOnboarding()">Get Started</button>
        <div style="text-align: center; margin-top: 15px; color: #666; font-size: 0.9em;">
            Already have an account? <a href="#" onclick="showWelcomeFromOnboarding(); return false;" style="color: #667eea; text-decoration: underline;">Sign in</a>
        </div>
    </div>
</div>
            <div id="welcome" class="page">
    <div class="header"><div class="logo"> Friendle</div><div class="tagline">What do you feel like doing?</div></div>
    
    <form id="login-form" onsubmit="event.preventDefault(); signIn();">
        <div class="form-group"><label for="login-email">Email</label><input type="email" id="login-email" placeholder="Enter your email" autocomplete="email" inputmode="email"></div>
        <div class="form-group"><label for="login-password">Password</label><input type="password" id="login-password" placeholder="Enter your password" autocomplete="current-password"></div>
        <button type="submit" class="btn">Sign In</button>
        <button type="button" class="btn btn-secondary" onclick="showRegister()">Create Account</button>
        <div style="text-align: center; margin-top: 15px;">
            <a href="#" onclick="showForgotPassword(); return false;" style="color: #667eea; text-decoration: underline; font-size: 0.9em;">Forgot password?</a>
        </div>
    </form>
    
    <form id="register-form" style="display: none;" onsubmit="event.preventDefault(); signUp();">
        <div class="form-group"><label for="register-email">Email</label><input type="email" id="register-email" placeholder="Enter your email" autocomplete="email" inputmode="email"></div>
        <div class="form-group"><label for="register-name">Your Name</label><input type="text" id="register-name" placeholder="Enter your name" autocomplete="given-name"></div>
        <div class="form-group"><label for="register-password">Password</label><input type="password" id="register-password" placeholder="Create a password (6+ characters)" autocomplete="new-password"></div>
        <div class="form-group">
            <label>Profile Picture</label>
            <div style="text-align: center; margin: 20px 0;">
                <div style="position: relative; width: 100px; height: 100px; margin: 0 auto 15px;">
                    <div id="register-profile-preview" style="width: 100%; height: 100%; border-radius: 50%; border: 3px solid var(--border-color); display: flex; align-items: center; justify-content: center; font-size: 50px; background: var(--card-bg); overflow: hidden; cursor: pointer;" onclick="showRegisterPhotoMenu(event)">
                        <span id="register-avatar-display"></span>
                    </div>
                    <div style="position: absolute; bottom: 0; right: 0; width: 32px; height: 32px; border-radius: 50%; background: var(--primary-color); display: flex; align-items: center; justify-content: center; cursor: pointer; border: 2px solid var(--card-bg);" onclick="showRegisterPhotoMenu(event)" title="Change photo"></div>
                </div>
                <input type="file" id="register-photo-input" accept="image/*" style="display: none;" onchange="handleRegisterPhotoUpload(event)">
            </div>
            <div style="text-align: center; margin-bottom: 10px; color: var(--text-secondary); font-size: 0.9em;">or choose an emoji avatar:</div>
            <div class="avatar-grid">
                <div class="avatar-option" data-avatar=""></div><div class="avatar-option" data-avatar=""></div><div class="avatar-option" data-avatar=""></div><div class="avatar-option" data-avatar=""></div>
                <div class="avatar-option" data-avatar=""></div><div class="avatar-option" data-avatar=""></div><div class="avatar-option" data-avatar=""></div><div class="avatar-option" data-avatar=""></div>
            </div>
        </div>
        <button type="submit" class="btn">Create Account</button>
        <div style="text-align: center; margin-top: 20px; margin-bottom: -10px; color: #666; font-size: 0.9em;">
    Already have an account?
</div>
<button type="button" class="btn btn-secondary" onclick="showLogin()">Sign In</button>
    </form>
    
    <form id="forgot-password-form" style="display: none;" onsubmit="event.preventDefault(); sendPasswordReset();">
        <div class="form-group"><label for="reset-email">Email</label><input type="email" id="reset-email" placeholder="Enter your email" autocomplete="email" inputmode="email"></div>
        <button type="submit" class="btn">Send Reset Link</button>
        <button type="button" class="btn btn-secondary" onclick="showLogin()">Back to Sign In</button>
    </form>

    <form id="password-reset-form" style="display: none;" onsubmit="event.preventDefault(); submitPasswordReset();">
        <h2 style="text-align: center; margin-bottom: 20px;"> Reset Your Password</h2>
        <p style="text-align: center; color: #666; margin-bottom: 20px;">Welcome! Your password reset link worked. Enter your new password below to complete the process.</p>
        <div class="form-group"><label for="new-reset-password">New Password</label><input type="password" id="new-reset-password" placeholder="Enter new password (6+ characters)" autocomplete="new-password"></div>
        <div class="form-group"><label for="confirm-reset-password">Confirm Password</label><input type="password" id="confirm-reset-password" placeholder="Confirm new password" autocomplete="new-password"></div>
        <button type="submit" class="btn">Reset Password</button>
    </form>
</div>
            <div id="circles" class="page">
    <div class="header">
        <div class="logo"> Circles</div>
        <div class="tagline">Who do you want to hang with?</div>
    </div>
    <div id="circles-list"></div>
    <div id="no-circles-message" style="display: none; text-align: center; padding: 40px 20px; color: #666;">
        <div style="font-size: 3em; margin-bottom: 20px;"></div>
        <h3 style="margin-bottom: 15px; color: #333;">No Circles Yet</h3>
        <p style="margin-bottom: 25px; line-height: 1.6;">
            Circles are your friend groups. Create one to start coordinating activities, or join an existing circle with an invite code.
        </p>
    </div>
    <button class="btn" onclick="showCreateCircle()">Create New Circle</button>
    <button class="btn btn-secondary" onclick="showJoinCircle()">Join Circle</button>
</div>
            <div id="activities" class="page">
    <div class="header">
        <div class="logo"> Friendle</div>
        <div class="tagline">Plan events with your circles</div>
    </div>

    <!-- Circle Selector -->
    <div class="form-group">
        <label for="circle-selector">Select Circle</label>
        <select id="circle-selector" onchange="handleCircleChange()" style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid #ddd; font-size: 14px;">
            <option value="">Choose a circle...</option>
        </select>
    </div>

    <!-- Upcoming Events Section -->
    <div id="home-events-section" style="display: none; margin-bottom: 30px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
            <h3 style="margin: 0; font-size: 18px; font-weight: 600;"> Upcoming Events</h3>
            <button class="btn btn-secondary btn-small" onclick="showPage('events')" style="font-size: 12px; padding: 6px 12px;">View All</button>
        </div>
        <div id="home-events-list"></div>
    </div>

    <!-- Activity Browser Section -->
    <div style="margin-bottom: 15px;">
        <h3 style="margin: 0 0 12px 0; font-size: 18px; font-weight: 600;"> Browse Activities</h3>
        <p style="margin: 0 0 15px 0; color: #666; font-size: 14px;">Tap activities to plan events. Select your interests in Settings to customize notifications.</p>
    </div>

    <!-- Activity Grid (now default view) -->
    <div id="activity-grid-container">
        <div id="frequent-section" style="display: none;">
            <div class="section-title"> Frequently Used</div>
            <div class="frequent-grid" id="frequent-grid"></div>
        </div>
        <div class="activities-grid" id="activities-grid"></div>
    </div>

    <!-- Action Buttons -->
    <div style="display: flex; gap: 10px; margin-top: 20px; margin-bottom: 20px;">
        <button class="btn btn-secondary btn-small" onclick="openSuggestModal()" style="flex: 1;"> Suggest New Activity</button>
        <button class="btn btn-secondary btn-small" onclick="openManageActivitiesModal()" style="flex: 1;"> Manage Activities</button>
    </div>

            </div>
            <div id="matches" class="page">
    <div class="header">
        <div class="logo"> Matches</div>
        <div class="tagline">Who else wants to do what you want to do?</div>
    </div>
    <div id="matches-list"></div>
</div>
            <div id="events" class="page">
    <div class="header">
        <div class="logo"> Events</div>
        <div class="tagline">All upcoming events from your circles</div>
    </div>
    <div id="events-list"></div>
</div>
            <div id="chat" class="page">
    <div class="chat-container">
        <div class="chat-header">
    <div style="display: flex; align-items: center; margin-bottom: 8px;">
        <button onclick="goToPreviousPage()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 0.85em;"> Back</button>
        <div style="flex: 1; text-align: center;">
            <div id="event-activity-name" style="font-weight: 600; font-size: 1.1em;"></div>
            <div id="event-participants" style="font-size: 0.8em; opacity: 0.8;"></div>
        </div>
    </div>
    <div style="display: flex; gap: 8px; justify-content: flex-end;">
        <button id="lock-details-btn" onclick="openLockDetailsModal()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 0.85em; display: none;"> Lock in Details</button>
        <button id="add-to-calendar-btn" onclick="addToCalendarFromHeader()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 0.85em; display: none;"> Add to Calendar</button>
        <button id="leave-event-btn" onclick="leaveEvent()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 0.85em; display: none;">Leave event</button>
        <button id="mute-chat-btn" onclick="toggleMuteChat()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 0.85em; display: none;">
            <span id="mute-btn-text"> Mute</span>
        </button>
        <button id="create-event-header-btn" onclick="openCreateEventModalFromHeader()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 0.85em; display: none;"> Create Event</button>
        <button id="event-options-btn" onclick="openEventOptionsModal()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 0.85em; display: none;"></button>
    </div>
</div>
        
        <div id="event-details" style="background: #e6f7ff; padding: 12px 15px; border-bottom: 1px solid #91d5ff; flex-shrink: 0;">
            <div id="event-date" style="font-weight: 500; margin-bottom: 4px; color: #0050b3;"></div>
            <div id="event-location" style="color: #0050b3; font-size: 14px;"></div>
            <div id="event-notes" style="color: #0050b3; font-size: 14px; margin-top: 4px;"></div>
        </div>
        
        <div class="chat-messages" id="chat-messages"></div>
        
        <div class="chat-input">
            <textarea id="message-input" placeholder="Type a message..." onkeydown="handleMessageKeyPress(event)" rows="1"></textarea>
            <div class="chat-input-button-row">
                <button class="attachment-btn" id="poll-btn" onclick="openCreatePollModal()" title="Create a poll"></button>
                <button class="attachment-btn" id="photo-btn" onclick="sharePhoto()"></button>
                <button class="attachment-btn" id="location-btn" onclick="shareLocation()"></button>
                <button class="attachment-btn" id="search-btn" onclick="findNearbyPlaces()"></button>
            </div>
            <button class="btn send-btn" onclick="sendMessage()">Send</button>
        </div>
    </div>
</div>
            <div id="settings" class="page">
            <div class="header"><div class="logo"> Settings</div><div class="tagline">Manage your preferences</div></div>
    <div style="text-align: center; margin: 40px 0;">
        <div class="profile-picture-container" onclick="showSettingsPhotoMenu(event)">
            <div class="profile-picture">
                <div id="profile-avatar" class="avatar-display emoji"></div>
            </div>
            <div class="profile-picture-overlay" title="Change profile picture"></div>
        </div>
        <input type="file" id="profile-picture-input" accept="image/*" style="display: none;" onchange="uploadProfilePicture(event)">
        <h2 id="profile-name" style="color: var(--text-primary);">Your Name</h2>
    </div>

    <button class="btn btn-secondary" onclick="openUpdateNameModal()">Update Name</button>

    <!-- Activity Interests Section (Collapsible) -->
    <div style="margin: 30px 0 20px 0; background: var(--card-bg); border-radius: 8px; border: 1px solid var(--border-color); overflow: hidden;">
        <div onclick="toggleActivityInterests()" style="padding: 20px; cursor: pointer; user-select: none; display: flex; justify-content: space-between; align-items: center;">
            <h3 style="margin: 0; font-size: 1.1em; color: var(--text-primary);"> Activity Interests</h3>
            <span id="activity-interests-arrow" style="font-size: 1.2em; color: var(--text-secondary); transition: transform 0.3s ease;"></span>
        </div>

        <div id="activity-interests-content" style="max-height: 0; overflow: hidden; transition: max-height 0.3s ease;">
            <div style="padding: 0 20px 20px 20px;">
                <p style="margin: 0 0 15px 0; font-size: 0.85em; color: var(--text-secondary); line-height: 1.4;">
                    Select activities you're interested in to customize which event notifications you receive. When someone creates an event for an activity you've selected, you'll be notified.
                </p>

                <!-- Circle Selector for Activity Interests -->
                <div class="form-group">
                    <label for="interests-circle-selector">Select Circle</label>
                    <select id="interests-circle-selector" onchange="loadActivityInterests()" style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-primary);">
                        <option value="">Choose a circle...</option>
                    </select>
                </div>

                <!-- Activity Interests Grid -->
                <div id="activity-interests-grid-container" style="display: none;">
                    <div class="activities-grid" id="activity-interests-grid" style="margin-bottom: 15px;"></div>

                    <!-- Action Buttons -->
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <button class="btn btn-secondary btn-small" onclick="openSuggestModal()" style="flex: 1; font-size: 0.85em;"> Suggest Activity</button>
                        <button class="btn btn-secondary btn-small" onclick="openManageActivitiesModal()" style="flex: 1; font-size: 0.85em;"> Manage Activities</button>
                    </div>

                    <button id="save-interests-btn" class="btn" onclick="saveActivityInterests()" style="width: 100%; display: none;">Save Interests</button>
                </div>

                <div id="select-circle-prompt" style="text-align: center; padding: 20px; color: var(--text-secondary); font-size: 0.9em;">
                    Select a circle above to manage your activity interests
                </div>
            </div>
        </div>
    </div>

    <div class="toggle-container">
        <label class="toggle-label" for="dark-mode-toggle">
            <div class="toggle-text">
                <div class="toggle-title"> Dark Mode</div>
                <div class="toggle-description">Switch between light and dark theme</div>
            </div>
            <div class="toggle-switch">
                <input type="checkbox" id="dark-mode-toggle" onchange="toggleDarkMode()">
                <span class="toggle-slider"></span>
            </div>
        </label>
    </div>

    <!-- Notification Settings Section (Collapsible) -->
    <div style="margin: 30px 0 20px 0; background: var(--card-bg); border-radius: 8px; border: 1px solid var(--border-color); overflow: hidden;">
        <div onclick="toggleNotificationSettings()" style="padding: 20px; cursor: pointer; user-select: none; display: flex; justify-content: space-between; align-items: center;">
            <h3 style="margin: 0; font-size: 1.1em; color: var(--text-primary);"> Notification Settings</h3>
            <span id="notification-settings-arrow" style="font-size: 1.2em; color: var(--text-secondary); transition: transform 0.3s ease;"></span>
        </div>

        <div id="notification-settings-content" style="max-height: 0; overflow: hidden; transition: max-height 0.3s ease;">
            <div style="padding: 0 20px 20px 20px;">
                <div class="toggle-container">
                    <label class="toggle-label" for="event-reminders-toggle">
                        <div class="toggle-text">
                            <div class="toggle-title">Event Reminders</div>
                            <div class="toggle-description">Get notified at 9 AM on the day of your events</div>
                        </div>
                        <div class="toggle-switch">
                            <input type="checkbox" id="event-reminders-toggle" onchange="toggleEventReminders()">
                            <span class="toggle-slider"></span>
                        </div>
                    </label>
                </div>

                <div style="margin: 15px 0 20px 0;">
                    <label for="timezone-select" style="display: block; font-size: 0.9em; color: var(--text-secondary); margin-bottom: 8px;">Your Timezone</label>
                    <select id="timezone-select" onchange="updateTimezone()" style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-primary); font-size: 1em;">
                        <option value="America/New_York">Eastern Time (ET)</option>
                        <option value="America/Chicago">Central Time (CT)</option>
                        <option value="America/Denver">Mountain Time (MT)</option>
                        <option value="America/Los_Angeles">Pacific Time (PT)</option>
                        <option value="America/Anchorage">Alaska Time (AKT)</option>
                        <option value="Pacific/Honolulu">Hawaii Time (HT)</option>
                        <option value="Europe/London">London (GMT/BST)</option>
                        <option value="Europe/Paris">Central European (CET)</option>
                        <option value="Europe/Athens">Eastern European (EET)</option>
                        <option value="Asia/Dubai">Dubai (GST)</option>
                        <option value="Asia/Kolkata">India (IST)</option>
                        <option value="Asia/Shanghai">China (CST)</option>
                        <option value="Asia/Tokyo">Japan (JST)</option>
                        <option value="Australia/Sydney">Sydney (AEDT)</option>
                        <option value="Pacific/Auckland">New Zealand (NZDT)</option>
                    </select>
                    <button onclick="detectAndUpdateTimezone()" style="width: 100%; margin-top: 8px; padding: 8px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--input-bg); color: var(--text-primary); font-size: 0.9em; cursor: pointer;">
                         Detect Automatically
                    </button>
                    <div style="font-size: 0.8em; color: var(--text-secondary); margin-top: 4px;">Reminders will be sent at 9 AM in your timezone</div>
                </div>

                <h4 style="margin: 20px 0 10px 0; font-size: 0.95em; color: var(--text-primary);">Push Notifications</h4>
                <p style="margin: 0 0 15px 0; font-size: 0.85em; color: var(--text-secondary);">Control which push notifications you receive</p>

                <div class="toggle-container">
                    <label class="toggle-label" for="new-match-toggle">
                        <div class="toggle-text">
                            <div class="toggle-title">New Matches</div>
                            <div class="toggle-description">Get notified when someone joins your activity</div>
                        </div>
                        <div class="toggle-switch">
                            <input type="checkbox" id="new-match-toggle" onchange="toggleNewMatches()">
                            <span class="toggle-slider"></span>
                        </div>
                    </label>
                </div>

                <div class="toggle-container">
                    <label class="toggle-label" for="event-join-toggle">
                        <div class="toggle-text">
                            <div class="toggle-title">Event Joins</div>
                            <div class="toggle-description">Get notified when someone joins your event</div>
                        </div>
                        <div class="toggle-switch">
                            <input type="checkbox" id="event-join-toggle" onchange="toggleEventJoins()">
                            <span class="toggle-slider"></span>
                        </div>
                    </label>
                </div>

                <div class="toggle-container">
                    <label class="toggle-label" for="chat-messages-toggle">
                        <div class="toggle-text">
                            <div class="toggle-title">Chat Messages</div>
                            <div class="toggle-description">Get notified about new chat messages</div>
                        </div>
                        <div class="toggle-switch">
                            <input type="checkbox" id="chat-messages-toggle" onchange="toggleChatMessages()">
                            <span class="toggle-slider"></span>
                        </div>
                    </label>
                </div>

                <div class="toggle-container">
                    <label class="toggle-label" for="inactivity-warnings-toggle">
                        <div class="toggle-text">
                            <div class="toggle-title">Inactivity Warnings</div>
                            <div class="toggle-description">Get notified before you're marked inactive</div>
                        </div>
                        <div class="toggle-switch">
                            <input type="checkbox" id="inactivity-warnings-toggle" onchange="toggleInactivityWarnings()">
                            <span class="toggle-slider"></span>
                        </div>
                    </label>
                </div>

                <h4 style="margin: 20px 0 10px 0; font-size: 0.95em; color: var(--text-primary);"> Activity Momentum Alerts</h4>
                <p style="margin: 0 0 15px 0; font-size: 0.85em; color: var(--text-secondary);">Get notified when activities you're interested in reach key thresholds to help coordination happen</p>

                <div class="toggle-container">
                    <label class="toggle-label" for="notify-at-4-toggle">
                        <div class="toggle-text">
                            <div class="toggle-title">Notify at 4 interested</div>
                            <div class="toggle-description">When a group becomes viable</div>
                        </div>
                        <div class="toggle-switch">
                            <input type="checkbox" id="notify-at-4-toggle" onchange="toggleNotifyAt4()">
                            <span class="toggle-slider"></span>
                        </div>
                    </label>
                </div>

                <div class="toggle-container">
                    <label class="toggle-label" for="notify-at-8-toggle">
                        <div class="toggle-text">
                            <div class="toggle-title">Notify at 8 interested</div>
                            <div class="toggle-description">When momentum is strong</div>
                        </div>
                        <div class="toggle-switch">
                            <input type="checkbox" id="notify-at-8-toggle" onchange="toggleNotifyAt8()">
                            <span class="toggle-slider"></span>
                        </div>
                    </label>
                </div>

                <div style="margin: 10px 0 0 0; padding: 10px; background: var(--card-bg); border-radius: 6px; border: 1px solid var(--border-color);">
                    <p style="margin: 0; font-size: 0.8em; color: var(--text-secondary); line-height: 1.4;">
                         These help coordinate spontaneous group activities by notifying you when interest reaches critical thresholds
                    </p>
                </div>

                <!-- Samsung Internet Notification Troubleshooting -->
                <div id="samsung-notification-help" style="display: none; margin: 20px 0 0 0; padding: 15px; background: #fff3cd; border-radius: 8px; border-left: 3px solid #ffc107;">
                    <h3 style="margin: 0 0 10px 0; font-size: 1em; color: #856404;"> Samsung Device Notification Help</h3>

                    <div style="margin-bottom: 15px; padding: 10px; background: #ffe5e5; border-radius: 4px; border: 1px solid #ff4444;">
                        <strong style="color: #cc0000;"> IMPORTANT - WebAPK Issue:</strong>
                        <p style="margin: 5px 0 0 0; font-size: 0.85em; color: #cc0000;">
                            If your app info says "Downloaded from Google Play Store" but it's NOT actually in the Play Store, Samsung has installed this as a WebAPK which <strong>blocks web push notifications</strong>.
                        </p>
                        <p style="margin: 5px 0 0 0; font-size: 0.85em; color: #cc0000;">
                            <strong>FIX:</strong> Uninstall the app, then use Friendle directly from Samsung Internet browser (don't install to home screen), OR install it using Chrome browser instead.
                        </p>
                    </div>

                    <p style="margin: 0 0 10px 0; font-size: 0.85em; color: #856404; line-height: 1.4;">
                        Run the diagnostic test below first. If not using WebAPK, try these steps:
                    </p>
                    <ol style="margin: 0; padding-left: 20px; font-size: 0.85em; color: #856404; line-height: 1.6;">
                        <li><strong>Check Sleeping Apps:</strong> Settings  Battery  Background usage limits  Sleeping apps. Friendle should NOT be in this list.</li>
                        <li><strong>Allow Background Activity:</strong> Settings  Apps  Friendle  Battery  Allow background activity.</li>
                        <li><strong>Check Notification Settings:</strong> Settings  Apps  Friendle  Notifications. Ensure all categories are enabled.</li>
                        <li><strong>Disable Battery Optimization:</strong> Settings  Apps  Friendle  Battery  Optimize battery usage  Turn OFF.</li>
                    </ol>
                    <button class="btn btn-secondary" onclick="testSamsungNotifications()" style="width: 100%; margin-top: 10px;">
                         Run Diagnostic Test
                    </button>
                    <div id="samsung-diagnostic-results" style="margin-top: 10px; padding: 10px; background: white; border-radius: 4px; font-family: monospace; font-size: 0.75em; display: none;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Help & Tutorials Section (Collapsible) -->
    <div style="margin: 30px 0 20px 0; background: var(--card-bg); border-radius: 8px; border: 1px solid var(--border-color); overflow: hidden;">
        <div onclick="toggleHelpTutorials()" style="padding: 20px; cursor: pointer; user-select: none; display: flex; justify-content: space-between; align-items: center;">
            <h3 style="margin: 0; font-size: 1.1em; color: var(--text-primary);"> Help & Tutorials</h3>
            <span id="help-tutorials-arrow" style="font-size: 1.2em; color: var(--text-secondary); transition: transform 0.3s ease;"></span>
        </div>

        <div id="help-tutorials-content" style="max-height: 0; overflow: hidden; transition: max-height 0.3s ease;">
            <div style="padding: 0 20px 20px 20px;">
                <p style="margin: 0 0 15px 0; font-size: 0.85em; color: var(--text-secondary); line-height: 1.4;">
                    View the tutorial guides again to learn how to use Friendle.
                </p>

                <button class="btn btn-secondary" onclick="showTutorial('activities', true)" style="width: 100%; margin-bottom: 10px;">
                     Activities Tutorial
                </button>

                <button class="btn btn-secondary" onclick="showTutorial('circles', true)" style="width: 100%; margin-bottom: 10px;">
                     Circles Tutorial
                </button>

                <button class="btn btn-secondary" onclick="showTutorial('matches', true)" style="width: 100%;">
                     Matches Tutorial
                </button>
            </div>
        </div>
    </div>

    <!-- Blocked Users Section (Collapsible) -->
    <div style="margin: 30px 0 20px 0; background: var(--card-bg); border-radius: 8px; border: 1px solid var(--border-color); overflow: hidden;">
        <div onclick="toggleBlockedUsers()" style="padding: 20px; cursor: pointer; user-select: none; display: flex; justify-content: space-between; align-items: center;">
            <h3 style="margin: 0; font-size: 1.1em; color: var(--text-primary);"> Blocked Users</h3>
            <span id="blocked-users-arrow" style="font-size: 1.2em; color: var(--text-secondary); transition: transform 0.3s ease;"></span>
        </div>

        <div id="blocked-users-content" style="max-height: 0; overflow: hidden; transition: max-height 0.3s ease;">
            <div style="padding: 0 20px 20px 20px;">
                <p style="margin: 0 0 15px 0; font-size: 0.85em; color: var(--text-secondary); line-height: 1.4;">
                    Blocked users cannot see your profile, send you messages, or interact with you in circles and matches.
                </p>

                <div id="blocked-users-list" style="margin-bottom: 15px;">
                    <!-- Blocked users will be populated here -->
                    <div id="no-blocked-users" style="text-align: center; padding: 20px; font-size: 0.85em; color: var(--text-tertiary);">
                        No blocked users
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Advanced Settings Section (Collapsible) -->
    <div style="margin: 30px 0 20px 0; background: var(--card-bg); border-radius: 8px; border: 1px solid var(--border-color); overflow: hidden;">
        <div onclick="toggleAdvancedSettings()" style="padding: 20px; cursor: pointer; user-select: none; display: flex; justify-content: space-between; align-items: center;">
            <h3 style="margin: 0; font-size: 1.1em; color: var(--text-primary);"> Advanced Settings</h3>
            <span id="advanced-settings-arrow" style="font-size: 1.2em; color: var(--text-secondary); transition: transform 0.3s ease;"></span>
        </div>

        <div id="advanced-settings-content" style="max-height: 0; overflow: hidden; transition: max-height 0.3s ease;">
            <div style="padding: 0 20px 20px 20px;">
                <div style="margin-bottom: 20px; padding: 15px; background: var(--bg-primary); border-radius: 6px; border-left: 3px solid #0066cc;">
                    <h4 style="margin: 0 0 8px 0; font-size: 0.95em; color: var(--text-primary);"> Export My Data</h4>
                    <p style="margin: 0 0 12px 0; font-size: 0.85em; color: var(--text-secondary); line-height: 1.4;">
                        Download all your personal data including circles, activities, matches, and preferences as a JSON file. Required for GDPR compliance.
                    </p>
                    <button class="btn btn-secondary" onclick="exportData()" style="width: 100%;">Export My Data</button>
                </div>

                <div style="margin-bottom: 0; padding: 15px; background: var(--bg-primary); border-radius: 6px; border-left: 3px solid #dc3545;">
                    <h4 style="margin: 0 0 8px 0; font-size: 0.95em; color: #dc3545;"> Delete All My Data</h4>
                    <p style="margin: 0 0 12px 0; font-size: 0.85em; color: var(--text-secondary); line-height: 1.4;">
                        Permanently delete all your data including circles, activities, matches, preferences, and profile. This action cannot be undone. Consider exporting your data first.
                    </p>
                    <button class="btn btn-secondary" onclick="resetApp()" style="width: 100%; background: #dc3545; color: white; font-weight: 600;">Delete All My Data</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Provide Feedback Section -->
    <div style="margin: 20px 0; padding: 15px; background: var(--card-bg); border-radius: 8px; border-left: 3px solid #28a745;">
        <h3 style="margin: 0 0 10px 0; font-size: 1em; color: var(--text-primary);"> Share Your Feedback</h3>
        <p style="margin: 0 0 15px 0; font-size: 0.85em; color: var(--text-secondary); line-height: 1.4;">
            Help us improve Friendle! Share your thoughts, suggestions, or report issues.
        </p>
        <a href="https://docs.google.com/forms/d/e/1FAIpQLSdGqNR1X-Xe0jHEIbrpABegJBgrAid-xYUkUSGHMW4JbIsxcg/viewform?usp=header" target="_blank" rel="noopener noreferrer" style="text-decoration: none;">
            <button class="btn btn-secondary" style="width: 100%;">Share Your Feedback</button>
        </a>
    </div>

    <button class="btn btn-secondary" onclick="signOut()">Sign Out</button>
</div>
        </div>

        <div class="bottom-nav">
            <div class="nav-item" onclick="showPage('circles')"><div class="nav-icon"></div><div class="nav-label">Circles</div></div>
            <div class="nav-item" onclick="showPage('activities')"><div class="nav-icon"></div><div class="nav-label">Activities</div></div>
            <div class="nav-item active" onclick="showPage('events')"><div class="nav-icon"></div><div class="nav-label">Events</div></div>
            <div class="nav-item" onclick="showPage('settings')"><div class="nav-icon"></div><div class="nav-label">Settings</div></div>
        </div>
        
        <div class="modal-overlay" id="image-modal-overlay"><div class="close-modal" onclick="closeImageModal()"></div><div class="modal-content modal-image-content"><img class="modal-image" id="modal-image" src="" alt=""><div class="image-actions"><span class="image-action-btn" onclick="downloadImage()" title="Download image"> Download</span><span class="image-action-btn" onclick="shareImage()" title="Share image"> Share</span></div></div></div>
        <div class="modal-overlay" id="circle-modal-overlay"><div class="modal-content"><span class="close-modal-btn" onclick="closeCircleModal()"></span><div id="create-circle" style="display: none;">
    <!-- Step 1: Name -->
    <div id="circle-step-1">
        <div class="modal-header">Create New Circle</div>
        <div class="form-group">
            <label for="circle-name">Circle Name</label>
            <input type="text" id="circle-name" placeholder="e.g., College Friends">
        </div>
        <button class="btn" onclick="goToCircleStep2()">Next</button>
        <button class="btn btn-secondary" onclick="closeCircleModal()">Cancel</button>
    </div>
    
    <!-- Step 2: Activities -->
    <div id="circle-step-2" style="display: none;">
        <div class="modal-header">What activities interest this group?</div>

        <!-- Activity grid -->
        <div class="activities-grid" id="circle-creation-activities-grid" style="max-height: 300px; overflow-y: auto; margin-bottom: 15px;"></div>
        
        <div style="text-align: center; margin: 15px 0;">
            <button class="btn btn-secondary btn-small" onclick="openSuggestModal()">
                 Suggest a different activity
            </button>
        </div>
        
        <div style="text-align: center; color: #666; font-size: 0.9em; margin-bottom: 15px;">
            <span id="circle-selected-count">0</span> activities selected
            <div id="circle-min-warning" style="color: #dc3545; font-size: 0.85em; margin-top: 5px; display: none;">
                Select at least 4 activities to continue
            </div>
        </div>
        
        <button class="btn" id="circle-create-btn" onclick="finalizeCircleCreation()" disabled style="opacity: 0.5; cursor: not-allowed;">Create Circle</button>
        <button class="btn btn-secondary" onclick="goBackToCircleStep1()"> Back</button>
    </div>
</div><div id="join-circle" style="display: none;"><div class="modal-header">Join Circle</div><div class="form-group"><label for="circle-code">Circle Code</label><input type="text" id="circle-code" placeholder="Enter 6-digit code"></div><button class="btn" onclick="joinCircle()">Join</button></div></div></div>
        <div class="modal-overlay" id="suggest-modal-overlay"><div class="modal-content"><span class="close-modal-btn" onclick="closeSuggestModal()"></span><div class="modal-header">Suggest an Activity</div><div class="form-group"><label for="suggest-name">Activity Name</label><input type="text" id="suggest-name" placeholder="e.g., Go Karting"></div><button class="btn" onclick="suggestActivity()">Suggest</button></div></div>
        <div class="modal-overlay" id="invite-modal-overlay"><div class="modal-content"><span class="close-modal-btn" onclick="closeInviteModal()"></span><div class="modal-header">Share Invite Link</div><div class="form-group"><label for="invite-link">Copy this link and send it to a friend:</label><input type="text" id="invite-link" readonly></div><button class="btn" onclick="copyInviteLink()">Copy Link</button></div></div>
        <div class="modal-overlay" id="update-name-modal-overlay"><div class="modal-content"><span class="close-modal-btn" onclick="closeUpdateNameModal()"></span><div class="modal-header">Update Display Name</div><div class="form-group"><label for="modal-new-username">Display Name</label><input type="text" id="modal-new-username" placeholder="Enter new name"></div><button class="btn" onclick="changeUsername()">Update Name</button></div></div>

<!-- Circle Members Modal -->
<div class="modal-overlay" id="circle-members-modal-overlay" onclick="if(event.target === this) closeCircleMembersModal()">
    <div class="modal-content">
        <span class="close-modal-btn" onclick="closeCircleMembersModal()"></span>
        <div class="modal-header" id="circle-members-modal-title">Circle Members</div>
        <div id="circle-members-list" style="margin-top: 15px;">
            <!-- Members will be populated here -->
        </div>
    </div>
</div>

<!-- Block User Modal -->
<div class="modal-overlay" id="block-user-modal-overlay">
    <div class="modal-content">
        <span class="close-modal-btn" onclick="closeBlockUserModal()"></span>
        <div class="modal-header"> Block User</div>
        <input type="hidden" id="block-user-id">
        <p style="margin: 15px 0; font-size: 0.9em; color: var(--text-secondary); line-height: 1.4;">
            <strong id="block-user-name"></strong> will no longer be able to:
        </p>
        <ul style="margin: 0 0 15px 20px; font-size: 0.85em; color: var(--text-secondary); line-height: 1.6;">
            <li>See your profile</li>
            <li>Send you messages</li>
            <li>Interact with you in circles and matches</li>
        </ul>
        <p style="margin: 15px 0; font-size: 0.85em; color: var(--text-secondary); line-height: 1.4;">
            You won't see their messages or profile either. You can unblock them later from Settings.
        </p>
        <div class="form-group">
            <label for="block-reason">Reason (optional)</label>
            <textarea id="block-reason" rows="2" placeholder="Why are you blocking this user?"></textarea>
        </div>
        <button class="btn" style="background: #dc3545;" onclick="confirmBlockUser()">Block User</button>
        <button class="btn btn-secondary" onclick="closeBlockUserModal()">Cancel</button>
    </div>
</div>

<!-- Report Content Modal -->
<div class="modal-overlay" id="report-modal-overlay">
    <div class="modal-content">
        <span class="close-modal-btn" onclick="closeReportModal()"></span>
        <div class="modal-header"> Report <span id="report-type-text">Content</span></div>
        <input type="hidden" id="report-content-type">
        <input type="hidden" id="report-content-id">
        <input type="hidden" id="report-content-name">
        <input type="hidden" id="report-sender-id">
        <p style="margin: 15px 0; font-size: 0.9em; color: var(--text-secondary); line-height: 1.4;">
            Help us keep Friendle safe. Your report will be reviewed by our team.
        </p>
        <div class="form-group">
            <label for="report-category">Reason *</label>
            <select id="report-category" required style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--bg-color); color: var(--text-primary); font-size: 1em;">
                <option value="">Select a reason...</option>
                <option value="harassment">Harassment or bullying</option>
                <option value="spam">Spam or scam</option>
                <option value="inappropriate_content">Inappropriate content</option>
                <option value="fake_profile">Fake profile or impersonation</option>
                <option value="threatening_behavior">Threatening behavior</option>
                <option value="other">Other</option>
            </select>
        </div>
        <div class="form-group">
            <label for="report-details">Additional details (optional)</label>
            <textarea id="report-details" rows="3" placeholder="Please provide more context..."></textarea>
        </div>
        <div style="margin-bottom: 15px;">
            <label style="display: flex; align-items: center; font-size: 0.85em; color: var(--text-secondary); cursor: pointer;">
                <input type="checkbox" id="report-also-block" style="margin-right: 8px;">
                Also block this user
            </label>
        </div>
        <button class="btn" onclick="submitReport()">Submit Report</button>
        <button class="btn btn-secondary" onclick="closeReportModal()">Cancel</button>
    </div>
</div>

<!-- Payment Modal -->
<div class="modal-overlay" id="payment-modal-overlay">
    <div class="modal-content" style="max-width: 400px;">
        <span class="close-modal-btn" onclick="closePaymentModal()"></span>
        <div class="modal-header"> Additional Circle</div>
        <div style="margin: 20px 0; text-align: center;">
            <div style="font-size: 3em; margin-bottom: 10px;"></div>
            <p style="font-size: 1.1em; font-weight: 600; color: var(--text-primary); margin-bottom: 10px;">
                Your first circle is free!
            </p>
            <p style="font-size: 0.95em; color: var(--text-secondary); line-height: 1.5; margin-bottom: 20px;">
                To create or join additional circles, there's a one-time fee of <strong style="color: var(--primary-color);">$1.99 AUD</strong> per circle.
            </p>
            <div style="background: var(--bg-secondary); border-radius: 12px; padding: 15px; margin: 20px 0;">
                <div style="font-size: 0.85em; color: var(--text-secondary); margin-bottom: 8px;">
                    Active circles:
                </div>
                <div style="font-size: 1.3em; font-weight: 600; color: var(--primary-color);">
                    <span id="payment-circles-current">0</span> / <span id="payment-circles-total">0</span>
                </div>
                <div style="font-size: 0.8em; color: var(--text-tertiary); margin-top: 8px;">
                    (includes 1 free circle)
                </div>
            </div>
        </div>
        <button class="btn" id="payment-proceed-btn" onclick="proceedToPayment()" style="width: 100%; margin-bottom: 10px;">
            Join Additional Circle - $1.99
        </button>
        <button class="btn btn-secondary" onclick="closePaymentModal()" style="width: 100%;">
            Cancel
        </button>
        <p style="font-size: 0.75em; color: var(--text-tertiary); text-align: center; margin-top: 15px;">
            Secure payment powered by Stripe
        </p>
    </div>
</div>

<div class="undo-container" id="undo-container">
                    <span>Selection updated.</span>
                    <button class="undo-btn" onclick="undoLastActivityChange()">Undo</button>
                </div>
<div class="modal-overlay" id="manage-activities-modal-overlay">
    <div class="modal-content">
        <span class="close-modal-btn" onclick="closeManageActivitiesModal()"></span>
        <div class="modal-header">Manage Activities for This Circle</div>
        <div style="margin-bottom: 15px; font-size: 0.9em; color: #666;">
    Customize which activities appear in your activity selection. Core activities are shown by default - uncheck to hide them. Additional activities are available to add more variety to your options.
</div>
        <div id="manage-activities-grid" class="activities-grid"></div>
        <button class="btn" onclick="saveActivityVisibility()">Save Changes</button>
    </div>
</div>
</div>

<!-- Create Event Modal -->
<div class="modal-overlay" id="create-event-modal">
    <div class="modal-content" style="max-width: 500px;">
        <span class="close-modal-btn" onclick="closeCreateEventModal()"></span>
        <div class="modal-header">Schedule New Event</div>
        
        <form id="create-event-form">
            <input type="hidden" id="new-event-match-id">
            
            <div class="form-group">
    <label for="new-event-date">Date *</label>
    <div style="display: flex; gap: 10px;">
        <input type="date" id="new-event-date" required style="flex: 1;">
        <input type="time" id="new-event-time" placeholder="Time (optional)" style="flex: 1;">
    </div>
</div>

            <div class="form-group">
                <label for="new-event-location">Location</label>
                <input type="text" id="new-event-location" placeholder="Where are you meeting?">
            </div>
            
            <div class="form-group">
                <label for="new-event-notes">Notes</label>
                <textarea id="new-event-notes" rows="3" placeholder="Any additional details..."></textarea>
            </div>

            <div class="form-group">
                <label for="new-event-max-participants">Max Attendees</label>
                <input type="number" id="new-event-max-participants" min="1" placeholder="Unlimited">
            </div>

            <button type="submit" class="btn">Create Event</button>
        </form>
    </div>
</div>

<!-- Event Options Modal -->
<div class="modal-overlay" id="event-options-modal">
    <div class="modal-content" style="max-width: 400px;">
        <span class="close-modal-btn" onclick="closeEventOptionsModal()"></span>
        <div class="modal-header">Event Options</div>
        
        <button id="event-edit-btn" onclick="editCurrentEvent()" class="btn btn-secondary" style="width: 100%; text-align: left; margin: 5px 0;">
             Edit Event Details
        </button>
        <button id="event-cancel-btn" onclick="cancelEvent()" class="btn btn-secondary" style="width: 100%; text-align: left; margin: 5px 0;">
             Cancel Event
        </button>
        <button onclick="deleteEvent()" class="btn btn-secondary" style="width: 100%; text-align: left; margin: 5px 0; background: #dc3545; color: white;">
             Delete Event
        </button>
    </div>
</div>

<!-- Edit Event Modal -->
<div class="modal-overlay" id="edit-event-modal">
    <div class="modal-content" style="max-width: 500px;">
        <span class="close-modal-btn" onclick="closeEditEventModal()"></span>
        <div class="modal-header">Edit Event</div>
        
        <form id="edit-event-form">
            <div class="form-group">
    <label for="edit-event-date">Date *</label>
    <div style="display: flex; gap: 10px;">
        <input type="date" id="edit-event-date" required style="flex: 1;">
        <input type="time" id="edit-event-time" placeholder="Time (optional)" style="flex: 1;">
    </div>
</div>

            <div class="form-group">
                <label for="edit-event-location">Location</label>
                <input type="text" id="edit-event-location" placeholder="Where are you meeting?">
            </div>
            
            <div class="form-group">
                <label for="edit-event-notes">Notes</label>
                <textarea id="edit-event-notes" rows="3" placeholder="Any additional details..."></textarea>
            </div>

            <div class="form-group">
                <label for="edit-event-max-participants">Max Attendees</label>
                <input type="number" id="edit-event-max-participants" min="1" placeholder="Unlimited">
            </div>

            <button type="submit" class="btn">Save Changes</button>
        </form>
    </div>
</div>

<!-- Swipe Action Modal (Plan Event / Stay Interested) -->
<div class="modal-overlay" id="swipe-action-modal">
    <div class="modal-content" style="max-width: 400px;">
        <span class="close-modal-btn" onclick="closeSwipeActionModal()"></span>
        <div class="modal-header" id="swipe-action-title"> Activity Match!</div>

        <div style="margin-bottom: 20px; color: #666; line-height: 1.6; text-align: center;">
            <p id="swipe-action-description">What would you like to do?</p>
        </div>

        <button onclick="handlePlanEvent()" class="btn" style="width: 100%; margin-bottom: 10px; background: #007bff;">
             Plan Event
        </button>

        <button onclick="handleStayInterested()" class="btn btn-secondary" style="width: 100%; background: #6c757d; color: white;">
             Stay Interested
        </button>

        <div style="margin-top: 15px; font-size: 12px; color: #999; text-align: center;">
            "Stay Interested" lets you watch for events others create without planning one yourself.
        </div>
    </div>
</div>

<!-- Activity Detail Modal -->
<div class="modal-overlay" id="activity-detail-modal">
    <div class="modal-content" style="max-width: 500px;">
        <span class="close-modal-btn" onclick="closeActivityDetail()"></span>
        <div class="modal-header" id="activity-detail-title"></div>

        <div id="activity-detail-description" style="margin: 20px 0; color: var(--text-secondary); line-height: 1.6;">
            <!-- Activity description will go here -->
        </div>

        <div id="activity-detail-interested" style="margin: 20px 0;">
            <h4 style="font-size: 14px; font-weight: 600; margin-bottom: 10px; color: var(--text-primary);">Interested in this circle:</h4>
            <div id="activity-interested-list" style="font-size: 14px; color: var(--text-secondary);">
                <!-- List of interested users will go here -->
            </div>
        </div>

        <button onclick="planActivityFromDetail()" class="btn" style="width: 100%; margin-top: 10px; background: var(--primary-color);">
             Plan This Activity
        </button>

        <div style="margin-top: 15px; font-size: 12px; color: #999; text-align: center;">
            Set your interests in Settings to customize which event notifications you receive
        </div>
    </div>
</div>

<!-- Planning Event Creation Modal -->
<div class="modal-overlay" id="planning-event-modal">
    <div class="modal-content" style="max-width: 500px;">
        <span class="close-modal-btn" onclick="closePlanningEventModal()"></span>
        <div class="modal-header" id="planning-event-title"> Plan: Activity</div>

        <form id="planning-event-form">
            <input type="hidden" id="planning-event-match-id">
            <input type="hidden" id="planning-event-activity-name">

            <!-- Collapsible Section: Lock in Details Now -->
            <div class="collapsible-section" style="margin-top: 20px;">
                <div class="collapsible-header" onclick="toggleCollapsible(this)">
                    <div class="collapsible-title">
                        <span></span>
                        <span>Lock in details now</span>
                    </div>
                    <span class="collapsible-icon"></span>
                </div>
                <div class="collapsible-content">
                    <div class="collapsible-body">
                        <input type="hidden" id="lock-details-now" value="false">

                        <div class="form-group">
                            <label for="planning-lock-date">Date *</label>
                            <div style="display: flex; gap: 10px;">
                                <input type="date" id="planning-lock-date" style="flex: 1;">
                                <input type="time" id="planning-lock-time" placeholder="Time (optional)" style="flex: 1;">
                            </div>
                        </div>

                        <div class="form-group">
                            <label for="planning-lock-max-participants">Max Attendees</label>
                            <input type="number" id="planning-lock-max-participants" min="1" placeholder="Unlimited">
                        </div>

                        <div class="form-group">
                            <label for="planning-location">Where? *</label>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <input type="text" id="planning-location" placeholder="Enter location" style="flex: 1;">
                                <button type="button" onclick="openGoogleMapsSearch()" style="padding: 10px 12px; border: 1px solid #ddd; border-radius: 5px; background: white; cursor: pointer; font-size: 16px;" title="Search location on Google Maps"></button>
                            </div>
                            <div id="planning-location-suggestions" style="margin-top: 5px; font-size: 12px; color: #666;">
                                <!-- Suggestions will appear here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Collapsible Section: Plan with Others -->
            <div class="collapsible-section">
                <div class="collapsible-header" onclick="toggleCollapsible(this)">
                    <div class="collapsible-title">
                        <span></span>
                        <span>Plan with others</span>
                    </div>
                    <span class="collapsible-icon"></span>
                </div>
                <div class="collapsible-content">
                    <div class="collapsible-body">
                        <input type="hidden" id="plan-with-others" value="false">

                        <div class="form-group">
                            <label for="planning-timeframe">When works for you? *</label>
                            <select id="planning-timeframe" required style="width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #ddd;">
                                <option value="">Select a timeframe...</option>
                                <option value="Today">Today</option>
                                <option value="Tomorrow">Tomorrow</option>
                                <option value="This week">This week</option>
                                <option value="Next week">Next week</option>
                                <option value="Flexible">Flexible</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="planning-plan-location">Where? (optional)</label>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <input type="text" id="planning-plan-location" placeholder="Suggest a location or leave blank" style="flex: 1;">
                                <button type="button" onclick="openGoogleMapsSearchPlan()" style="padding: 10px 12px; border: 1px solid #ddd; border-radius: 5px; background: white; cursor: pointer; font-size: 16px;" title="Search location on Google Maps"></button>
                            </div>
                        </div>

                        <div class="form-group">
                            <label for="planning-notes">Notes (optional)</label>
                            <textarea id="planning-notes" rows="3" placeholder="Any other thoughts..."></textarea>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Collapsible Section: Create a Poll -->
            <div class="collapsible-section">
                <div class="collapsible-header" onclick="toggleCollapsible(this)">
                    <div class="collapsible-title">
                        <span></span>
                        <span>Create a poll</span>
                    </div>
                    <span class="collapsible-icon"></span>
                </div>
                <div class="collapsible-content">
                    <div class="collapsible-body">
                        <input type="hidden" id="create-poll-on-start" value="false">

                        <div class="form-group">
                            <label for="planning-poll-question-template">Question Template</label>
                            <select id="planning-poll-question-template" onchange="handlePlanningPollTemplateChange()" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 10px;">
                                <option value="">Select a template or write your own...</option>
                                <option value="when">When? (Scheduling/Timing)</option>
                                <option value="where">Where? (Location)</option>
                                <option value="who">Who should come? (Group Size)</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="planning-poll-question">Poll Question *</label>
                            <input type="text" id="planning-poll-question" placeholder="Enter your question or select a template above" style="width: 100%;">
                        </div>

                        <div class="form-group">
                            <label>Poll Options *</label>
                            <div id="planning-poll-options-container">
                                <div class="poll-option-input" style="display: flex; gap: 10px; margin-bottom: 10px;">
                                    <input type="text" class="planning-poll-option" placeholder="Option 1" style="flex: 1;">
                                </div>
                                <div class="poll-option-input" style="display: flex; gap: 10px; margin-bottom: 10px;">
                                    <input type="text" class="planning-poll-option" placeholder="Option 2" style="flex: 1;">
                                </div>
                            </div>
                            <button type="button" onclick="addPlanningPollOption()" class="btn btn-secondary" style="padding: 8px 12px; font-size: 14px;">+ Add Option</button>
                        </div>

                        <div class="form-group consensus-notification-section" style="background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #dee2e6;">
                            <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 10px;">
                                <input type="checkbox" id="enable-auto-lock" onchange="toggleAutoLockFields()" style="margin-right: 10px;">
                                <span><strong> Send notification when users agree</strong></span>
                            </label>
                            <p style="font-size: 12px; color: #666; margin: 0 0 10px 0;">Notify all participants when enough people agree on a poll option</p>

                            <div id="auto-lock-fields" style="display: none;">
                                <label for="auto-lock-threshold">Notify when this many users agree:</label>
                                <input type="number" id="auto-lock-threshold" min="2" value="3" style="width: 100%; margin-top: 5px;">
                                <p style="font-size: 11px; color: #666; margin: 5px 0 0 0;">Everyone will be notified when this many participants vote for the same option</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <button type="submit" class="btn" id="planning-submit-btn" style="width: 100%; margin-top: 20px;">Start Planning</button>
        </form>
    </div>
</div>

<!-- Going Users Modal -->
<div class="modal-overlay" id="event-attendees-modal">
    <div class="modal-content" style="max-width: 400px;">
        <span class="close-modal-btn" onclick="closeEventAttendeesModal()"></span>
        <div class="modal-header" id="attendees-modal-title"> Going</div>

        <div id="attendees-list" style="margin-top: 20px;">
            <!-- Going users will be populated here -->
        </div>
    </div>
</div>

<!-- Lock in Details Modal -->
<div class="modal-overlay" id="lock-details-modal">
    <div class="modal-content" style="max-width: 500px;">
        <span class="close-modal-btn" onclick="closeLockDetailsModal()"></span>
        <div class="modal-header"> Lock in Event Details</div>

        <form id="lock-details-form">
            <div class="form-group">
                <label for="lock-date">Date *</label>
                <div style="display: flex; gap: 10px;">
                    <input type="date" id="lock-date" required style="flex: 1;">
                    <input type="time" id="lock-time" placeholder="Time (optional)" style="flex: 1;">
                </div>
            </div>

            <div class="form-group">
                <label for="lock-location">Location *</label>
                <input type="text" id="lock-location" required placeholder="Where are you meeting?">
            </div>

            <div class="form-group">
                <label for="lock-notes">Notes (optional)</label>
                <textarea id="lock-notes" rows="3" placeholder="Any additional details..."></textarea>
            </div>

            <div class="form-group">
                <label for="lock-max-participants">Max Attendees</label>
                <input type="number" id="lock-max-participants" min="1" placeholder="Unlimited">
            </div>

            <button type="submit" class="btn"> Lock in Event</button>
        </form>
    </div>
</div>

<!-- Create Poll Modal -->
<div class="modal-overlay" id="create-poll-modal">
    <div class="modal-content" style="max-width: 500px;">
        <span class="close-modal-btn" onclick="closeCreatePollModal()"></span>
        <div class="modal-header"> Quick Poll</div>

        <form id="create-poll-form">
            <div class="form-group">
                <label for="poll-question-template">Question Template</label>
                <select id="poll-question-template" onchange="handlePollTemplateChange()" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 10px;">
                    <option value="">Select a template or write your own...</option>
                    <option value="when">When? (Scheduling/Timing)</option>
                    <option value="where">Where? (Location)</option>
                    <option value="who">Who should come? (Group Size)</option>
                </select>
            </div>

            <div class="form-group">
                <label for="poll-question">Question *</label>
                <input type="text" id="poll-question" required placeholder="Enter your question or select a template above" maxlength="200">
            </div>

            <div class="form-group">
                <label>Options *</label>
                <div id="poll-options-container">
                    <div class="poll-option-input" style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <input type="text" class="poll-option" placeholder="Option 1" required style="flex: 1;">
                    </div>
                    <div class="poll-option-input" style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <input type="text" class="poll-option" placeholder="Option 2" required style="flex: 1;">
                    </div>
                </div>
                <button type="button" onclick="addPollOption()" class="btn btn-secondary" style="width: 100%; margin-top: 5px;">
                     Add Option
                </button>
            </div>

            <!-- Agreement Notification Section -->
            <div class="form-group poll-notification-section" style="padding: 15px; border-radius: 8px;">
                <label class="poll-notification-label" style="display: flex; align-items: center; cursor: pointer; margin-bottom: 5px;">
                    <input type="checkbox" id="chat-poll-enable-auto-lock" onchange="toggleChatPollAutoLock()" style="margin-right: 10px;">
                    <span style="font-weight: 600;"> Enable Agreement Notifications</span>
                </label>
                <p class="poll-notification-description" style="font-size: 12px; margin: 0 0 10px 0;">Notify all participants when enough people agree on a poll option</p>

                <div id="chat-poll-auto-lock-threshold" style="display: none; margin-top: 10px;">
                    <label for="chat-poll-threshold-input" class="poll-notification-threshold-label" style="font-size: 13px; margin-bottom: 5px; display: block;">
                        Notify when <input type="number" id="chat-poll-threshold-input" min="2" max="10" value="2" style="width: 50px; padding: 4px; border: 1px solid #ccc; border-radius: 4px; text-align: center; margin: 0 5px;"> people agree
                    </label>
                </div>
            </div>

            <button type="submit" class="btn" style="width: 100%;">Send Poll</button>
        </form>
    </div>
</div>

<!-- Location Permission Modal -->
<div class="modal-overlay" id="location-permission-modal">
    <div class="modal-content" style="max-width: 400px;">
        <span class="close-modal-btn" onclick="closeLocationPermissionModal()"></span>
        <div class="modal-header">Location Access Needed</div>

        <div style="margin-bottom: 20px; color: #666; line-height: 1.6;">
            <p style="margin-bottom: 15px;">This feature requires access to your location to:</p>
            <ul style="margin: 0; padding-left: 20px;">
                <li style="margin-bottom: 8px;">Share your location with friends</li>
                <li style="margin-bottom: 8px;">Find nearby places for your activities</li>
            </ul>
        </div>

        <button class="btn" onclick="requestLocationPermission()">Enable Location</button>
        <button class="btn btn-secondary" onclick="closeLocationPermissionModal()">Not Now</button>
    </div>
</div>

<!-- Generic Modal for dynamic content -->
<div class="modal-overlay" id="generic-modal-overlay">
    <div class="modal-content">
        <span class="close-modal-btn" onclick="closeGenericModal()"></span>
        <div class="modal-header" id="generic-modal-title">Modal</div>
        <div id="generic-modal-body" style="margin-top: 15px;">
            <!-- Dynamic content will be inserted here -->
        </div>
    </div>
</div>

<!-- Removed: Old match notification and first-to-choose modals - replaced with swipe action modal -->

<!-- Tutorial Modals -->
<!-- Activities Tutorial Modal -->
<div class="modal-overlay" id="tutorial-activities-modal" style="z-index: 9999;">
    <div class="modal-content tutorial-modal" style="max-width: 400px;">
        <div class="tutorial-header">
            <h2 style="margin: 0 0 10px 0; color: var(--primary-color);"> Activities Guide</h2>
            <div class="tutorial-progress">
                <span class="tutorial-step-indicator"></span>
            </div>
        </div>

        <div class="tutorial-content">
            <!-- Step 1 -->
            <div class="tutorial-step" data-step="1">
                <div style="font-size: 3em; text-align: center; margin-bottom: 15px;"></div>
                <h3 style="margin-bottom: 10px;">Select Activities</h3>
                <p>Swipe right or tap to select. Pick as many as you want!</p>
            </div>

            <!-- Step 2 -->
            <div class="tutorial-step" data-step="2" style="display: none;">
                <div style="font-size: 3em; text-align: center; margin-bottom: 15px;"></div>
                <h3 style="margin-bottom: 10px;">Pass Activities</h3>
                <p>Swipe left or de-select to pass. Change your mind anytime.</p>
            </div>

            <!-- Step 3 -->
            <div class="tutorial-step" data-step="3" style="display: none;">
                <div style="font-size: 3em; text-align: center; margin-bottom: 15px;"></div>
                <h3 style="margin-bottom: 10px;">Switch Views</h3>
                <p>Toggle between swipe and grid. Grid shows multiple at once.</p>
            </div>

            <!-- Step 4 -->
            <div class="tutorial-step" data-step="4" style="display: none;">
                <div style="font-size: 3em; text-align: center; margin-bottom: 15px;"></div>
                <h3 style="margin-bottom: 10px;">Suggest Activities</h3>
                <p>Don't see what you want? Tap "Suggest Activity" to add your own!</p>
            </div>
        </div>

        <div class="tutorial-buttons">
            <button class="btn btn-secondary" onclick="skipTutorial('activities')" id="tutorial-activities-skip">Skip</button>
            <div style="display: flex; gap: 10px; flex: 1; justify-content: flex-end;">
                <button class="btn btn-secondary" onclick="previousTutorialStep('activities')" id="tutorial-activities-prev" style="display: none;">Previous</button>
                <button class="btn" onclick="nextTutorialStep('activities')" id="tutorial-activities-next">Next</button>
            </div>
        </div>
    </div>
</div>

<!-- Circles Tutorial Modal -->
<div class="modal-overlay" id="tutorial-circles-modal" style="z-index: 9999;">
    <div class="modal-content tutorial-modal" style="max-width: 400px;">
        <div class="tutorial-header">
            <h2 style="margin: 0 0 10px 0; color: var(--primary-color);"> Circles Guide</h2>
            <div class="tutorial-progress">
                <span class="tutorial-step-indicator"></span>
            </div>
        </div>

        <div class="tutorial-content">
            <!-- Step 1 -->
            <div class="tutorial-step" data-step="1">
                <div style="font-size: 3em; text-align: center; margin-bottom: 15px;"></div>
                <h3 style="margin-bottom: 10px;">What are Circles?</h3>
                <p>Circles are your friend groups - work, college, family, etc.</p>
            </div>

            <!-- Step 2 -->
            <div class="tutorial-step" data-step="2" style="display: none;">
                <div style="font-size: 3em; text-align: center; margin-bottom: 15px;"></div>
                <h3 style="margin-bottom: 10px;">Create a Circle</h3>
                <p>Tap "Create Circle", name it, and share the invite code!</p>
            </div>

            <!-- Step 3 -->
            <div class="tutorial-step" data-step="3" style="display: none;">
                <div style="font-size: 3em; text-align: center; margin-bottom: 15px;"></div>
                <h3 style="margin-bottom: 10px;">Join a Circle</h3>
                <p>Have an invite code? Tap "Join Circle" and enter it.</p>
            </div>

            <!-- Step 4 -->
            <div class="tutorial-step" data-step="4" style="display: none;">
                <div style="font-size: 3em; text-align: center; margin-bottom: 15px;"></div>
                <h3 style="margin-bottom: 10px;">Expand Circles</h3>
                <p>Tap a circle to see the invite code and chat. More people = better matches!</p>
            </div>
        </div>

        <div class="tutorial-buttons">
            <button class="btn btn-secondary" onclick="skipTutorial('circles')" id="tutorial-circles-skip">Skip</button>
            <div style="display: flex; gap: 10px; flex: 1; justify-content: flex-end;">
                <button class="btn btn-secondary" onclick="previousTutorialStep('circles')" id="tutorial-circles-prev" style="display: none;">Previous</button>
                <button class="btn" onclick="nextTutorialStep('circles')" id="tutorial-circles-next">Next</button>
            </div>
        </div>
    </div>
</div>

<!-- Matches Tutorial Modal -->
<div class="modal-overlay" id="tutorial-matches-modal" style="z-index: 9999;">
    <div class="modal-content tutorial-modal" style="max-width: 400px;">
        <div class="tutorial-header">
            <h2 style="margin: 0 0 10px 0; color: var(--primary-color);"> Matches Guide</h2>
            <div class="tutorial-progress">
                <span class="tutorial-step-indicator"></span>
            </div>
        </div>

        <div class="tutorial-content">
            <!-- Step 1 -->
            <div class="tutorial-step" data-step="1">
                <div style="font-size: 3em; text-align: center; margin-bottom: 15px;"></div>
                <h3 style="margin-bottom: 10px;">What are Matches?</h3>
                <p>Matches show when you and friends pick the same activity!</p>
            </div>

            <!-- Step 2 -->
            <div class="tutorial-step" data-step="2" style="display: none;">
                <div style="font-size: 3em; text-align: center; margin-bottom: 15px;"></div>
                <h3 style="margin-bottom: 10px;">Expand Cards</h3>
                <p>Tap a match to see who's interested and upcoming events.</p>
            </div>

            <!-- Step 3 -->
            <div class="tutorial-step" data-step="3" style="display: none;">
                <div style="font-size: 3em; text-align: center; margin-bottom: 15px;"></div>
                <h3 style="margin-bottom: 10px;">Plan Events</h3>
                <p>Tap "Create Event" to lock in details or just start planning together!</p>
            </div>

            <!-- Step 4 -->
            <div class="tutorial-step" data-step="4" style="display: none;">
                <div style="font-size: 3em; text-align: center; margin-bottom: 15px;"></div>
                <h3 style="margin-bottom: 10px;">Join Events</h3>
                <p>See an event you like? Join to confirm attendance and chat!</p>
            </div>
        </div>

        <div class="tutorial-buttons">
            <button class="btn btn-secondary" onclick="skipTutorial('matches')" id="tutorial-matches-skip">Skip</button>
            <div style="display: flex; gap: 10px; flex: 1; justify-content: flex-end;">
                <button class="btn btn-secondary" onclick="previousTutorialStep('matches')" id="tutorial-matches-prev" style="display: none;">Previous</button>
                <button class="btn" onclick="nextTutorialStep('matches')" id="tutorial-matches-next">Next</button>
            </div>
        </div>
    </div>
</div>

<style>
@keyframes slideUp {
    from {
        transform: translateY(50px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

@keyframes bounce {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.2); }
}
</style>

    <script>

        // App State
        let currentUser = null, circles = [], selectedCircle = null, activities = [], lastActivitiesState = [], activityCounts = {}, matches = [], undoTimeout = null, showingArchivedMessages = false, currentCircleChat = null, circleMessageSubscription = null, allActiveSubscriptions = [], skipAutoLoad = false, currentMatchId = null, expandedCircles = new Set(), expandedMatchCircles = new Set(), highlightedEventId = null;

        // Message Pagination State
        const MESSAGE_PAGE_SIZE = 50;
        let messagePagination = {
            match: { loadedCount: 0, hasMore: true, loading: false },
            event: { loadedCount: 0, hasMore: true, loading: false },
            circle: { loadedCount: 0, hasMore: true, loading: false }
        };

        // App Initialization State Tracker (for iOS notification handling)
        window.appState = {
            initialized: false,
            dataLoaded: false,
            matchesLoaded: false,
            circlesLoaded: false,
            timestamp: Date.now()
        };

        // SECURITY: Secure Storage Helper
        // Minimizes sensitive data in localStorage to reduce XSS attack surface
        // Only stores user ID persistently; uses sessionStorage for non-critical data
        const SecureStorage = {
            // Only store user ID persistently (needed for auto-login check)
            setUserId(userId) {
                if (userId) {
                    localStorage.setItem('friendle_user_id', userId);
                }
            },

            getUserId() {
                return localStorage.getItem('friendle_user_id');
            },

            // Store minimal UI data in sessionStorage (clears on tab close)
            setSessionData(data) {
                if (!data) return;
                sessionStorage.setItem('friendle_session', JSON.stringify({
                    name: data.name || '',
                    avatar: data.avatar || ''
                }));
            },

            getSessionData() {
                const data = sessionStorage.getItem('friendle_session');
                return data ? JSON.parse(data) : null;
            },

            // Clear all stored data on logout
            clearAll() {
                localStorage.removeItem('friendle_user_id');
                localStorage.removeItem('friendle_user'); // Legacy - clean up old storage
                localStorage.removeItem('friendle_current_page'); // Reset page preference to default
                localStorage.removeItem('friendle_previous_page'); // Clear navigation history
                localStorage.removeItem('friendle_current_chat_context'); // Clear chat context
                sessionStorage.removeItem('friendle_session');
            }
        };

        // Invite Code Storage Helper
        // Stores invite codes in localStorage (survives PWA installation) with 24-hour expiry
        const InviteCodeStorage = {
            STORAGE_KEY: 'pending_invite_code',
            EXPIRY_HOURS: 24,

            set(code) {
                if (!code) return;
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify({
                    code: code,
                    timestamp: Date.now()
                }));
                console.log(' Invite code stored:', code);
            },

            get() {
                const data = localStorage.getItem(this.STORAGE_KEY);
                if (!data) return null;

                try {
                    const parsed = JSON.parse(data);
                    const ageHours = (Date.now() - parsed.timestamp) / (1000 * 60 * 60);

                    // Check if expired
                    if (ageHours > this.EXPIRY_HOURS) {
                        console.log(' Invite code expired, clearing');
                        this.clear();
                        return null;
                    }

                    return parsed.code;
                } catch (e) {
                    // Handle legacy sessionStorage format or invalid data
                    console.error('Error parsing invite code:', e);
                    this.clear();
                    return null;
                }
            },

            clear() {
                localStorage.removeItem(this.STORAGE_KEY);
                // Also clear legacy sessionStorage if present
                sessionStorage.removeItem('pending_invite_code');
                console.log(' Invite code cleared');
            }
        };

        // SECURITY: Rate Limiter
        // Prevents abuse by limiting actions per time window
        // Uses sliding window algorithm for accurate rate limiting
        const RateLimiter = {
            limits: new Map(), // operation -> array of timestamps

            /**
             * Check if an operation is allowed based on rate limit
             * @param {string} operation - Name of the operation (e.g., 'file_upload', 'send_message')
             * @param {number} maxRequests - Maximum requests allowed
             * @param {number} windowMs - Time window in milliseconds
             * @returns {boolean} - True if allowed, false if rate limited
             */
            checkLimit(operation, maxRequests, windowMs) {
                const now = Date.now();
                const operationKey = `${operation}_${currentUser?.id || 'anonymous'}`;

                // Get existing timestamps for this operation
                if (!this.limits.has(operationKey)) {
                    this.limits.set(operationKey, []);
                }

                const timestamps = this.limits.get(operationKey);

                // Remove timestamps outside the current window
                const validTimestamps = timestamps.filter(ts => now - ts < windowMs);
                this.limits.set(operationKey, validTimestamps);

                // Check if under limit
                if (validTimestamps.length >= maxRequests) {
                    const oldestTimestamp = Math.min(...validTimestamps);
                    const waitTimeMs = windowMs - (now - oldestTimestamp);
                    const waitTimeSec = Math.ceil(waitTimeMs / 1000);
                    console.warn(`Rate limit exceeded for ${operation}. Wait ${waitTimeSec}s`);
                    return false;
                }

                // Add current timestamp
                validTimestamps.push(now);
                this.limits.set(operationKey, validTimestamps);
                return true;
            },

            /**
             * Get remaining requests for an operation
             * @param {string} operation - Name of the operation
             * @param {number} maxRequests - Maximum requests allowed
             * @param {number} windowMs - Time window in milliseconds
             * @returns {number} - Number of requests remaining
             */
            getRemaining(operation, maxRequests, windowMs) {
                const now = Date.now();
                const operationKey = `${operation}_${currentUser?.id || 'anonymous'}`;

                if (!this.limits.has(operationKey)) {
                    return maxRequests;
                }

                const timestamps = this.limits.get(operationKey);
                const validTimestamps = timestamps.filter(ts => now - ts < windowMs);
                return Math.max(0, maxRequests - validTimestamps.length);
            }
        };

        /**
         * Waits for the app to be fully initialized and data to be loaded
         * Critical for iOS devices where notification clicks may happen during app load
         * @param {number} timeoutMs - Maximum time to wait in milliseconds
         * @returns {Promise<void>}
         */
        window.waitForAppReady = async function(timeoutMs = 30000) {
            const startTime = Date.now();
            const checkInterval = 100; // Check every 100ms

            console.log(' waitForAppReady: Starting to wait for app readiness...');
            console.log(' Initial state:', JSON.stringify(window.appState));

            return new Promise((resolve, reject) => {
                const checkReady = () => {
                    const elapsed = Date.now() - startTime;

                    // Check if app is fully ready
                    const isReady = window.appState.initialized &&
                                  window.appState.dataLoaded &&
                                  window.currentUser !== null;

                    console.log(` waitForAppReady check (${elapsed}ms elapsed):`, {
                        initialized: window.appState.initialized,
                        dataLoaded: window.appState.dataLoaded,
                        hasUser: window.currentUser !== null,
                        matchesLoaded: window.appState.matchesLoaded,
                        circlesLoaded: window.appState.circlesLoaded,
                        isReady: isReady
                    });

                    if (isReady) {
                        console.log(' waitForAppReady: App is ready!');
                        resolve();
                        return;
                    }

                    // Check for timeout
                    if (elapsed >= timeoutMs) {
                        console.error(' waitForAppReady: Timeout after', elapsed, 'ms');
                        console.error(' Final state:', JSON.stringify(window.appState));
                        reject(new Error(`App not ready after ${timeoutMs}ms timeout`));
                        return;
                    }

                    // Continue checking
                    setTimeout(checkReady, checkInterval);
                };

                // Start checking
                checkReady();
            });
        };

// ========== CHAT CONTEXT MANAGEMENT ==========
// These helpers ensure only ONE chat context is active at a time

function clearAllChatContexts() {
    console.log(' Clearing all chat contexts');
    currentEvent = null;
    currentCircleChat = null;
    currentMatchId = null;
}

function setEventContext(event) {
    console.log(' Setting event context:', event.id);
    clearAllChatContexts();
    currentEvent = event;
}

function setMatchContext(match) {
    console.log(' Setting match context:', match.id);
    clearAllChatContexts();
    currentMatchId = match.id; // Keep for backwards compatibility during refactor
}

function setCircleChatContext(circle) {
    console.log(' Setting circle chat context:', circle.id);
    clearAllChatContexts();
    currentCircleChat = circle;
}

function getCurrentChatContext() {
    if (currentEvent) {
        return { type: 'event', id: currentEvent.id, data: currentEvent };
    } else if (currentCircleChat) {
        return { type: 'circle', id: currentCircleChat.id, data: currentCircleChat };
    }
    return { type: 'none', id: null, data: null };
}
// ========== END CHAT CONTEXT MANAGEMENT ==========

// UUID Generator
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

// Authentication functions
function showRegister() {
    document.getElementById('login-form').style.display = 'none';
    document.getElementById('forgot-password-form').style.display = 'none';
    document.getElementById('password-reset-form').style.display = 'none';
    document.getElementById('register-form').style.display = 'block';
}

function showLogin() {
    document.getElementById('register-form').style.display = 'none';
    document.getElementById('forgot-password-form').style.display = 'none';
    document.getElementById('password-reset-form').style.display = 'none';
    document.getElementById('login-form').style.display = 'block';
}

function showForgotPassword() {
    document.getElementById('login-form').style.display = 'none';
    document.getElementById('register-form').style.display = 'none';
    document.getElementById('password-reset-form').style.display = 'none';
    document.getElementById('forgot-password-form').style.display = 'block';
}

function showPasswordResetModal() {
    console.log('Showing password reset modal');

    // Hide all other forms
    const loginForm = document.getElementById('login-form');
    const registerForm = document.getElementById('register-form');
    const forgotPasswordForm = document.getElementById('forgot-password-form');
    const passwordResetForm = document.getElementById('password-reset-form');

    if (loginForm) loginForm.style.display = 'none';
    if (registerForm) registerForm.style.display = 'none';
    if (forgotPasswordForm) forgotPasswordForm.style.display = 'none';
    if (passwordResetForm) passwordResetForm.style.display = 'block';

    // Show the welcome page (which contains the password reset form)
    const welcomePage = document.getElementById('welcome');
    if (welcomePage) {
        // Hide all other pages first
        document.querySelectorAll('.page').forEach(page => page.classList.remove('active'));
        welcomePage.classList.add('active');
    }

    // Hide loader if it's showing
    hideLoader();

    console.log('Password reset form should now be visible');
}

async function submitPasswordReset() {
    const newPassword = document.getElementById('new-reset-password').value;
    const confirmPassword = document.getElementById('confirm-reset-password').value;

    if (!newPassword || !confirmPassword) {
        return showNotification('Please fill in both password fields', 'error');
    }

    if (newPassword.length < 6) {
        return showNotification('New password must be at least 6 characters', 'error');
    }

    if (newPassword !== confirmPassword) {
        return showNotification('Passwords do not match', 'error');
    }

    try {
        showLoader('Resetting password...');

        const { error } = await supabase.auth.updateUser({
            password: newPassword
        });

        if (error) throw error;

        // User is now authenticated with new password - load their profile and navigate to app
        const { data: { session } } = await supabase.auth.getSession();

        if (session) {
            // Load user profile
            const { data: profileData, error: profileError } = await supabase
                .from('profiles')
                .select('*')
                .eq('id', session.user.id)
                .single();

            if (profileError) throw profileError;

            currentUser = profileData;
            // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
            SecureStorage.setUserId(currentUser.id);
            SecureStorage.setSessionData(currentUser);

            // Clear form fields
            document.getElementById('new-reset-password').value = '';
            document.getElementById('confirm-reset-password').value = '';

            // Load app data
            await renderCircles();
            window.appState.circlesLoaded = true;

            await loadMatches();
            window.appState.matchesLoaded = true;

            await updateNotificationBadge();

            // Mark app as initialized (critical for iOS)
            window.appState.initialized = true;
            window.appState.dataLoaded = true;
            console.log(' App initialized after password reset:', JSON.stringify(window.appState));

            // Clear hash parameters to prevent re-triggering password recovery flow
            window.history.replaceState({}, document.title, window.location.pathname);

            hideLoader();
            showNotification('Password reset successful!  Welcome back!', 'success');

            // Check for pending chat from notification click (takes priority)
            const hasPendingChat = sessionStorage.getItem('pending_chat_id') && sessionStorage.getItem('pending_chat_type');

            if (!hasPendingChat) {
                showPage('events');
            }

            updateProfile();
            await processPendingChat();
        } else {
            // No session - show login
            hideLoader();
            showNotification('Password reset successful!  Please sign in with your new password.', 'success');
            showLogin();
        }

    } catch (error) {
        hideLoader();
        console.error('Password reset error:', error);
        showNotification(error.message || 'Error resetting password', 'error');
    }
}

async function sendPasswordReset() {
    const email = document.getElementById('reset-email').value.trim();

    if (!email) {
        return showNotification('Please enter your email address', 'error');
    }

    try {
        showLoader('Sending reset link...');

        const { error } = await supabase.auth.resetPasswordForEmail(email, {
            redirectTo: window.location.origin
        });

        if (error) throw error;

        hideLoader();
        showNotification('Password reset link sent! \n\nIMPORTANT: The email may take 5-15 minutes to arrive. Please be patient and check your spam/junk folder if you don\'t see it.\n\nClick the link in the email to reset your password.', 'success');
        showLogin();
        document.getElementById('reset-email').value = '';

    } catch (error) {
        hideLoader();
        console.error('Password reset error:', error);
        showNotification(error.message || 'Error sending reset link', 'error');
    }
}

window.showWelcomeFromOnboarding = function() {
    document.getElementById('onboarding').classList.remove('active');
    document.getElementById('welcome').classList.add('active');

    // If they have an invite code, show registration form instead of login
    const inviteCode = InviteCodeStorage.get();
    if (inviteCode) {
        showRegister();

        // Show PWA install prompt for invite code users
        // This ensures the prompt appears even if they clicked through quickly from onboarding
        setTimeout(() => {
            showPWAPrompt(true);
        }, 1000);
    }
}

window.signUp = async function() {
    const email = document.getElementById('register-email').value.trim();
    const password = document.getElementById('register-password').value;
    const name = document.getElementById('register-name').value.trim();
    const selectedAvatar = document.querySelector('#register-form .avatar-option.selected');
    const photoFile = window.registerPhotoFile;

    // Debug logging (password length only for security)
    console.log('Sign up attempt:', {
        email,
        name,
        passwordLength: password.length,
        hasAvatar: !!selectedAvatar,
        hasPhoto: !!photoFile
    });

    if (!email || !password || !name) {
        console.error('Validation failed: missing required fields');
        return showNotification('Please fill in all fields', 'error');
    }

    if (!selectedAvatar && !photoFile) {
        return showNotification('Please select an avatar or upload a photo', 'error');
    }

    if (password.length < 6) {
        return showNotification('Password must be at least 6 characters', 'error');
    }

    try {
        showLoader('Creating your account...');

        // Sign up with Supabase Auth
        const { data: authData, error: authError } = await supabase.auth.signUp({
            email: email,
            password: password
        });

        if (authError) throw authError;

        let avatarValue = selectedAvatar ? selectedAvatar.dataset.avatar : '';

        // If user uploaded a photo, upload it to storage
        if (photoFile) {
            showLoader('Uploading profile picture...');

            const fileExt = photoFile.name.split('.').pop().toLowerCase();
            const fileName = `${authData.user.id}/avatar.${fileExt}`;

            // Upload photo
            const { error: uploadError } = await supabase.storage
                .from('avatars')
                .upload(fileName, photoFile, {
                    cacheControl: '3600',
                    upsert: true
                });

            if (uploadError) throw uploadError;

            // Get public URL
            const { data: urlData } = supabase.storage
                .from('avatars')
                .getPublicUrl(fileName);

            avatarValue = urlData.publicUrl;
        }

        // Create profile with authenticated user ID
        const profileDataToInsert = {
            id: authData.user.id, // Use Supabase Auth user ID
            name: name,
            avatar: avatarValue
        };

        console.log('Creating profile with data:', profileDataToInsert);

        const { data: profileData, error: profileError } = await supabase
            .from('profiles')
            .insert([profileDataToInsert])
            .select()
            .single();

        if (profileError) throw profileError;

        console.log('Profile created successfully:', { id: profileData.id, name: profileData.name, avatar: profileData.avatar });

        // Clear the photo file after successful registration
        window.registerPhotoFile = null;

        currentUser = profileData;

        // Load default activities now that user is authenticated
        // This is critical for new users who will create circles
        await loadDefaultActivities();

        // Request notification permission and subscribe to OneSignal
        if (window.OneSignalDeferred) {
            try {
                window.OneSignalDeferred.push(async function(OneSignal) {
                    // Use OneSignal API to request permission and subscribe
                    // This properly subscribes the user unlike native Notification.requestPermission()
                    const permission = await OneSignal.Notifications.permission;
                    if (!permission) {
                        console.log(' Requesting OneSignal notification permission...');

                        if (isSamsungInternet()) {
                            console.log(' SAMSUNG: About to request permission during signup');
                            console.log(' SAMSUNG: Current permission state:', permission);
                        }

                        await OneSignal.Notifications.requestPermission();

                        if (isSamsungInternet()) {
                            const newPermission = await OneSignal.Notifications.permission;
                            console.log(' SAMSUNG: Permission after request:', newPermission);
                            const token = OneSignal.User.PushSubscription.token;
                            console.log(' SAMSUNG: Token after request:', token ? 'Present' : 'Missing');
                        }
                    }

                    // Save player ID to profile
                    const userId = await OneSignal.User.PushSubscription.id;
                    if (userId) {
                        await supabase
                            .from('profiles')
                            .update({ onesignal_player_id: userId })
                            .eq('id', currentUser.id);

                        console.log(' OneSignal Player ID saved:', userId);

                        if (isSamsungInternet()) {
                            console.log(' SAMSUNG: Player ID saved to database:', userId);
                        }
                    } else if (isSamsungInternet()) {
                        console.log(' SAMSUNG: WARNING - No player ID returned after permission request');
                    }
                });
            } catch (error) {
                console.error('Error setting up OneSignal:', error);
            }
        }

        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
        SecureStorage.setUserId(currentUser.id);
        SecureStorage.setSessionData(currentUser);

        showNotification('Account created successfully!');

        // Load app data before processing pending chat (critical for iOS)
        await renderCircles();
        window.appState.circlesLoaded = true;

        await loadMatches();
        window.appState.matchesLoaded = true;

        // Mark app as initialized
        window.appState.initialized = true;
        window.appState.dataLoaded = true;
        console.log(' App initialized after signup:', JSON.stringify(window.appState));

        // Check for pending chat from notification click (takes priority)
        const hasPendingChat = sessionStorage.getItem('pending_chat_id') && sessionStorage.getItem('pending_chat_type');

        if (!hasPendingChat) {
            showPage('events');
        }

        updateProfile();
        await processInviteCode();
        await processPendingChat();

        hideLoader();

    } catch (error) {
        hideLoader();
        console.error('Signup error:', error);
        showNotification(error.message || 'Error creating account', 'error');
    }
}

window.signIn = async function() {
    const email = document.getElementById('login-email').value.trim();
    const password = document.getElementById('login-password').value;
    
    if (!email || !password) {
        return showNotification('Please enter email and password', 'error');
    }
    
    try {
        // Sign in with Supabase Auth
        const { data: authData, error: authError } = await supabase.auth.signInWithPassword({
            email: email,
            password: password
        });
        
        if (authError) throw authError;
        
        // Load user profile
        const { data: profileData, error: profileError } = await supabase
            .from('profiles')
            .select('*')
            .eq('id', authData.user.id)
            .single();
        
        if (profileError) throw profileError;
        
        currentUser = profileData;

        // Load default activities now that user is authenticated
        await loadDefaultActivities();

        // Request notification permission and save OneSignal Player ID to profile
        if (window.OneSignalDeferred) {
            try {
                window.OneSignalDeferred.push(async function(OneSignal) {
                    // Request notification permission on first sign-in (especially for PWA users)
                    const permission = await OneSignal.Notifications.permission;
                    if (!permission) {
                        console.log(' Requesting OneSignal notification permission on sign-in...');
                        await OneSignal.Notifications.requestPermission();
                    }

                    // Save player ID to profile
                    const userId = await OneSignal.User.PushSubscription.id;
                    if (userId && userId !== currentUser.onesignal_player_id) {
                        await supabase
                            .from('profiles')
                            .update({ onesignal_player_id: userId })
                            .eq('id', currentUser.id);

                        console.log(' OneSignal Player ID saved:', userId);
                        currentUser.onesignal_player_id = userId;
                    }
                });
            } catch (error) {
                console.error('Error setting up OneSignal:', error);
            }
        }

        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
        SecureStorage.setUserId(currentUser.id);
        SecureStorage.setSessionData(currentUser);

        showNotification('Signed in successfully!');

        // Load app data before processing pending chat (critical for iOS)
        await renderCircles();
        window.appState.circlesLoaded = true;

        await loadMatches();
        window.appState.matchesLoaded = true;

        // Mark app as initialized
        window.appState.initialized = true;
        window.appState.dataLoaded = true;
        console.log(' App initialized after signin:', JSON.stringify(window.appState));

        // Check for pending chat from notification click (takes priority)
        const hasPendingChat = sessionStorage.getItem('pending_chat_id') && sessionStorage.getItem('pending_chat_type');

        if (!hasPendingChat) {
            showPage('events');
        }

        updateProfile();
        await processInviteCode();
        await processPendingChat();

    } catch (error) {
        console.error('Signin error:', error);
        showNotification(error.message || 'Error signing in', 'error');
    }
}

window.signOut = async function() {
    if (!confirm('Are you sure you want to sign out?')) return;
    
    try {
        // Clean up all active subscriptions
        allActiveSubscriptions.forEach(sub => {
            if (sub) supabase.removeChannel(sub);
        });
        allActiveSubscriptions = [];
        
        await supabase.auth.signOut();
        currentUser = null;
        // SECURITY: Clear all stored user data (localStorage + sessionStorage)
        SecureStorage.clearAll();
        showPage('welcome');
        showNotification('Signed out successfully');
    } catch (error) {
        console.error('Sign out error:', error);
        showNotification('Error signing out', 'error');
    }
}

async function processInviteCode() {
    const inviteCode = InviteCodeStorage.get();
    if (!inviteCode || !currentUser) return;

    try {
        // Find circle by code
        const { data: circle, error: circleError } = await supabase
            .from('circles')
            .select('*')
            .eq('code', inviteCode)
            .single();

        if (circleError || !circle) {
            showNotification('Invalid invite code', 'error');
            InviteCodeStorage.clear();
            return;
        }

        // Check if user is already a member
        const { data: existingMember } = await supabase
            .from('circle_members')
            .select('*')
            .eq('circle_id', circle.id)
            .eq('profile_id', currentUser.id)
            .single();

        if (existingMember) {
            showNotification('You are already a member of this circle');
            InviteCodeStorage.clear();
            return;
        }

        // Check if user has available circles
        const { data: profile, error: profileError } = await supabase
            .from('profiles')
            .select('circles_purchased')
            .eq('id', currentUser.id)
            .single();

        if (profileError) throw profileError;

        const circlesPurchased = profile?.circles_purchased || 1;

        // Count user's current circles
        const { data: memberData, error: countError } = await supabase
            .from('circle_members')
            .select('circle_id')
            .eq('profile_id', currentUser.id);

        if (countError) throw countError;

        const currentCircleCount = memberData?.length || 0;

        // Check if user needs to purchase more circles
        if (currentCircleCount >= circlesPurchased) {
            // Clear any stale pending join data first
            const existingPendingJoin = localStorage.getItem('pendingCircleJoin');
            if (existingPendingJoin) {
                console.log(' Clearing stale pendingCircleJoin before setting new one');
                localStorage.removeItem('pendingCircleJoin');
            }

            // Save circle join intent to localStorage for after payment
            const pendingData = {
                code: inviteCode,
                timestamp: Date.now(),
                source: 'invite_link'
            };
            localStorage.setItem('pendingCircleJoin', JSON.stringify(pendingData));
            console.log(' Set pendingCircleJoin for invite code:', inviteCode);

            // Don't clear invite code yet - we'll need it if payment is cancelled
            await showPaymentModal();
            return;
        }

        // Add user to circle
        const { error: joinError } = await supabase
            .from('circle_members')
            .insert([{ circle_id: circle.id, profile_id: currentUser.id }]);

        if (joinError) throw joinError;

        showNotification('Successfully joined "' + circle.name + '"!');

        // Mark that user joined their first circle for PWA prompt
        markCircleJoined();

        await renderCircles(); // Refresh circles display

        // Refresh the activities page if user is on it
        const currentPage = localStorage.getItem('friendle_current_page');
        if (currentPage === 'activities') {
            await populateCircleSelector();
        }

        InviteCodeStorage.clear();

        // Show PWA install prompt after successful invite join
        // Brief delay to avoid interrupting the success moment
        setTimeout(() => {
            showPWAPrompt();
        }, 500);

    } catch (error) {
        console.error('Error processing invite:', error);
        showNotification('Error joining circle', 'error');
        InviteCodeStorage.clear();
    }
}

async function processPendingChat() {
    const pendingChatId = sessionStorage.getItem('pending_chat_id');
    const pendingChatType = sessionStorage.getItem('pending_chat_type');

    if (!pendingChatId || !pendingChatType || !currentUser) {
        console.log(' No pending chat to process:', { pendingChatId, pendingChatType, hasUser: !!currentUser });
        return;
    }

    console.log(' Processing pending chat from notification:', { pendingChatId, pendingChatType });
    console.log(' Device info:', { userAgent: navigator.userAgent, platform: navigator.platform });

    try {
        // Clear the stored values first
        sessionStorage.removeItem('pending_chat_id');
        sessionStorage.removeItem('pending_chat_type');

        // Wait for app to be fully ready with proper timeout (critical for iOS)
        console.log(' Waiting for app to be ready before opening chat...');
        console.log(' Current app state:', window.appState);

        try {
            await window.waitForAppReady(30000); // 30 second timeout for slower devices
            console.log(' App is ready, attempting to open chat');
            console.log(' App state after ready:', window.appState);
        } catch (error) {
            console.error(' Timeout waiting for app to be ready:', error);
            throw new Error('App initialization timeout - please try opening the notification again');
        }

        // Add retry logic with exponential backoff for robustness
        const maxRetries = 3;
        let lastError = null;

        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                console.log(` Attempt ${attempt}/${maxRetries} to open chat`);

                if (pendingChatType === 'match') {
                    // Match chat deprecated - redirect to matches page
                    await loadMatches();
                    showPage('matches');
                } else if (pendingChatType === 'event') {
                    await openEventChat(pendingChatId);
                } else if (pendingChatType === 'circle') {
                    await openCircleChat(pendingChatId);
                }

                console.log(' Opened pending chat successfully on attempt', attempt);
                return; // Success, exit function

            } catch (error) {
                lastError = error;
                console.error(` Attempt ${attempt} failed:`, error);
                console.error(' Error stack:', error.stack);

                if (attempt < maxRetries) {
                    // Exponential backoff: 500ms, 1000ms, 2000ms
                    const delayMs = 500 * Math.pow(2, attempt - 1);
                    console.log(` Waiting ${delayMs}ms before retry...`);
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                } else {
                    // Final attempt failed
                    console.error(' All retry attempts exhausted');
                    throw error;
                }
            }
        }

    } catch (error) {
        console.error(' Error opening pending chat after all retries:', error);
        console.error(' Final error stack:', error.stack);
        console.error(' Final app state:', window.appState);
        showNotification('Could not open chat. Please try again from the Matches tab.', 'error');
    }
}

        // Utility Functions
        function generateCode() { return Math.floor(100000 + Math.random() * 900000).toString(); }
	// Check if chat is muted and update button
async function updateMuteButton(matchId, eventId, circleId) {
    try {
        // Build query dynamically to handle nulls correctly
        let query = supabase
            .from('muted_chats')
            .select('id')
            .eq('profile_id', currentUser.id);

        // Use .is() for null values, .eq() for non-null
        if (matchId) {
            query = query.eq('match_id', matchId);
        } else {
            query = query.is('match_id', null);
        }

        if (eventId) {
            query = query.eq('event_id', eventId);
        } else {
            query = query.is('event_id', null);
        }

        if (circleId) {
            query = query.eq('circle_id', circleId);
        } else {
            query = query.is('circle_id', null);
        }

        const { data: muted, error } = await query.maybeSingle();

        if (error) {
            console.error('Error checking mute status:', error);
            return;
        }

        const btnText = document.getElementById('mute-btn-text');
        if (muted) {
            btnText.textContent = ' Unmute';
        } else {
            btnText.textContent = ' Mute';
        }
    } catch (error) {
        console.error('Error checking mute status:', error);
    }
}

// Toggle mute for current chat
window.toggleMuteChat = async function() {
    const currentChatContext = getCurrentChatContext();

    if (!currentChatContext || currentChatContext.type === 'none') {
        showNotification('No chat selected', 'error');
        return;
    }

    const matchId = currentChatContext.type === 'match' ? currentChatContext.id : null;
    const eventId = currentChatContext.type === 'event' ? currentChatContext.id : null;
    const circleId = currentChatContext.type === 'circle' ? currentChatContext.id : null;

    try {
        showLoader('Updating...');

        // Check if already muted
        let query = supabase
            .from('muted_chats')
            .select('id')
            .eq('profile_id', currentUser.id);

        // Use .is() for null values, .eq() for non-null
        if (matchId) {
            query = query.eq('match_id', matchId);
        } else {
            query = query.is('match_id', null);
        }

        if (eventId) {
            query = query.eq('event_id', eventId);
        } else {
            query = query.is('event_id', null);
        }

        if (circleId) {
            query = query.eq('circle_id', circleId);
        } else {
            query = query.is('circle_id', null);
        }

        const { data: existing, error: selectError } = await query.maybeSingle();

        if (selectError) {
            hideLoader();
            console.error('Error checking mute status:', selectError);
            showNotification('Error checking mute status', 'error');
            return;
        }

        if (existing) {
            // Unmute
            const { error: deleteError } = await supabase
                .from('muted_chats')
                .delete()
                .eq('id', existing.id);

            if (deleteError) {
                hideLoader();
                console.error('Error unmuting chat:', deleteError);
                showNotification('Error unmuting chat', 'error');
                return;
            }

            hideLoader();
            showNotification(' Chat unmuted - you\'ll receive notifications');
        } else {
            // Mute
            const { error: insertError } = await supabase
                .from('muted_chats')
                .insert({
                    profile_id: currentUser.id,
                    match_id: matchId,
                    event_id: eventId,
                    circle_id: circleId
                });

            if (insertError) {
                hideLoader();
                console.error('Error muting chat:', insertError);
                showNotification('Error muting chat', 'error');
                return;
            }

            hideLoader();
            showNotification(' Chat muted - you won\'t receive notifications');
        }

        // Update button text
        await updateMuteButton(matchId, eventId, circleId);

    } catch (error) {
        hideLoader();
        console.error('Error toggling mute:', error);
        showNotification('Error updating mute setting', 'error');
    }
}

// Utility function to escape HTML and prevent XSS
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function showNotification(message, type = 'success') {
    // Remove existing notification if any
    const existing = document.getElementById('app-notification');
    if (existing) existing.remove();

    const isDarkMode = document.body.classList.contains('dark-mode');
    const bgColor = type === 'error'
        ? '#dc3545'
        : type === 'warning'
            ? '#f59e0b'
            : '#10b981';

    const notification = document.createElement('div');
    notification.id = 'app-notification';
    notification.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: ${bgColor};
        color: white;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        z-index: 10000;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        animation: slideDown 0.3s ease;
        max-width: 90%;
        text-align: center;
    `;
    notification.textContent = message;
    document.body.appendChild(notification);

    // Auto-remove after 3 seconds
    setTimeout(() => {
        if (notification.parentNode) {
            notification.style.animation = 'fadeOut 0.3s ease';
            setTimeout(() => notification.remove(), 300);
        }
    }, 3000);
}

function showLoader(message = 'Loading...') {
    // Don't show loader if planning event modal is open (user is filling out the form)
    const planningEventModal = document.getElementById('planning-event-modal');
    const swipeActionModal = document.getElementById('swipe-action-modal');

    if (planningEventModal && planningEventModal.style.display === 'flex') {
        return; // Skip showing loader when planning modal is open
    }

    if (swipeActionModal && swipeActionModal.style.display === 'flex') {
        return; // Skip showing loader when swipe action modal is open
    }

    // Remove existing loader if any
    hideLoader();

    const isDarkMode = document.body.classList.contains('dark-mode');
    const bgColor = isDarkMode ? '#1a1a1e' : '#ffffff';
    const textColor = isDarkMode ? '#e5e5e7' : '#1a1a1a';

    const loader = document.createElement('div');
    loader.id = 'app-loader';
    loader.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0,0,0,0.7);
        backdrop-filter: blur(4px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
    `;
    loader.innerHTML = `
        <div style="background: ${bgColor}; padding: 40px; border-radius: 16px; text-align: center; box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3); animation: fadeIn 0.2s ease;">
            <div style="font-size: 3em; margin-bottom: 20px; animation: spin 1s linear infinite;"></div>
            <div style="font-size: 16px; color: ${textColor}; font-weight: 500;">${message}</div>
        </div>
    `;
    document.body.appendChild(loader);
}

function hideLoader() {
    const loader = document.getElementById('app-loader');
    if (loader) loader.remove();
}

function showNotificationPrompt() {
    const promptHtml = `
        <div class="modal-overlay" id="notification-prompt" style="display: flex;">
            <div class="modal-content" style="max-width: 400px; text-align: center;">
                <h3 style="margin-top: 0; color: #667eea;"> Stay Connected!</h3>
                <p style="line-height: 1.6; color: #666; margin: 20px 0;">
                    Get notified when friends message you or join your activities. 
                    You can turn this off anytime in settings.
                </p>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn btn-primary" onclick="enableNotifications()" style="flex: 1;">
                        Enable Notifications
                    </button>
                    <button class="btn btn-secondary" onclick="closeNotificationPrompt()" style="flex: 1;">
                        Maybe Later
                    </button>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', promptHtml);
}

window.enableNotifications = async function() {
    closeNotificationPrompt();

    // Use OneSignal API to properly request permission and subscribe
    if (window.OneSignalDeferred) {
        window.OneSignalDeferred.push(async function(OneSignal) {
            try {
                if (isSamsungInternet()) {
                    console.log(' SAMSUNG: Manual enable notifications clicked');
                    const prePermission = await OneSignal.Notifications.permission;
                    console.log(' SAMSUNG: Permission before request:', prePermission);
                }

                await OneSignal.Notifications.requestPermission();
                const permission = await OneSignal.Notifications.permission;

                if (isSamsungInternet()) {
                    console.log(' SAMSUNG: Permission after request:', permission);
                    const token = OneSignal.User.PushSubscription.token;
                    console.log(' SAMSUNG: Token after request:', token ? 'Present' : 'Missing');
                }

                if (permission) {
                    showNotification('Notifications enabled! ');

                    // Save player ID to profile
                    const userId = await OneSignal.User.PushSubscription.id;
                    if (userId && window.currentUser) {
                        await supabase
                            .from('profiles')
                            .update({ onesignal_player_id: userId })
                            .eq('id', currentUser.id);
                        console.log(' OneSignal Player ID saved:', userId);

                        if (isSamsungInternet()) {
                            console.log(' SAMSUNG: Player ID saved to database:', userId);
                        }
                    } else if (isSamsungInternet()) {
                        console.log(' SAMSUNG: WARNING - No player ID after enabling notifications');
                    }
                } else {
                    showNotification('Notification permission denied', 'error');
                }
            } catch (error) {
                console.error('Error enabling notifications:', error);
                showNotification('Error enabling notifications', 'error');
            }
        });
    }
}

// Samsung notification diagnostic test
window.testSamsungNotifications = async function() {
    const resultsDiv = document.getElementById('samsung-diagnostic-results');
    resultsDiv.style.display = 'block';
    resultsDiv.innerHTML = '<div style="color: #667eea;">Running diagnostics...</div>';

    const results = [];
    results.push('=== SAMSUNG NOTIFICATION DIAGNOSTIC ===\n');
    results.push(`Timestamp: ${new Date().toLocaleString()}\n`);
    results.push(`Browser: ${window.browserInfo.browserName} ${window.browserInfo.browserVersion}\n`);
    results.push(`Platform: ${navigator.platform}\n`);
    results.push(`PWA Mode: ${window.matchMedia('(display-mode: standalone)').matches ? 'Yes' : 'No'}\n`);
    results.push(`WebAPK Mode: ${window.isWebAPK ? 'YES ' : 'No'}\n`);
    results.push(`Referrer: ${document.referrer || 'None'}\n`);
    results.push(`User Agent: ${navigator.userAgent}\n\n`);

    // WebAPK warning
    if (window.isWebAPK) {
        results.push(' WEBAPK DETECTED: App is installed as WebAPK\n');
        results.push('This may cause notification issues. See recommendations below.\n\n');
    }

    try {
        // Test OneSignal availability
        if (window.OneSignalDeferred) {
            results.push(' OneSignal SDK loaded\n');

            await new Promise((resolve) => {
                window.OneSignalDeferred.push(async function(OneSignal) {
                    try {
                        // Check permission
                        const permission = await OneSignal.Notifications.permission;
                        results.push(`Permission State: ${permission ? ' Granted' : ' Not Granted'}\n`);

                        // Check push support
                        const isPushSupported = await OneSignal.Notifications.isPushSupported();
                        results.push(`Push Supported: ${isPushSupported ? ' Yes' : ' No'}\n`);

                        // Check subscription
                        const isSubscribed = OneSignal.User.PushSubscription.optedIn;
                        results.push(`Subscribed: ${isSubscribed ? ' Yes' : ' No'}\n`);

                        // Check player ID
                        const playerId = OneSignal.User.PushSubscription.id;
                        results.push(`Player ID: ${playerId ? ' ' + playerId : ' Not Set'}\n`);

                        // Check token
                        const token = OneSignal.User.PushSubscription.token;
                        results.push(`Push Token: ${token ? ' Present (' + token.substring(0, 20) + '...)' : ' Missing'}\n\n`);

                        // Check database
                        if (window.currentUser) {
                            results.push(`User ID: ${currentUser.id}\n`);
                            results.push(`DB Player ID: ${currentUser.onesignal_player_id || ' Not Set'}\n`);

                            // Verify database record
                            const { data, error } = await supabase
                                .from('profiles')
                                .select('onesignal_player_id, notify_new_matches, notify_event_joins, notify_chat_messages')
                                .eq('id', currentUser.id)
                                .single();

                            if (data) {
                                results.push(`\nNotification Preferences:\n`);
                                results.push(`- New Matches: ${data.notify_new_matches ? '' : ''}\n`);
                                results.push(`- Event Joins: ${data.notify_event_joins ? '' : ''}\n`);
                                results.push(`- Chat Messages: ${data.notify_chat_messages ? '' : ''}\n`);
                            }
                        } else {
                            results.push(' No user logged in\n');
                        }

                        // Recommendations
                        results.push('\n=== RECOMMENDATIONS ===\n');

                        // WebAPK-specific recommendations
                        if (window.isWebAPK) {
                            results.push('\n WEBAPK NOTIFICATION FIX:\n');
                            results.push('Samsung installed this PWA as a WebAPK (appears in Play Store).\n');
                            results.push('This prevents web push notifications from working properly.\n\n');
                            results.push('TO FIX (RECOMMENDED):\n');
                            results.push('1. Remove app from home screen (uninstall WebAPK)\n');
                            results.push('2. Open Samsung Internet browser\n');
                            results.push('3. Go to https://friendle.app\n');
                            results.push('4. Use the app from the browser (bookmark it)\n');
                            results.push('5. OR: Install PWA again but from Chrome browser instead\n\n');
                            results.push('WHY: Samsung\'s WebAPK doesn\'t support OneSignal web push.\n');
                            results.push('Using the browser version works perfectly!\n\n');
                        }

                        if (!permission) {
                            results.push(' ISSUE: Notification permission not granted\n');
                            results.push('    Tap "Enable Notifications" button above\n');
                        }
                        if (!token) {
                            results.push(' ISSUE: No push token registered\n');
                            if (!window.isWebAPK) {
                                results.push('    Try clearing browser cache and re-enabling notifications\n');
                                results.push('    Check if app is in "Sleeping Apps" (Settings  Battery)\n');
                            } else {
                                results.push('    This is expected with WebAPK. See fix above.\n');
                            }
                        }
                        if (playerId && currentUser && currentUser.onesignal_player_id !== playerId) {
                            results.push(' WARNING: Player ID mismatch between OneSignal and database\n');
                            results.push('    Attempting to sync...\n');
                            await supabase
                                .from('profiles')
                                .update({ onesignal_player_id: playerId })
                                .eq('id', currentUser.id);
                            results.push('    Synced!\n');
                        }
                        if (permission && token && playerId) {
                            results.push(' All checks passed! Notifications should be working.\n');
                            if (!window.isWebAPK) {
                                results.push('   If you still don\'t receive notifications:\n');
                                results.push('   1. Check "Sleeping Apps" in Battery settings\n');
                                results.push('   2. Ensure "Allow background activity" is enabled\n');
                                results.push('   3. Try reinstalling the PWA\n');
                            }
                        }

                    } catch (err) {
                        results.push(`\n ERROR during diagnostics: ${err.message}\n`);
                        console.error('Samsung diagnostic error:', err);
                    }

                    resultsDiv.innerHTML = '<pre style="margin: 0; white-space: pre-wrap; word-wrap: break-word;">' +
                                          results.join('') + '</pre>';
                    resolve();
                });
            });
        } else {
            results.push(' OneSignal SDK not loaded\n');
            resultsDiv.innerHTML = '<pre style="margin: 0; white-space: pre-wrap;">' + results.join('') + '</pre>';
        }
    } catch (error) {
        results.push(`\n FATAL ERROR: ${error.message}\n`);
        resultsDiv.innerHTML = '<pre style="margin: 0; white-space: pre-wrap;">' + results.join('') + '</pre>';
        console.error('Samsung diagnostic fatal error:', error);
    }
}

// PWA Install Prompt
let deferredPrompt = null;

// Capture the beforeinstallprompt event (Android/Chrome)
window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    console.log(' beforeinstallprompt event captured');
});

// Detect iOS Safari
function isIOSSafari() {
    const ua = window.navigator.userAgent;
    const iOS = !!ua.match(/iPad/i) || !!ua.match(/iPhone/i);
    const webkit = !!ua.match(/WebKit/i);
    const iOSSafari = iOS && webkit && !ua.match(/CriOS/i);
    return iOSSafari;
}

// Check if app is already installed
function isAppInstalled() {
    return window.matchMedia('(display-mode: standalone)').matches ||
           window.navigator.standalone === true;
}

// Check if we should show the PWA install prompt
function shouldShowPWAPrompt(forceShow = false) {
    // Don't show if already installed
    if (isAppInstalled()) {
        console.log(' PWA prompt: App already installed');
        return false;
    }

    // Check if dismissed recently (within 7 days)
    const dismissedAt = localStorage.getItem('pwa_prompt_dismissed_at');
    if (dismissedAt) {
        const daysSinceDismissed = (Date.now() - parseInt(dismissedAt)) / (1000 * 60 * 60 * 24);
        if (daysSinceDismissed < 7) {
            console.log(` PWA prompt: Dismissed ${Math.floor(daysSinceDismissed)} days ago`);
            return false;
        }
    }

    // If forceShow is true (e.g., on sign-in page), skip visit count check
    if (forceShow) {
        console.log(' PWA prompt: Force show on sign-in page');
        return true;
    }

    // Track visits
    const visitCount = parseInt(localStorage.getItem('pwa_visit_count') || '0');
    const hasJoinedCircle = localStorage.getItem('pwa_has_joined_circle') === 'true';

    console.log('PWA prompt check:', { visitCount, hasJoinedCircle });

    // Show if user has joined their first circle OR on their first visit
    return hasJoinedCircle || visitCount >= 1;
}

// Track page visits
function trackPWAVisit() {
    const visitCount = parseInt(localStorage.getItem('pwa_visit_count') || '0');
    localStorage.setItem('pwa_visit_count', (visitCount + 1).toString());
    console.log(` PWA visit tracked: ${visitCount + 1}`);
}

// Mark that user joined a circle
function markCircleJoined() {
    localStorage.setItem('pwa_has_joined_circle', 'true');
    console.log(' First circle join marked for PWA prompt');
}

// Show PWA install prompt
function showPWAPrompt(forceShow = false) {
    if (!shouldShowPWAPrompt(forceShow)) {
        return;
    }

    const isIOS = isIOSSafari();

    // For iOS, show instructions modal
    if (isIOS) {
        showIOSInstallInstructions();
        return;
    }

    // For Android/Chrome with beforeinstallprompt support
    if (!deferredPrompt) {
        console.log(' PWA prompt: No deferred prompt available');
        return;
    }

    // Don't show if banner already exists
    if (document.getElementById('pwa-install-banner')) {
        console.log(' PWA prompt: Banner already visible');
        return;
    }

    const bannerHTML = `
        <div class="pwa-install-banner" id="pwa-install-banner">
            <button class="pwa-banner-close" onclick="dismissPWAPrompt()" aria-label="Close"></button>
            <div class="pwa-banner-content">
                <div class="pwa-banner-icon"></div>
                <div class="pwa-banner-text">
                    <div class="pwa-banner-title">Want to add Friendle as an app?</div>
                    <div class="pwa-banner-subtitle">Add to home screen for quick access. Note: You'll need to log in again.</div>
                </div>
            </div>
            <div class="pwa-banner-buttons">
                <button class="pwa-banner-btn pwa-banner-btn-primary" onclick="installPWA()">
                    Add to Home Screen
                </button>
                <button class="pwa-banner-btn pwa-banner-btn-secondary" onclick="dismissPWAPrompt()">
                    Maybe Later
                </button>
            </div>
        </div>
    `;

    document.body.insertAdjacentHTML('beforeend', bannerHTML);

    // Animate in after brief delay for smooth transition
    setTimeout(() => {
        const banner = document.getElementById('pwa-install-banner');
        if (banner) {
            banner.classList.add('show');
        }
    }, 150);

    console.log(' PWA install banner shown');
}

// Show iOS installation instructions in modal
function showIOSInstallInstructions() {
    // Don't show if modal already exists
    if (document.getElementById('pwa-ios-modal')) {
        console.log(' PWA iOS prompt: Modal already visible');
        return;
    }

    const modalHTML = `
        <div class="modal-overlay" id="pwa-ios-modal" style="display: flex;">
            <div class="modal-content" style="max-width: 400px;">
                <h3 style="margin-top: 0; color: var(--primary-color);"> Want to add Friendle as an app?</h3>
                <p style="line-height: 1.6; color: var(--text-secondary); margin: 15px 0;">
                    Add Friendle to your home screen for the best experience!
                </p>
                <p style="line-height: 1.6; color: var(--text-secondary); margin: 15px 0; font-size: 14px; opacity: 0.8;">
                    <strong>Note:</strong> You'll need to log in again after installing.
                </p>
                <div class="pwa-ios-instructions">
                    <div class="pwa-ios-step">
                        <div class="pwa-ios-step-number">1</div>
                        <div>Tap the Share button <strong></strong> at the bottom</div>
                    </div>
                    <div class="pwa-ios-step">
                        <div class="pwa-ios-step-number">2</div>
                        <div>Scroll down and tap <strong>"Add to Home Screen"</strong></div>
                    </div>
                    <div class="pwa-ios-step">
                        <div class="pwa-ios-step-number">3</div>
                        <div>Tap <strong>"Add"</strong> in the top right</div>
                    </div>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn btn-secondary" onclick="dismissPWAPrompt()" style="flex: 1;">
                        Maybe Later
                    </button>
                </div>
            </div>
        </div>
    `;

    document.body.insertAdjacentHTML('beforeend', modalHTML);
    console.log(' iOS install instructions shown');
}

// Install PWA (Android/Chrome)
window.installPWA = async function() {
    if (!deferredPrompt) {
        console.log(' No deferred prompt available');
        return;
    }

    // Show the install prompt
    deferredPrompt.prompt();

    // Wait for the user to respond to the prompt
    const { outcome } = await deferredPrompt.userChoice;
    console.log(`User response to install prompt: ${outcome}`);

    if (outcome === 'accepted') {
        showNotification('App installed! ');
    }

    // Clear the deferred prompt
    deferredPrompt = null;

    // Close the banner
    closePWABanner();
}

// Dismiss PWA prompt
window.dismissPWAPrompt = function() {
    // Store dismissal timestamp
    localStorage.setItem('pwa_prompt_dismissed_at', Date.now().toString());
    console.log('PWA prompt dismissed for 7 days');

    // Close banner or modal
    closePWABanner();

    const iosModal = document.getElementById('pwa-ios-modal');
    if (iosModal) {
        iosModal.remove();
    }
}

// Close PWA banner with animation
function closePWABanner() {
    const banner = document.getElementById('pwa-install-banner');
    if (banner) {
        banner.classList.remove('show');
        setTimeout(() => banner.remove(), 300);
    }
}

function closeNotificationPrompt() {
    const prompt = document.getElementById('notification-prompt');
    if (prompt) prompt.remove();
}

        // Profile Management & Avatar Selection
       window.createProfile = async function() {
  const name = document.getElementById('name').value.trim();
  const selectedAvatar = document.querySelector('.avatar-option.selected');
  if (!name || !selectedAvatar) {
    return showNotification('Please enter a name and select an avatar', 'error');
  }

  // Auto-detect user's timezone
  const detectedTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone || 'America/Los_Angeles';

  // Create profile object with UUID
  const profileData = {
    id: generateUUID(), // Use UUID instead of letting Supabase auto-generate
    name,
    avatar: selectedAvatar.dataset.avatar,
    timezone: detectedTimezone
  };

  // Insert into Supabase
  const { data, error } = await supabase
    .from('profiles')
    .insert([profileData])
    .select()
    .single();

  if (error) {
    console.error(error);
    return showNotification('Could not create profile', 'error');
  }

  currentUser = data; // store the profile from DB
  // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser); // keep local copy for session
  showPage('events');
  updateProfile();
  processInvite();
}

        function updateProfile() {
            if (currentUser) {
                document.getElementById('profile-name').textContent = currentUser.name;

                const avatarElement = document.getElementById('profile-avatar');
                const removePictureBtn = document.getElementById('remove-picture-btn');

                // Check if avatar is a URL or emoji
                if (currentUser.avatar && currentUser.avatar.startsWith('http')) {
                    // It's an image URL
                    avatarElement.innerHTML = `<img src="${currentUser.avatar}" alt="Profile picture" class="avatar-display">`;
                    avatarElement.classList.remove('emoji');
                    if (removePictureBtn) removePictureBtn.style.display = 'inline-block';
                } else {
                    // It's an emoji
                    avatarElement.textContent = currentUser.avatar || '';
                    avatarElement.classList.add('emoji');
                    if (removePictureBtn) removePictureBtn.style.display = 'none';
                }

                loadMinimumGroupSize();
            }
        }

async function loadMinimumGroupSize() {
    if (!currentUser) return;

    // Load all notification preferences
    const reminderToggle = document.getElementById('event-reminders-toggle');
    if (reminderToggle) {
        reminderToggle.checked = currentUser.event_reminders_enabled || false;
    }

    // Load timezone preference
    const timezoneSelect = document.getElementById('timezone-select');
    if (timezoneSelect) {
        const userTimezone = currentUser.timezone || 'America/Los_Angeles';

        // Check if user's timezone is in the dropdown
        const existingOption = Array.from(timezoneSelect.options).find(opt => opt.value === userTimezone);

        // If not in dropdown, add it dynamically
        if (!existingOption) {
            const newOption = document.createElement('option');
            newOption.value = userTimezone;
            newOption.textContent = userTimezone;
            timezoneSelect.appendChild(newOption);
        }

        timezoneSelect.value = userTimezone;
    }

    const newMatchToggle = document.getElementById('new-match-toggle');
    if (newMatchToggle) {
        newMatchToggle.checked = currentUser.notify_new_matches !== false; // Default true
    }

    const eventJoinToggle = document.getElementById('event-join-toggle');
    if (eventJoinToggle) {
        eventJoinToggle.checked = currentUser.notify_event_joins !== false; // Default true
    }

    const inactivityToggle = document.getElementById('inactivity-warnings-toggle');
    if (inactivityToggle) {
        inactivityToggle.checked = currentUser.notify_inactivity_warnings !== false; // Default true
    }

    const chatToggle = document.getElementById('chat-messages-toggle');
    if (chatToggle) {
        chatToggle.checked = currentUser.notify_chat_messages !== false; // Default true
    }

    const notifyAt4Toggle = document.getElementById('notify-at-4-toggle');
    if (notifyAt4Toggle) {
        notifyAt4Toggle.checked = currentUser.notify_at_4 !== false; // Default true
    }

    const notifyAt8Toggle = document.getElementById('notify-at-8-toggle');
    if (notifyAt8Toggle) {
        notifyAt8Toggle.checked = currentUser.notify_at_8 !== false; // Default true
    }

    // Load dark mode preference
    const darkModeToggle = document.getElementById('dark-mode-toggle');
    if (darkModeToggle) {
        const isDarkMode = currentUser.dark_mode_enabled || false;
        darkModeToggle.checked = isDarkMode;
        // Apply dark mode on load
        if (isDarkMode) {
            document.body.classList.add('dark-mode');
        }
    }
}

window.openUpdateNameModal = function() {
    const modal = document.getElementById('update-name-modal-overlay');
    const input = document.getElementById('modal-new-username');
    input.value = currentUser.name || '';
    modal.style.display = 'flex';
};

window.closeUpdateNameModal = function() {
    const modal = document.getElementById('update-name-modal-overlay');
    modal.style.display = 'none';
};

window.changeUsername = async function() {
    const newName = document.getElementById('modal-new-username').value.trim();

    if (!newName) {
        return showNotification('Please enter a name', 'error');
    }

    try {
        const { error } = await supabase
            .from('profiles')
            .update({ name: newName })
            .eq('id', currentUser.id);

        if (error) throw error;

        currentUser.name = newName;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser);

        updateProfile();
        closeUpdateNameModal();

        showNotification('Name updated successfully!');

    } catch (error) {
        console.error('Error changing username:', error);
        showNotification('Error updating name', 'error');
    }
}

window.uploadProfilePicture = async function(event) {
    const file = event.target.files[0];

    if (!file) {
        return;
    }

    // SECURITY: Rate limiting - max 3 uploads per minute
    if (!RateLimiter.checkLimit('file_upload', 3, 60000)) {
        const remaining = RateLimiter.getRemaining('file_upload', 3, 60000);
        const waitTime = remaining === 0 ? '1 minute' : `${60 - remaining * 20} seconds`;
        return showNotification(`Too many uploads. Please wait ${waitTime} before trying again.`, 'error');
    }

    // SECURITY: Comprehensive file upload validation

    // 1. Validate file extension (whitelist only safe formats)
    const allowedExtensions = ['jpg', 'jpeg', 'png', 'webp'];
    const fileExt = file.name.split('.').pop().toLowerCase();

    if (!allowedExtensions.includes(fileExt)) {
        return showNotification(`Only ${allowedExtensions.join(', ').toUpperCase()} images are allowed`, 'error');
    }

    // 2. Validate MIME type matches extension
    const expectedMimeTypes = {
        'jpg': 'image/jpeg',
        'jpeg': 'image/jpeg',
        'png': 'image/png',
        'webp': 'image/webp'
    };

    const expectedMime = expectedMimeTypes[fileExt];
    if (!file.type || file.type !== expectedMime) {
        return showNotification('File type does not match extension. Please select a valid image.', 'error');
    }

    // 3. Validate file size (max 5MB)
    if (file.size > 5 * 1024 * 1024) {
        return showNotification('Image must be less than 5MB', 'error');
    }

    // 4. Validate image dimensions (max 4096x4096)
    // Create a promise to load and validate the image
    const validateImageDimensions = new Promise((resolve, reject) => {
        const img = new Image();
        const url = URL.createObjectURL(file);

        img.onload = function() {
            URL.revokeObjectURL(url); // Clean up

            if (this.width > 4096 || this.height > 4096) {
                reject(new Error('Image dimensions must not exceed 4096x4096 pixels'));
            } else if (this.width < 10 || this.height < 10) {
                reject(new Error('Image is too small. Minimum size is 10x10 pixels'));
            } else {
                resolve({ width: this.width, height: this.height });
            }
        };

        img.onerror = function() {
            URL.revokeObjectURL(url);
            reject(new Error('Invalid image file. File may be corrupted.'));
        };

        img.src = url;
    });

    try {
        // Wait for dimension validation to complete
        showLoader('Validating image...');
        await validateImageDimensions;

        showLoader('Uploading profile picture...');
        const fileName = `${currentUser.id}/avatar.${fileExt}`;

        // Delete old avatar if exists
        const { data: existingFiles } = await supabase.storage
            .from('avatars')
            .list(currentUser.id);

        if (existingFiles && existingFiles.length > 0) {
            for (const oldFile of existingFiles) {
                await supabase.storage
                    .from('avatars')
                    .remove([`${currentUser.id}/${oldFile.name}`]);
            }
        }

        // Upload new avatar
        const { error: uploadError } = await supabase.storage
            .from('avatars')
            .upload(fileName, file, {
                cacheControl: '3600',
                upsert: true
            });

        if (uploadError) throw uploadError;

        // Get public URL
        const { data: urlData } = supabase.storage
            .from('avatars')
            .getPublicUrl(fileName);

        const avatarUrl = urlData.publicUrl;

        // Update profile with new avatar URL
        const { error: updateError } = await supabase
            .from('profiles')
            .update({ avatar: avatarUrl })
            .eq('id', currentUser.id);

        if (updateError) throw updateError;

        // Update current user and UI
        currentUser.avatar = avatarUrl;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser);

        updateProfile();
        hideLoader();
        showNotification('Profile picture updated successfully!');

    } catch (error) {
        console.error('Error uploading profile picture:', error);
        hideLoader();
        // Show specific error message if validation failed, otherwise generic error
        const errorMessage = error.message || 'Error uploading profile picture';
        showNotification(errorMessage, 'error');
    }
}

window.removeProfilePicture = async function() {
    if (!confirm('Are you sure you want to remove your profile picture?')) {
        return;
    }

    try {
        showLoader('Removing profile picture...');

        // Delete avatar from storage if it's a URL
        if (currentUser.avatar && currentUser.avatar.includes('supabase')) {
            const { data: existingFiles } = await supabase.storage
                .from('avatars')
                .list(currentUser.id);

            if (existingFiles && existingFiles.length > 0) {
                for (const file of existingFiles) {
                    await supabase.storage
                        .from('avatars')
                        .remove([`${currentUser.id}/${file.name}`]);
                }
            }
        }

        // Set default emoji avatar
        const defaultAvatar = '';

        // Update profile with default avatar
        const { error: updateError } = await supabase
            .from('profiles')
            .update({ avatar: defaultAvatar })
            .eq('id', currentUser.id);

        if (updateError) throw updateError;

        // Update current user and UI
        currentUser.avatar = defaultAvatar;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser);

        updateProfile();
        hideLoader();
        showNotification('Profile picture removed');

    } catch (error) {
        console.error('Error removing profile picture:', error);
        hideLoader();
        showNotification('Error removing profile picture', 'error');
    }
}

// Camera functionality
let cameraStream = null;
let cameraContext = 'register'; // 'register' or 'settings'

window.openRegisterCamera = async function() {
    cameraContext = 'register';
    await openCameraModal();
}

window.openSettingsCamera = async function() {
    cameraContext = 'settings';
    await openCameraModal();
}

async function openCameraModal() {
    const modal = document.getElementById('camera-modal');
    const video = document.getElementById('camera-video');

    try {
        // Request camera access
        cameraStream = await navigator.mediaDevices.getUserMedia({
            video: {
                facingMode: 'user',
                width: { ideal: 1280 },
                height: { ideal: 720 }
            }
        });

        video.srcObject = cameraStream;
        modal.style.display = 'flex';
    } catch (error) {
        console.error('Error accessing camera:', error);
        if (error.name === 'NotAllowedError') {
            showNotification('Camera access denied. Please enable camera permissions in your browser.', 'error');
        } else if (error.name === 'NotFoundError') {
            showNotification('No camera found on this device.', 'error');
        } else {
            showNotification('Error accessing camera: ' + error.message, 'error');
        }
    }
}

window.closeCameraModal = function() {
    const modal = document.getElementById('camera-modal');
    const video = document.getElementById('camera-video');

    // Stop camera stream
    if (cameraStream) {
        cameraStream.getTracks().forEach(track => track.stop());
        cameraStream = null;
    }

    video.srcObject = null;
    modal.style.display = 'none';
}

window.capturePhoto = function() {
    const video = document.getElementById('camera-video');
    const canvas = document.getElementById('camera-canvas');

    // Set canvas dimensions to match video
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    // Draw video frame to canvas
    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    // Convert canvas to blob
    canvas.toBlob(async (blob) => {
        if (!blob) {
            showNotification('Error capturing photo', 'error');
            return;
        }

        // Close camera modal
        closeCameraModal();

        // Create a file from the blob
        const file = new File([blob], 'camera-photo.jpg', { type: 'image/jpeg' });

        // Handle the captured photo based on context
        if (cameraContext === 'register') {
            await handleRegisterPhotoCapture(file);
        } else {
            await handleSettingsPhotoCapture(file);
        }
    }, 'image/jpeg', 0.9);
}

// Registration photo handling
window.registerPhotoFile = null;

window.handleRegisterPhotoUpload = async function(event) {
    const file = event.target.files[0];
    if (!file) return;

    await handleRegisterPhotoCapture(file);
}

async function handleRegisterPhotoCapture(file) {
    // Validate file
    const allowedExtensions = ['jpg', 'jpeg', 'png', 'webp'];
    const fileExt = file.name.split('.').pop().toLowerCase();

    if (!allowedExtensions.includes(fileExt) && file.type === 'image/jpeg') {
        // Allow camera captures which are always JPEG
    } else if (!allowedExtensions.includes(fileExt)) {
        return showNotification(`Only ${allowedExtensions.join(', ').toUpperCase()} images are allowed`, 'error');
    }

    // Validate file size (max 5MB)
    if (file.size > 5 * 1024 * 1024) {
        return showNotification('Image must be less than 5MB', 'error');
    }

    // Validate image dimensions
    const validateImageDimensions = new Promise((resolve, reject) => {
        const img = new Image();
        const url = URL.createObjectURL(file);

        img.onload = function() {
            URL.revokeObjectURL(url);

            if (this.width > 4096 || this.height > 4096) {
                reject(new Error('Image dimensions must not exceed 4096x4096 pixels'));
            } else if (this.width < 10 || this.height < 10) {
                reject(new Error('Image is too small. Minimum size is 10x10 pixels'));
            } else {
                resolve({ width: this.width, height: this.height, url: URL.createObjectURL(file) });
            }
        };

        img.onerror = function() {
            URL.revokeObjectURL(url);
            reject(new Error('Invalid image file. File may be corrupted.'));
        };

        img.src = url;
    });

    try {
        const { url: previewUrl } = await validateImageDimensions;

        // Store the file for upload during registration
        window.registerPhotoFile = file;

        // Update preview
        const preview = document.getElementById('register-profile-preview');
        const display = document.getElementById('register-avatar-display');

        display.innerHTML = '';
        display.style.fontSize = '0';
        preview.style.backgroundImage = `url(${previewUrl})`;
        preview.style.backgroundSize = 'cover';
        preview.style.backgroundPosition = 'center';

        // Deselect any emoji avatars
        const avatars = document.querySelectorAll('#register-form .avatar-option');
        avatars.forEach(a => a.classList.remove('selected'));

        showNotification('Photo ready! Complete the form to create your account.');
    } catch (error) {
        console.error('Error validating image:', error);
        showNotification(error.message || 'Error processing image', 'error');
    }
}

async function handleSettingsPhotoCapture(file) {
    // Create a fake event object for uploadProfilePicture
    const fakeEvent = {
        target: {
            files: [file]
        }
    };

    await uploadProfilePicture(fakeEvent);
}

// Photo menu functionality
let photoMenuContext = 'settings'; // 'settings' or 'register'

window.showSettingsPhotoMenu = function(event) {
    event.stopPropagation();
    photoMenuContext = 'settings';

    // Show remove option if user has a photo
    const hasPhoto = currentUser && currentUser.avatar && currentUser.avatar.includes('supabase');
    const removeOption = document.getElementById('photo-menu-remove');
    if (removeOption) {
        removeOption.style.display = hasPhoto ? 'block' : 'none';
    }

    showPhotoMenuAtPosition(event.clientX, event.clientY);
}

window.showRegisterPhotoMenu = function(event) {
    event.stopPropagation();
    photoMenuContext = 'register';

    // Hide remove option for registration
    const removeOption = document.getElementById('photo-menu-remove');
    if (removeOption) {
        removeOption.style.display = 'none';
    }

    showPhotoMenuAtPosition(event.clientX, event.clientY);
}

function showPhotoMenuAtPosition(x, y) {
    const menu = document.getElementById('photo-menu');
    menu.style.display = 'block';

    // Position the menu
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';

    // Adjust if menu goes off screen
    setTimeout(() => {
        const rect = menu.getBoundingClientRect();
        if (rect.right > window.innerWidth) {
            menu.style.left = (window.innerWidth - rect.width - 10) + 'px';
        }
        if (rect.bottom > window.innerHeight) {
            menu.style.top = (window.innerHeight - rect.height - 10) + 'px';
        }
    }, 0);

    // Close menu when clicking outside
    setTimeout(() => {
        document.addEventListener('click', closePhotoMenu, { once: true });
    }, 0);
}

function closePhotoMenu() {
    const menu = document.getElementById('photo-menu');
    menu.style.display = 'none';
}

// Chat Photo Menu Functions
function showChatPhotoMenu(x, y) {
    const menu = document.getElementById('chat-photo-menu');
    menu.style.display = 'block';

    // Position the menu
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';

    // Adjust if menu goes off screen
    setTimeout(() => {
        const rect = menu.getBoundingClientRect();
        if (rect.right > window.innerWidth) {
            menu.style.left = (window.innerWidth - rect.width - 10) + 'px';
        }
        if (rect.bottom > window.innerHeight) {
            menu.style.top = (window.innerHeight - rect.height - 10) + 'px';
        }
        // Ensure menu doesn't go above viewport
        if (rect.top < 0) {
            menu.style.top = '10px';
        }
    }, 0);

    // Close menu when clicking outside
    setTimeout(() => {
        document.addEventListener('click', closeChatPhotoMenu, { once: true });
    }, 0);
}

function closeChatPhotoMenu() {
    const menu = document.getElementById('chat-photo-menu');
    menu.style.display = 'none';
}

window.handleChatPhotoMenuAction = function(action) {
    closeChatPhotoMenu();

    if (action === 'camera') {
        takePhotoFromCamera();
    } else if (action === 'library') {
        chooseFromLibrary();
    }
}

// Take photo from camera
function takePhotoFromCamera() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.capture = 'environment'; // Use rear camera on mobile

    input.onchange = async function(event) {
        const file = event.target.files[0];
        await uploadChatPhoto(file);
    };

    input.click();
}

// Choose photo from library
function chooseFromLibrary() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    // No capture attribute - this will open the file picker/gallery

    input.onchange = async function(event) {
        const file = event.target.files[0];
        await uploadChatPhoto(file);
    };

    input.click();
}

window.handlePhotoMenuAction = async function(action) {
    closePhotoMenu();

    if (action === 'camera') {
        if (photoMenuContext === 'settings') {
            await openSettingsCamera();
        } else {
            await openRegisterCamera();
        }
    } else if (action === 'upload') {
        if (photoMenuContext === 'settings') {
            document.getElementById('profile-picture-input').click();
        } else {
            document.getElementById('register-photo-input').click();
        }
    } else if (action === 'remove') {
        // Show avatar selection modal
        showAvatarSelectionModal();
    }
}

// Avatar selection modal
window.showAvatarSelectionModal = function() {
    const modal = document.getElementById('avatar-selection-modal');
    modal.style.display = 'flex';

    // Set up click handlers for avatar options in the modal
    const avatars = modal.querySelectorAll('.avatar-option');
    avatars.forEach(option => {
        option.addEventListener('click', function() {
            avatars.forEach(o => o.classList.remove('selected'));
            this.classList.add('selected');
        });
    });
}

window.closeAvatarSelectionModal = function() {
    const modal = document.getElementById('avatar-selection-modal');
    modal.style.display = 'none';

    // Clear selections
    const avatars = modal.querySelectorAll('.avatar-option');
    avatars.forEach(o => o.classList.remove('selected'));
}

window.confirmAvatarSelection = async function() {
    const modal = document.getElementById('avatar-selection-modal');
    const selectedAvatar = modal.querySelector('.avatar-option.selected');

    if (!selectedAvatar) {
        showNotification('Please select an avatar', 'error');
        return;
    }

    const avatarEmoji = selectedAvatar.dataset.avatar;

    try {
        showLoader('Updating profile picture...');

        // Delete avatar from storage if it exists
        if (currentUser.avatar && currentUser.avatar.includes('supabase')) {
            const { data: existingFiles } = await supabase.storage
                .from('avatars')
                .list(currentUser.id);

            if (existingFiles && existingFiles.length > 0) {
                for (const file of existingFiles) {
                    await supabase.storage
                        .from('avatars')
                        .remove([`${currentUser.id}/${file.name}`]);
                }
            }
        }

        // Update profile with selected avatar
        const { error: updateError } = await supabase
            .from('profiles')
            .update({ avatar: avatarEmoji })
            .eq('id', currentUser.id);

        if (updateError) throw updateError;

        // Update current user and UI
        currentUser.avatar = avatarEmoji;
        SecureStorage.setUserId(currentUser.id);
        SecureStorage.setSessionData(currentUser);

        updateProfile();
        hideLoader();
        closeAvatarSelectionModal();
        showNotification('Avatar updated successfully!');

    } catch (error) {
        console.error('Error updating avatar:', error);
        hideLoader();
        showNotification('Error updating avatar', 'error');
    }
}

window.toggleEventReminders = async function() {
    const toggle = document.getElementById('event-reminders-toggle');
    const isEnabled = toggle.checked;

    try {
        showLoader('Updating settings...');

        const { error } = await supabase
            .from('profiles')
            .update({ event_reminders_enabled: isEnabled })
            .eq('id', currentUser.id);

        if (error) throw error;

        currentUser.event_reminders_enabled = isEnabled;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser);

        hideLoader();
        showNotification(isEnabled ? ' Event reminders enabled!' : ' Event reminders disabled');

    } catch (error) {
        hideLoader();
        console.error('Error toggling event reminders:', error);
        showNotification('Error updating setting', 'error');
        // Revert toggle on error
        toggle.checked = !isEnabled;
    }
}

window.updateTimezone = async function() {
    const select = document.getElementById('timezone-select');
    const timezone = select.value;

    try {
        showLoader('Updating timezone...');

        const { error } = await supabase
            .from('profiles')
            .update({ timezone: timezone })
            .eq('id', currentUser.id);

        if (error) throw error;

        currentUser.timezone = timezone;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser);

        hideLoader();
        showNotification('Timezone updated!');

    } catch (error) {
        hideLoader();
        console.error('Error updating timezone:', error);
        showNotification('Error updating timezone', 'error');
    }
}

window.detectAndUpdateTimezone = async function() {
    try {
        showLoader('Detecting timezone...');

        // Detect timezone using browser's Intl API
        const detectedTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;

        if (!detectedTimezone) {
            throw new Error('Could not detect timezone');
        }

        // Update the dropdown to show detected timezone
        const select = document.getElementById('timezone-select');

        // Check if the detected timezone is already in the dropdown
        const existingOption = Array.from(select.options).find(opt => opt.value === detectedTimezone);

        // If not in dropdown, add it dynamically
        if (!existingOption) {
            const newOption = document.createElement('option');
            newOption.value = detectedTimezone;
            newOption.textContent = detectedTimezone;
            select.appendChild(newOption);
        }

        select.value = detectedTimezone;

        // Update in database
        const { error } = await supabase
            .from('profiles')
            .update({ timezone: detectedTimezone })
            .eq('id', currentUser.id);

        if (error) throw error;

        currentUser.timezone = detectedTimezone;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
        SecureStorage.setUserId(currentUser.id);
        SecureStorage.setSessionData(currentUser);

        hideLoader();
        showNotification(`Timezone detected: ${detectedTimezone}`);

    } catch (error) {
        hideLoader();
        console.error('Error detecting timezone:', error);
        showNotification('Error detecting timezone', 'error');
    }
}

window.toggleNewMatches = async function() {
    const toggle = document.getElementById('new-match-toggle');
    const isEnabled = toggle.checked;

    try {
        const { error } = await supabase
            .from('profiles')
            .update({ notify_new_matches: isEnabled })
            .eq('id', currentUser.id);

        if (error) throw error;

        currentUser.notify_new_matches = isEnabled;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser);

        showNotification(isEnabled ? ' New match notifications enabled!' : ' New match notifications disabled');

    } catch (error) {
        console.error('Error toggling new match notifications:', error);
        showNotification('Error updating setting', 'error');
        toggle.checked = !isEnabled;
    }
}

window.toggleEventJoins = async function() {
    const toggle = document.getElementById('event-join-toggle');
    const isEnabled = toggle.checked;

    try {
        const { error } = await supabase
            .from('profiles')
            .update({ notify_event_joins: isEnabled })
            .eq('id', currentUser.id);

        if (error) throw error;

        currentUser.notify_event_joins = isEnabled;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser);

        showNotification(isEnabled ? ' Event join notifications enabled!' : ' Event join notifications disabled');

    } catch (error) {
        console.error('Error toggling event join notifications:', error);
        showNotification('Error updating setting', 'error');
        toggle.checked = !isEnabled;
    }
}

window.toggleInactivityWarnings = async function() {
    const toggle = document.getElementById('inactivity-warnings-toggle');
    const isEnabled = toggle.checked;

    try {
        const { error } = await supabase
            .from('profiles')
            .update({ notify_inactivity_warnings: isEnabled })
            .eq('id', currentUser.id);

        if (error) throw error;

        currentUser.notify_inactivity_warnings = isEnabled;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser);

        showNotification(isEnabled ? ' Inactivity warnings enabled!' : ' Inactivity warnings disabled');

    } catch (error) {
        console.error('Error toggling inactivity warnings:', error);
        showNotification('Error updating setting', 'error');
        toggle.checked = !isEnabled;
    }
}

window.toggleChatMessages = async function() {
    const toggle = document.getElementById('chat-messages-toggle');
    const isEnabled = toggle.checked;

    try {
        const { error } = await supabase
            .from('profiles')
            .update({ notify_chat_messages: isEnabled })
            .eq('id', currentUser.id);

        if (error) throw error;

        currentUser.notify_chat_messages = isEnabled;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser);

        showNotification(isEnabled ? ' Chat notifications enabled!' : ' Chat notifications disabled');

    } catch (error) {
        console.error('Error toggling chat notifications:', error);
        showNotification('Error updating setting', 'error');
        toggle.checked = !isEnabled;
    }
}

window.toggleNotifyAt4 = async function() {
    const toggle = document.getElementById('notify-at-4-toggle');
    const isEnabled = toggle.checked;

    try {
        const { error } = await supabase
            .from('profiles')
            .update({ notify_at_4: isEnabled })
            .eq('id', currentUser.id);

        if (error) throw error;

        currentUser.notify_at_4 = isEnabled;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
        SecureStorage.setUserId(currentUser.id);
        SecureStorage.setSessionData(currentUser);

        showNotification(isEnabled ? ' Notifications at 4 interested enabled!' : ' Notifications at 4 interested disabled');

    } catch (error) {
        console.error('Error toggling notify at 4:', error);
        showNotification('Error updating setting', 'error');
        toggle.checked = !isEnabled;
    }
}

window.toggleNotifyAt8 = async function() {
    const toggle = document.getElementById('notify-at-8-toggle');
    const isEnabled = toggle.checked;

    try {
        const { error } = await supabase
            .from('profiles')
            .update({ notify_at_8: isEnabled })
            .eq('id', currentUser.id);

        if (error) throw error;

        currentUser.notify_at_8 = isEnabled;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
        SecureStorage.setUserId(currentUser.id);
        SecureStorage.setSessionData(currentUser);

        showNotification(isEnabled ? ' Notifications at 8 interested enabled!' : ' Notifications at 8 interested disabled');

    } catch (error) {
        console.error('Error toggling notify at 8:', error);
        showNotification('Error updating setting', 'error');
        toggle.checked = !isEnabled;
    }
}

window.toggleDarkMode = async function() {
    const toggle = document.getElementById('dark-mode-toggle');
    const isEnabled = toggle.checked;

    try {
        // Apply dark mode immediately for smooth UX
        if (isEnabled) {
            document.body.classList.add('dark-mode');
        } else {
            document.body.classList.remove('dark-mode');
        }

        const { error } = await supabase
            .from('profiles')
            .update({ dark_mode_enabled: isEnabled })
            .eq('id', currentUser.id);

        if (error) throw error;

        currentUser.dark_mode_enabled = isEnabled;
        // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
  SecureStorage.setUserId(currentUser.id);
  SecureStorage.setSessionData(currentUser);

        showNotification(isEnabled ? ' Dark mode enabled!' : ' Light mode enabled');

    } catch (error) {
        console.error('Error toggling dark mode:', error);
        showNotification('Error updating setting', 'error');
        // Revert dark mode on error
        toggle.checked = !isEnabled;
        if (isEnabled) {
            document.body.classList.remove('dark-mode');
        } else {
            document.body.classList.add('dark-mode');
        }
    }
}

window.changePassword = async function() {
    const newPassword = document.getElementById('new-password').value;
    const confirmPassword = document.getElementById('confirm-password').value;
    
    if (!newPassword || !confirmPassword) {
        return showNotification('Please fill in both password fields', 'error');
    }
    
    if (newPassword.length < 6) {
        return showNotification('New password must be at least 6 characters', 'error');
    }
    
    if (newPassword !== confirmPassword) {
        return showNotification('Passwords do not match', 'error');
    }
    
    try {
        const { error } = await supabase.auth.updateUser({
            password: newPassword
        });
        
        if (error) throw error;
        
        document.getElementById('new-password').value = '';
        document.getElementById('confirm-password').value = '';
        
        showNotification('Password updated successfully!');
        
    } catch (error) {
        console.error('Error changing password:', error);
        showNotification(error.message || 'Error updating password', 'error');
    }
}

        document.querySelectorAll('.avatar-option').forEach(option => {
            option.addEventListener('click', function() {
                document.querySelectorAll('.avatar-option').forEach(o => o.classList.remove('selected'));
                this.classList.add('selected');
            });
        });

        // Circle Management
        window.showCreateCircle = () => { document.getElementById('create-circle').style.display = 'block'; document.getElementById('circle-modal-overlay').style.display = 'flex'; };
        window.showJoinCircle = () => { document.getElementById('join-circle').style.display = 'block'; document.getElementById('circle-modal-overlay').style.display = 'flex'; };
        window.closeCircleModal = () => { document.getElementById('circle-modal-overlay').style.display = 'none'; document.getElementById('create-circle').style.display = 'none'; document.getElementById('join-circle').style.display = 'none'; };

        // Payment Modal Management
        window.showPaymentModal = async () => {
            // Get current user's circles purchased count
            const { data: profile } = await supabase
                .from('profiles')
                .select('circles_purchased')
                .eq('id', currentUser.id)
                .single();

            const circlesPurchased = profile?.circles_purchased || 1;

            // Count user's current circles
            const { data: memberData } = await supabase
                .from('circle_members')
                .select('circle_id')
                .eq('profile_id', currentUser.id);

            const currentCircleCount = memberData?.length || 0;

            document.getElementById('payment-circles-current').textContent = currentCircleCount;
            document.getElementById('payment-circles-total').textContent = circlesPurchased;
            document.getElementById('payment-modal-overlay').style.display = 'flex';
        };

        window.closePaymentModal = () => {
            document.getElementById('payment-modal-overlay').style.display = 'none';
        };

        window.proceedToPayment = async () => {
            const proceedBtn = document.getElementById('payment-proceed-btn');
            proceedBtn.disabled = true;
            proceedBtn.textContent = 'Processing...';

            try {
                console.log('Creating checkout session for user:', currentUser.id);

                // Get pending circle join info to pass to Stripe
                let circleCode = null;
                const pendingJoin = localStorage.getItem('pendingCircleJoin');
                if (pendingJoin) {
                    try {
                        const joinData = JSON.parse(pendingJoin);
                        circleCode = joinData.code;
                        console.log(' Including circle code in Stripe session:', circleCode);
                    } catch (e) {
                        console.error('Error parsing pendingCircleJoin:', e);
                    }
                }

                // Call serverless function to create Stripe checkout session
                const response = await fetch('/api/create-checkout-session', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        userId: currentUser.id,
                        userEmail: currentUser.email,
                        circleCode: circleCode, // Add circle code to request
                    }),
                });

                console.log('Response status:', response.status);

                const data = await response.json();
                console.log('Response data:', data);

                if (!response.ok) {
                    throw new Error(data.error || 'Failed to create checkout session');
                }

                if (!data.url) {
                    throw new Error('No checkout URL returned');
                }

                // Redirect to Stripe Checkout
                console.log('Redirecting to:', data.url);
                window.location.href = data.url;

            } catch (error) {
                console.error('Payment error:', error);
                showNotification(`Payment failed: ${error.message}`, 'error');
                proceedBtn.disabled = false;
                proceedBtn.textContent = 'Join Additional Circle - $1.99';
            }
        };

        // Generic Modal Management
        window.showModal = (title, content) => {
            document.getElementById('generic-modal-title').textContent = title;
            document.getElementById('generic-modal-body').innerHTML = content;
            document.getElementById('generic-modal-overlay').style.display = 'flex';
        };
        window.closeGenericModal = () => {
            document.getElementById('generic-modal-overlay').style.display = 'none';
        };
        // Allow clicking overlay to close
        document.getElementById('generic-modal-overlay')?.addEventListener('click', (e) => {
            if (e.target.id === 'generic-modal-overlay') {
                closeGenericModal();
            }
        });

        // Tutorial Management
        const tutorialSteps = {
            'activities': 4,
            'circles': 4,
            'matches': 4
        };

        let currentTutorialSteps = {
            'activities': 1,
            'circles': 1,
            'matches': 1
        };

        window.showTutorial = function(tutorialId, force = false) {
            if (!currentUser) return;

            // Check if user has already completed this tutorial (unless forced)
            if (!force && currentUser.completed_tutorials && currentUser.completed_tutorials[tutorialId]) {
                return;
            }

            // Reset to first step
            currentTutorialSteps[tutorialId] = 1;

            // Show modal
            const modal = document.getElementById(`tutorial-${tutorialId}-modal`);
            if (!modal) return;

            // Reset all steps
            const steps = modal.querySelectorAll('.tutorial-step');
            steps.forEach((step, index) => {
                step.style.display = index === 0 ? 'block' : 'none';
            });

            // Update progress indicators
            updateTutorialProgress(tutorialId);

            // Show/hide navigation buttons
            document.getElementById(`tutorial-${tutorialId}-prev`).style.display = 'none';
            const nextBtn = document.getElementById(`tutorial-${tutorialId}-next`);
            nextBtn.textContent = tutorialSteps[tutorialId] === 1 ? 'Got it!' : 'Next';

            // Display modal
            modal.style.display = 'flex';
        };

        window.nextTutorialStep = function(tutorialId) {
            const currentStep = currentTutorialSteps[tutorialId];
            const totalSteps = tutorialSteps[tutorialId];

            if (currentStep >= totalSteps) {
                // Last step - close and mark complete
                closeTutorial(tutorialId);
                return;
            }

            // Hide current step
            const modal = document.getElementById(`tutorial-${tutorialId}-modal`);
            const steps = modal.querySelectorAll('.tutorial-step');
            steps[currentStep - 1].style.display = 'none';

            // Show next step
            currentTutorialSteps[tutorialId]++;
            steps[currentTutorialSteps[tutorialId] - 1].style.display = 'block';

            // Update progress indicators
            updateTutorialProgress(tutorialId);

            // Update buttons
            document.getElementById(`tutorial-${tutorialId}-prev`).style.display = 'inline-block';
            const nextBtn = document.getElementById(`tutorial-${tutorialId}-next`);

            if (currentTutorialSteps[tutorialId] >= totalSteps) {
                nextBtn.textContent = 'Got it!';
            } else {
                nextBtn.textContent = 'Next';
            }

            // Update skip button text
            const skipBtn = document.getElementById(`tutorial-${tutorialId}-skip`);
            if (currentTutorialSteps[tutorialId] >= totalSteps) {
                skipBtn.style.display = 'none';
            }
        };

        window.previousTutorialStep = function(tutorialId) {
            const currentStep = currentTutorialSteps[tutorialId];

            if (currentStep <= 1) return;

            // Hide current step
            const modal = document.getElementById(`tutorial-${tutorialId}-modal`);
            const steps = modal.querySelectorAll('.tutorial-step');
            steps[currentStep - 1].style.display = 'none';

            // Show previous step
            currentTutorialSteps[tutorialId]--;
            steps[currentTutorialSteps[tutorialId] - 1].style.display = 'block';

            // Update progress indicators
            updateTutorialProgress(tutorialId);

            // Update buttons
            if (currentTutorialSteps[tutorialId] === 1) {
                document.getElementById(`tutorial-${tutorialId}-prev`).style.display = 'none';
            }

            const nextBtn = document.getElementById(`tutorial-${tutorialId}-next`);
            nextBtn.textContent = 'Next';

            // Show skip button again
            const skipBtn = document.getElementById(`tutorial-${tutorialId}-skip`);
            skipBtn.style.display = 'inline-block';
        };

        window.skipTutorial = function(tutorialId) {
            closeTutorial(tutorialId);
        };

        window.closeTutorial = async function(tutorialId) {
            // Hide modal
            const modal = document.getElementById(`tutorial-${tutorialId}-modal`);
            if (modal) {
                modal.style.display = 'none';
            }

            // Mark tutorial as completed in database
            await markTutorialComplete(tutorialId);
        };

        async function markTutorialComplete(tutorialId) {
            if (!currentUser) return;

            try {
                // Initialize completed_tutorials if it doesn't exist
                const completed = currentUser.completed_tutorials || {};
                completed[tutorialId] = true;

                // Update in database
                const { error } = await supabase
                    .from('profiles')
                    .update({ completed_tutorials: completed })
                    .eq('id', currentUser.id);

                if (error) throw error;

                // Update local user object
                currentUser.completed_tutorials = completed;
            } catch (error) {
                console.error('Error marking tutorial complete:', error);
            }
        }

        function updateTutorialProgress(tutorialId) {
            const currentStep = currentTutorialSteps[tutorialId];
            const totalSteps = tutorialSteps[tutorialId];
            const modal = document.getElementById(`tutorial-${tutorialId}-modal`);
            const progressContainer = modal.querySelector('.tutorial-progress');

            // Clear existing indicators
            progressContainer.innerHTML = '';

            // Create indicators for each step
            for (let i = 1; i <= totalSteps; i++) {
                const indicator = document.createElement('span');
                indicator.className = 'tutorial-step-indicator';
                if (i <= currentStep) {
                    indicator.classList.add('active');
                }
                progressContainer.appendChild(indicator);
            }
        }

        window.checkAndShowTutorial = async function(pageId) {
            // Only show tutorials for these pages
            if (!['activities', 'circles', 'matches'].includes(pageId)) {
                return;
            }

            if (!currentUser) return;

            // Check if tutorial has been completed
            const completed = currentUser.completed_tutorials || {};
            if (completed[pageId]) {
                return; // Tutorial already seen
            }

            // Show tutorial after a brief delay (500ms)
            setTimeout(() => {
                showTutorial(pageId, false);
            }, 500);
        };

	window.goToCircleStep2 = async function() {
    const name = document.getElementById('circle-name').value.trim();
    
    if (!name) {
        return showNotification('Please enter a circle name', 'error');
    }
    
    // Hide step 1, show step 2
    document.getElementById('circle-step-1').style.display = 'none';
    document.getElementById('circle-step-2').style.display = 'block';
    
    // Load and render activities (no previous selections on first load)
    await renderCircleCreationActivities();
}

window.goBackToCircleStep1 = function() {
    document.getElementById('circle-step-2').style.display = 'none';
    document.getElementById('circle-step-1').style.display = 'block';
}

async function renderCircleCreationActivities(previousSelections = new Set(), autoSelectId = null) {
    const grid = document.getElementById('circle-creation-activities-grid');
    grid.innerHTML = '';

    // Show helpful message if no default activities are available
    if (!defaultActivities || defaultActivities.length === 0) {
        grid.innerHTML = `
            <div style="grid-column: 1/-1; text-align: center; padding: 40px 20px; color: #666;">
                <div style="font-size: 3em; margin-bottom: 20px;"></div>
                <h3 style="margin-bottom: 15px; color: #333;">No Default Activities Available</h3>
                <p style="margin-bottom: 20px;">The database needs to be seeded with default activities.</p>
                <p style="font-size: 0.9em; color: #999;">For now, you can create custom activities by clicking the "+ Custom Activity" button above.</p>
            </div>
        `;
        updateCircleSelectedCount();
        return;
    }

    // Render all default activities
    defaultActivities.forEach(activity => {
        const card = document.createElement('div');
        card.className = 'activity-card';
        card.dataset.activityId = activity.id;

        // Restore previous selections or auto-select new activity
        // Note: Convert to string for comparison since dataset values are always strings
        if (previousSelections.has(String(activity.id)) || activity.id === autoSelectId) {
            card.classList.add('selected');
        }

        card.innerHTML = `
            <div class="activity-emoji">${activity.emoji || ''}</div>
            <div class="activity-name">${activity.name}</div>
        `;

        card.onclick = () => {
            card.classList.toggle('selected');
            updateCircleSelectedCount();
        };

        grid.appendChild(card);
    });

    updateCircleSelectedCount();
}

function updateCircleSelectedCount() {
    const selectedCards = document.querySelectorAll('#circle-creation-activities-grid .activity-card.selected');
    const count = selectedCards.length;
    
    document.getElementById('circle-selected-count').textContent = count;
    
    const createBtn = document.getElementById('circle-create-btn');
    const warning = document.getElementById('circle-min-warning');
    
    if (count >= 4) {
        createBtn.disabled = false;
        createBtn.style.opacity = '1';
        createBtn.style.cursor = 'pointer';
        warning.style.display = 'none';
    } else {
        createBtn.disabled = true;
        createBtn.style.opacity = '0.5';
        createBtn.style.cursor = 'not-allowed';
        warning.style.display = 'block';
    }
}

window.finalizeCircleCreation = async function() {
    const name = document.getElementById('circle-name').value.trim();

    if (!name) {
        return showNotification('Please enter a circle name', 'error');
    }

    // Get selected activities
    const selectedCards = document.querySelectorAll('#circle-creation-activities-grid .activity-card.selected');
    const selectedActivityIds = Array.from(selectedCards).map(card => card.dataset.activityId);

    if (selectedActivityIds.length < 4) {
        return showNotification('Please select at least 4 activities', 'error');
    }

    // Check if user has available circles
    showLoader('Checking availability...');

    try {
        // Get user's current circle count and purchased circles
        const { data: profile, error: profileError } = await supabase
            .from('profiles')
            .select('circles_purchased')
            .eq('id', currentUser.id)
            .single();

        if (profileError) throw profileError;

        const circlesPurchased = profile?.circles_purchased || 1;

        // Count user's current circles
        const { data: memberData, error: countError } = await supabase
            .from('circle_members')
            .select('circle_id')
            .eq('profile_id', currentUser.id);

        if (countError) throw countError;

        const currentCircleCount = memberData?.length || 0;

        // Check if user needs to purchase more circles
        if (currentCircleCount >= circlesPurchased) {
            hideLoader();

            // Save circle creation intent to localStorage for after payment
            localStorage.setItem('pendingCircleCreation', JSON.stringify({
                name: name,
                selectedActivityIds: selectedActivityIds,
                timestamp: Date.now()
            }));

            closeCircleModal();
            await showPaymentModal();
            return;
        }

        hideLoader();
    } catch (error) {
        hideLoader();
        console.error('Error checking circle availability:', error);
        showNotification('Error checking availability', 'error');
        return;
    }

    showLoader('Creating circle...');
    
    try {
        const code = generateCode();
        
        // Insert into circles
        const { data: circle, error } = await supabase
            .from('circles')
            .insert([{ name, code, created_by: currentUser.id }])
            .select()
            .single();
        
        if (error) throw error;
        
        // Add creator as a member
        await supabase.from('circle_members').insert([{ 
            circle_id: circle.id, 
            profile_id: currentUser.id 
        }]);
        
        // Save any custom activities that were suggested during creation
        const customActivities = defaultActivities.filter(a => 
            typeof a.id === 'string' && a.id.startsWith('temp_')
        );
        
        const activityIdMapping = {}; // Maps temp IDs to real IDs
        
        for (const customActivity of customActivities) {
            const { data: newActivity, error: actError } = await supabase
                .from('activities')
                .insert([{
                    name: customActivity.name,
                    emoji: customActivity.emoji,
                    category: 'custom',
                    circle_id: circle.id
                }])
                .select()
                .single();
            
            if (!actError && newActivity) {
                activityIdMapping[customActivity.id] = newActivity.id;
            }
        }
        
        // Update selected IDs to use real IDs instead of temp IDs
        const finalSelectedIds = selectedActivityIds.map(id => 
            activityIdMapping[id] || id
        );
        
        // Set activity visibility for this circle
        if (finalSelectedIds.length > 0) {
            // Get all default activity IDs (excluding temp ones)
            const allDefaultIds = defaultActivities
                .filter(a => !(typeof a.id === 'string' && a.id.startsWith('temp_')))
                .map(a => a.id);
            
            // Create visibility records for default activities
            // Note: Convert to string for comparison since dataset values are always strings
            const visibilityRecords = allDefaultIds.map(activityId => ({
                circle_id: circle.id,
                activity_id: activityId,
                is_visible: finalSelectedIds.includes(String(activityId))
            }));
            
            await supabase
                .from('circle_activities')
                .insert(visibilityRecords);
        }
        
        // Clean up temp activities from defaultActivities
        defaultActivities = defaultActivities.filter(a => 
            !(typeof a.id === 'string' && a.id.startsWith('temp_'))
        );
        
        circles.push(circle);
        
        // Reset modal
        document.getElementById('circle-name').value = '';
        document.getElementById('circle-step-2').style.display = 'none';
        document.getElementById('circle-step-1').style.display = 'block';
        
        closeCircleModal();
        hideLoader();
        await renderCircles();

        // Refresh the activities page if user is on it
        const currentPage = localStorage.getItem('friendle_current_page');
        if (currentPage === 'activities') {
            await populateCircleSelector();
        }

        showNotification(`Circle created! Share code: ${circle.code}`);
        
    } catch (error) {
        hideLoader();
        console.error('Error creating circle:', error);
        showNotification('Could not create circle', 'error');
    }
}

        
        window.joinCircle = async function() {
  const code = document.getElementById('circle-code').value.trim();
  if (!code) return;

  // Find the circle by code
  const { data: circle, error } = await supabase
    .from('circles')
    .select('*')
    .eq('code', code)
    .single();

  if (error || !circle) {
    return showNotification('Circle not found', 'error');
  }

  // Check if user is already a member
  const { data: existingMember } = await supabase
    .from('circle_members')
    .select('*')
    .eq('circle_id', circle.id)
    .eq('profile_id', currentUser.id)
    .single();

  if (existingMember) {
    closeCircleModal();
    return showNotification('You are already a member of this circle');
  }

  // Check if user has available circles
  showLoader('Checking availability...');

  try {
    // Get user's current circle count and purchased circles
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('circles_purchased')
      .eq('id', currentUser.id)
      .single();

    if (profileError) throw profileError;

    const circlesPurchased = profile?.circles_purchased || 1;

    // Count user's current circles
    const { data: memberData, error: countError } = await supabase
      .from('circle_members')
      .select('circle_id')
      .eq('profile_id', currentUser.id);

    if (countError) throw countError;

    const currentCircleCount = memberData?.length || 0;

    // Check if user needs to purchase more circles
    if (currentCircleCount >= circlesPurchased) {
      hideLoader();

      // Clear any stale pending join data first
      const existingPendingJoin = localStorage.getItem('pendingCircleJoin');
      if (existingPendingJoin) {
        console.log(' Clearing stale pendingCircleJoin before setting new one');
        localStorage.removeItem('pendingCircleJoin');
      }

      // Save circle join intent to localStorage for after payment
      const pendingData = {
        code: code,
        timestamp: Date.now(),
        source: 'manual_join'
      };
      localStorage.setItem('pendingCircleJoin', JSON.stringify(pendingData));
      console.log(' Set pendingCircleJoin for manual join code:', code);

      closeCircleModal();
      await showPaymentModal();
      return;
    }

    hideLoader();
  } catch (error) {
    hideLoader();
    console.error('Error checking circle availability:', error);
    showNotification('Error checking availability', 'error');
    return;
  }

  // Add user to circle_members
  await supabase.from('circle_members').insert([{ circle_id: circle.id, profile_id: currentUser.id }]);

  circles.push(circle);
  closeCircleModal();
  await renderCircles();

  // Refresh the activities page if user is on it
  const currentPage = localStorage.getItem('friendle_current_page');
  if (currentPage === 'activities') {
    await populateCircleSelector();
  }

  showNotification(`Joined Circle!`);

  // Mark that user joined their first circle for PWA prompt
  markCircleJoined();

  // Show PWA install prompt after brief delay to avoid interrupting the success moment
  setTimeout(() => {
    showPWAPrompt();
  }, 500);
}

        async function renderCircles() {
  showLoader('Loading circles...');

  try {
    // Get circles with last_read_at for unread tracking
    const { data, error } = await supabase
      .from('circle_members')
      .select(`
        circle_id,
        circles(*),
        profile_id,
        last_read_at
      `)
      .eq('profile_id', currentUser.id);

    if (error) throw error;

    circles = data.map(d => d.circles);

    // Create map of circle_id -> last_read_at
    const lastReadMap = new Map();
    data.forEach(d => {
      lastReadMap.set(d.circle_id, d.last_read_at);
    });

    // Get member counts for each circle
    const circleIds = circles.map(c => c.id);
    const { data: memberCounts, error: countError } = await supabase
      .from('circle_members')
      .select('circle_id')
      .in('circle_id', circleIds);

    if (countError) throw countError;

    // Count members per circle
    const counts = {};
    memberCounts.forEach(member => {
      counts[member.circle_id] = (counts[member.circle_id] || 0) + 1;
    });

    // Get unread counts for all circles in parallel
    const unreadPromises = circles.map(circle =>
      getCircleUnreadCount(circle.id, lastReadMap.get(circle.id))
    );
    const unreadCounts = await Promise.all(unreadPromises);

    // Create map of circle_id -> unread count
    const unreadMap = new Map();
    circles.forEach((circle, index) => {
      unreadMap.set(circle.id, unreadCounts[index]);
    });

    // Get upcoming events count for each circle
    // Use local timezone for "today" instead of UTC to avoid timezone bugs
    const now = new Date();
    const today = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;
    const { data: upcomingEvents, error: eventsError } = await supabase
      .from('events')
      .select('circle_id')
      .in('circle_id', circleIds)
      .gte('scheduled_date', today);

    // Count upcoming events per circle
    const upcomingEventCounts = {};
    if (upcomingEvents) {
      upcomingEvents.forEach(event => {
        upcomingEventCounts[event.circle_id] = (upcomingEventCounts[event.circle_id] || 0) + 1;
      });
    }

    const list = document.getElementById('circles-list');

    if (circles.length === 0) {
      list.innerHTML = `
        <div class="empty-state">
          <div class="empty-state-icon"></div>
          <div class="empty-state-title">No Circles Yet</div>
          <div class="empty-state-description">Circles are your friend groups. Create one to start coordinating activities, or join an existing circle with an invite code.</div>
          <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
            <button class="btn" onclick="showCreateCircle()">+ Create Circle</button>
            <button class="btn btn-secondary" onclick="showJoinCircle()">Join Circle</button>
          </div>
        </div>`;
      hideLoader();
      return;
    }

    list.innerHTML = circles.map(circle => {
      const memberCount = counts[circle.id] || 0;
      const memberText = memberCount === 1 ? '1 member' : `${memberCount} members`;
      const unreadCount = unreadMap.get(circle.id) || 0;
      const isExpanded = expandedCircles.has(circle.id);

      // Escape single quotes in circle name and code for onclick handlers
      const escapedName = circle.name.replace(/'/g, "\\'");
      const escapedCode = circle.code.replace(/'/g, "\\'");

      return `
        <div class="circle-card${unreadCount > 0 ? ' unread' : ''}${isExpanded ? ' expanded' : ''}" data-circle-id="${circle.id}">
          <div class="circle-card-header" onclick="toggleCircleExpand('${circle.id}')" style="display: flex; flex-direction: column; gap: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
              <div class="circle-name" onclick="event.stopPropagation(); renameCircle('${circle.id}')" style="cursor: pointer; font-size: 1.1em; font-weight: 600; text-align: left;" title="Click to rename">${circle.name}</div>
              <div class="circle-members" onclick="event.stopPropagation(); viewCircleMembers('${circle.id}')" style="cursor: pointer; text-decoration: underline; font-size: 0.9em; color: var(--text-secondary); text-align: right; white-space: nowrap;" title="Click to view members">${memberText}</div>
            </div>
            <div style="display: flex; align-items: center; gap: 6px; flex-wrap: wrap;">
              <button class="btn btn-small" onclick="event.stopPropagation(); openCircleChat('${circle.id}')" style="padding: 6px 12px; font-size: 0.85em;"> Chat</button>
              <button class="btn btn-small btn-secondary" onclick="event.stopPropagation(); inviteByEmail('${escapedName}', '${escapedCode}')" style="padding: 6px 12px; font-size: 0.85em;"> Invite</button>
              <button class="btn btn-small btn-secondary" onclick="event.stopPropagation(); copyCircleCode('${escapedCode}')" style="padding: 6px 12px; font-size: 0.85em; font-family: monospace;" title="Click to copy"> ${circle.code}</button>
              ${unreadCount > 0 ? `<span class="circle-new-message-badge" style="font-size: 0.9em;">New</span>` : ''}
              <span class="circle-expand-icon" style="margin-left: auto;"></span>
            </div>
          </div>
          <div class="circle-card-content">
            <button class="btn btn-small" onclick="event.stopPropagation(); leaveCircle('${circle.id}')" style="background: #dc3545; width: 100%;">Leave Circle</button>
          </div>
        </div>`;
    }).join('');
    } catch (error) {
    console.error('Error loading circles:', error);
    circles = [];
  } finally {
    hideLoader();
  }
}

window.toggleCircleExpand = function(circleId) {
  const card = document.querySelector(`.circle-card[data-circle-id="${circleId}"]`);
  if (!card) return;

  if (expandedCircles.has(circleId)) {
    expandedCircles.delete(circleId);
    card.classList.remove('expanded');
  } else {
    expandedCircles.add(circleId);
    card.classList.add('expanded');
  }
};

window.leaveCircle = async function(circleId) {
  if (!confirm("Are you sure you want to leave this circle?")) return;
  
  showLoader('Leaving circle...');
  
  try {
    // Check if user is the last member
    const { data: members, error: membersError } = await supabase
      .from('circle_members')
      .select('profile_id')
      .eq('circle_id', circleId);
    
    if (membersError) throw membersError;
    
    const isLastMember = members && members.length === 1;
    
    // Delete your membership
    const { error: deleteError } = await supabase
      .from('circle_members')
      .delete()
      .eq('circle_id', circleId)
      .eq('profile_id', currentUser.id);
    
    if (deleteError) throw deleteError;
    
    // If last member, delete the entire circle
    if (isLastMember) {
      await deleteCircle(circleId);
      hideLoader();
      showNotification("Circle deleted (you were the last member)");
    } else {
      hideLoader();
      showNotification("You left the circle.");
    }
    
    // Refresh circles list
    await renderCircles();
    
  } catch (error) {
    hideLoader();
    console.error('Error leaving circle:', error);
    showNotification("Error leaving circle", "error");
  }
};

async function deleteCircle(circleId) {
  try {
    console.log(' Deleting empty circle:', circleId);
    
    // Delete all related data (Supabase should handle cascades, but let's be explicit)
    
    // 1. Delete circle_activities
    await supabase
      .from('circle_activities')
      .delete()
      .eq('circle_id', circleId);
    
    // 2. Delete preferences
    await supabase
      .from('preferences')
      .delete()
      .eq('circle_id', circleId);
    
    // 3. Delete match_participants (for matches in this circle)
    const { data: circleMatches } = await supabase
      .from('matches')
      .select('id')
      .eq('circle_id', circleId);
    
    if (circleMatches && circleMatches.length > 0) {
      const matchIds = circleMatches.map(m => m.id);
      
      await supabase
        .from('match_participants')
        .delete()
        .in('match_id', matchIds);

      // Note: match_messages table has been removed (transitioned to event-based planning)
    }

    // 5. Delete events and related data
    const { data: circleEvents } = await supabase
      .from('events')
      .select('id')
      .eq('circle_id', circleId);
    
    if (circleEvents && circleEvents.length > 0) {
      const eventIds = circleEvents.map(e => e.id);
      
      // Delete event_participants
      await supabase
        .from('event_participants')
        .delete()
        .in('event_id', eventIds);
      
      // Delete event_messages
      await supabase
        .from('event_messages')
        .delete()
        .in('event_id', eventIds);
      
      // Delete events
      await supabase
        .from('events')
        .delete()
        .in('id', eventIds);
    }
    
    // 6. Delete matches
    await supabase
      .from('matches')
      .delete()
      .eq('circle_id', circleId);
    
    // 7. Delete custom activities for this circle
    await supabase
      .from('activities')
      .delete()
      .eq('circle_id', circleId);
    
    // 8. Finally, delete the circle itself
    const { error: circleError } = await supabase
      .from('circles')
      .delete()
      .eq('id', circleId);
    
    if (circleError) throw circleError;
    
    console.log(' Circle and all related data deleted');
    
  } catch (error) {
    console.error('Error deleting circle:', error);
    throw error;
  }
}

window.copyCircleCode = function(code) {
    navigator.clipboard.writeText(code).then(() => {
        showNotification('Circle code ' + code + ' copied to clipboard!');
    }).catch(() => {
        const textArea = document.createElement('textarea');
        textArea.value = code;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        showNotification('Circle code ' + code + ' copied to clipboard!');
    });
}

window.inviteByEmail = function(circleName, circleCode) {
    const subject = encodeURIComponent('Join my "' + circleName + '" circle on Friendle');
    const appUrl = 'https://friendlecircles.app/';
    const inviteUrl = appUrl + '?invite_code=' + circleCode;
    
    const body = encodeURIComponent(
    'Hi! I would like to invite you to join my "' + circleName + '" circle on Friendle.\n\n' +
    'Join us for coffee, hiking, and whatever else comes up.\n\n' +
    'CLICK THIS LINK TO JOIN:\n' +
    inviteUrl + '\n\n' +
    '(Copy and paste the link above into your browser if it does not appear clickable)\n\n' +
    'Or visit ' + appUrl + ' and manually enter code: ' + circleCode + '\n\n' +
    'Looking forward to planning some fun activities together!'
);
    
    const mailtoLink = 'mailto:?subject=' + subject + '&body=' + body;
    window.open(mailtoLink, '_self');
}

window.renameCircle = async function(circleId) {
    const circle = circles.find(c => c.id === circleId);

    if (!circle) {
        showNotification('Circle not found', 'error');
        return;
    }

    const newName = prompt('Enter new circle name:', circle.name);

    if (!newName || !newName.trim()) {
        return; // User cancelled or entered empty name
    }

    if (newName.trim() === circle.name) {
        return; // No change
    }

    try {
        const { error } = await supabase
            .from('circles')
            .update({ name: newName.trim() })
            .eq('id', circleId)
            .eq('created_by', currentUser.id); // Only creator can rename

        if (error) {
            if (error.code === '42501') {
                showNotification('Only the circle creator can rename it', 'error');
            } else {
                throw error;
            }
            return;
        }

        showNotification('Circle renamed!');
        await renderCircles(); // Refresh the display
    } catch (error) {
        console.error('Error renaming circle:', error);
        showNotification('Error renaming circle', 'error');
    }
}

window.viewCircleMembers = async function(circleId) {
    const circle = circles.find(c => c.id === circleId);

    if (!circle) {
        showNotification('Circle not found', 'error');
        return;
    }

    try {
        showLoader('Loading members...');

        const { data: members, error } = await supabase
            .from('circle_members')
            .select('profile_id, profiles(id, name, avatar)')
            .eq('circle_id', circleId);

        if (error) throw error;

        hideLoader();

        if (!members || members.length === 0) {
            showNotification('No members found in this circle.', 'error');
            return;
        }

        // Update modal title
        document.getElementById('circle-members-modal-title').textContent = `Members of ${circle.name}`;

        // Build members list HTML
        const membersHTML = members
            .map(m => {
                // Only show emoji avatars, not URLs
                const avatar = m.profiles.avatar && !m.profiles.avatar.startsWith('http')
                    ? `${m.profiles.avatar} `
                    : '';
                return `<div style="padding: 10px; border-bottom: 1px solid var(--border-color); font-size: 1em;">
                    ${avatar}${m.profiles.name}
                </div>`;
            })
            .join('');

        // Populate members list
        document.getElementById('circle-members-list').innerHTML = membersHTML;

        // Show modal
        document.getElementById('circle-members-modal-overlay').style.display = 'flex';
    } catch (error) {
        hideLoader();
        console.error('Error loading circle members:', error);
        showNotification('Error loading members', 'error');
    }
}

window.closeCircleMembersModal = function() {
    document.getElementById('circle-members-modal-overlay').style.display = 'none';
}

window.viewUpcomingEvents = async function(circleId) {
    const circle = circles.find(c => c.id === circleId);

    if (!circle) {
        showNotification('Circle not found', 'error');
        return;
    }

    try {
        showLoader('Loading upcoming events...');

        // Get today's date in YYYY-MM-DD format
        // Use local timezone for "today" instead of UTC to avoid timezone bugs
    const now = new Date();
    const today = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;

        // Query events for this circle that are today or in the future
        const { data: events, error } = await supabase
            .from('events')
            .select(`
                *,
                activities(name, emoji),
                event_participants(profile_id, profiles(id, name, avatar))
            `)
            .eq('circle_id', circleId)
            .gte('scheduled_date', today)
            .order('scheduled_date', { ascending: true })
            .order('scheduled_time', { ascending: true });

        if (error) throw error;

        hideLoader();

        if (!events || events.length === 0) {
            alert(`No upcoming events for ${circle.name}.`);
            return;
        }

        // Check if dark mode is enabled
        const isDarkMode = document.body.classList.contains('dark-mode');
        const bgColor = isDarkMode ? '#1a1a1e' : 'white';
        const textColor = isDarkMode ? '#e5e5e7' : '#1a1a1a';
        const borderColor = isDarkMode ? '#2a2a2e' : '#ddd';
        const cardBgColor = isDarkMode ? '#2a2a2e' : '#ffffff';
        const mutedTextColor = isDarkMode ? '#9ca3af' : '#666';

        // Create a modal to display the events
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        `;

        const modalContent = document.createElement('div');
        modalContent.style.cssText = `
            background: ${bgColor};
            color: ${textColor};
            border-radius: 12px;
            padding: 20px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        `;

        let eventsHtml = `<h2 style="margin-top: 0; color: ${textColor};"> Upcoming Events - ${circle.name}</h2>`;

        events.forEach(event => {
            const activity = event.activities;
            const activityName = activity ? `${activity.emoji} ${activity.name}` : 'Activity';
            const eventDate = new Date(event.scheduled_date).toLocaleDateString('en-US', {
                weekday: 'short',
                month: 'short',
                day: 'numeric'
            });
            const eventTime = event.scheduled_time || 'Time TBD';

            // Check if user is already a participant
            const isUserJoined = event.event_participants?.some(p => p.profile_id === currentUser.id) || false;
            const participantCount = event.event_participants?.length || 0;
            const maxParticipants = event.max_participants;
            const isFull = maxParticipants && participantCount >= maxParticipants;
            const participantDisplay = maxParticipants ? `${participantCount}/${maxParticipants}` : `${participantCount}`;

            eventsHtml += `
                <div style="border: 1px solid ${borderColor}; background: ${cardBgColor}; border-radius: 8px; padding: 15px; margin-bottom: 10px;">
                    <div style="font-weight: 600; font-size: 1.1em; margin-bottom: 5px; color: ${textColor};">${activityName}</div>
                    <div style="color: ${mutedTextColor}; font-size: 0.9em; margin-bottom: 5px;"> ${eventDate} at ${eventTime}</div>
                    <div style="color: ${mutedTextColor}; font-size: 0.9em; margin-bottom: 10px;"> ${participantDisplay} participant${participantCount !== 1 ? 's' : ''}${isFull && !isUserJoined ? ' (full)' : ''}</div>
                    ${isUserJoined
                        ? '<div style="color: #10b981; font-weight: 500;"> You\'re joined</div>'
                        : isFull
                            ? '<button class="btn btn-small" disabled style="width: 100%; background: #888; cursor: not-allowed;">Event Full</button>'
                            : `<button class="btn btn-small" onclick="joinEventFromModal('${event.id}')" style="width: 100%; background: #667eea;">Join Event</button>`
                    }
                </div>
            `;
        });

        eventsHtml += `
            <button class="btn btn-secondary" onclick="closeUpcomingEventsModal()" style="width: 100%; margin-top: 10px;">Close</button>
        `;

        modalContent.innerHTML = eventsHtml;
        modal.appendChild(modalContent);
        document.body.appendChild(modal);

        // Store modal reference for closing
        window.currentUpcomingEventsModal = modal;

        // Close on background click
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                closeUpcomingEventsModal();
            }
        });

    } catch (error) {
        hideLoader();
        console.error('Error loading upcoming events:', error);
        showNotification('Error loading upcoming events', 'error');
    }
}

window.closeUpcomingEventsModal = function() {
    if (window.currentUpcomingEventsModal) {
        window.currentUpcomingEventsModal.remove();
        window.currentUpcomingEventsModal = null;
    }
}

window.joinEventFromModal = async function(eventId) {
    try {
        await window.joinEvent(eventId);

        // Close and refresh the modal to show updated status
        closeUpcomingEventsModal();

        // Get the circle_id from the event
        const { data: event } = await supabase
            .from('events')
            .select('circle_id')
            .eq('id', eventId)
            .single();

        if (event && event.circle_id) {
            // Reopen the modal with updated data
            setTimeout(() => {
                viewUpcomingEvents(event.circle_id);
            }, 500);
        }
    } catch (error) {
        console.error('Error joining event from modal:', error);
        showNotification('Error joining event', 'error');
    }
}

// Save user preferences to Supabase
async function saveUserPreferences(circleId, selectedActivityIds) {
    try {

        // First, clear existing preferences for this circle
        const { error: deleteError } = await supabase
            .from('preferences')
            .delete()
            .eq('profile_id', currentUser.id)
            .eq('circle_id', circleId);

        if (deleteError) {
            console.error('Delete error:', deleteError);
            throw deleteError;
        }

        // Then insert new preferences (only if there are selections)
        if (selectedActivityIds.length > 0) {
            const preferences = selectedActivityIds.map(activityId => ({
                profile_id: currentUser.id,
                circle_id: circleId,
                activity_id: activityId.toString(),
                selected: true
            }));

            const { error: insertError } = await supabase
                .from('preferences')
                .insert(preferences);

            if (insertError) {
                console.error('Insert error:', insertError);
                throw insertError;
            }
            
            // Verify what was saved
            const { data: verifyData } = await supabase
                .from('preferences')
                .select('activity_id')
                .eq('profile_id', currentUser.id)
                .eq('circle_id', circleId);

        } else {

        }

        showNotification('Preferences saved!');
    } catch (error) {
        console.error('Error saving preferences:', error);
        showNotification('Error saving preferences', 'error');
    }
}

// Load user preferences from Supabase
async function loadUserPreferences(circleId) {
    try {
        
        const { data, error } = await supabase
            .from('preferences')
            .select('activity_id')
            .eq('profile_id', currentUser.id)
            .eq('circle_id', circleId)
            .eq('selected', true);

        if (error) throw error;
        
        const activityIds = data.map(pref => pref.activity_id);
        
        return activityIds;
    } catch (error) {
        console.error('Error loading preferences:', error);
        return [];
    }
}

// Check if activity interest has reached critical mass thresholds (4 or 8)
// and send notifications if threshold just crossed
async function checkCriticalMassThresholds(circleId, activityId) {
    try {
        console.log('Checking critical mass thresholds for', { circleId, activityId });

        // Get or create match for this activity + circle
        let { data: match, error: matchError } = await supabase
            .from('matches')
            .select('id, notified_at_4, notified_at_8')
            .eq('circle_id', circleId)
            .eq('activity_id', activityId)
            .single();

        // If no match exists, create one
        if (matchError && matchError.code === 'PGRST116') {
            const { data: newMatch, error: createError } = await supabase
                .from('matches')
                .insert({
                    circle_id: circleId,
                    activity_id: activityId,
                    created_at: new Date().toISOString()
                })
                .select('id, notified_at_4, notified_at_8')
                .single();

            if (createError) {
                console.error('Error creating match:', createError);
                return;
            }

            match = newMatch;
        } else if (matchError) {
            console.error('Error fetching match:', matchError);
            return;
        }

        if (!match) {
            console.error('No match found or created');
            return;
        }

        // Count total interested users for this match
        const { data: interestedUsers, error: countError } = await supabase
            .from('preferences')
            .select('profile_id')
            .eq('circle_id', circleId)
            .eq('activity_id', activityId)
            .eq('selected', true);

        if (countError) {
            console.error('Error counting interested users:', countError);
            return;
        }

        const interestedCount = interestedUsers?.length || 0;
        console.log(`Interested count: ${interestedCount}, notified_at_4: ${match.notified_at_4}, notified_at_8: ${match.notified_at_8}`);

        // Check if we just hit threshold 4
        if (interestedCount >= 4 && !match.notified_at_4) {
            console.log('Threshold 4 reached! Invoking Edge Function...');

            // Invoke Edge Function asynchronously (don't block user flow)
            supabase.functions.invoke('send-critical-mass-notification', {
                body: {
                    matchId: match.id,
                    threshold: 4
                }
            }).then(({ data, error }) => {
                if (error) {
                    console.error('Error invoking critical mass notification (threshold 4):', error);
                } else {
                    console.log('Critical mass notification (threshold 4) sent:', data);
                }
            }).catch(error => {
                console.error('Failed to invoke critical mass notification (threshold 4):', error);
            });
        }

        // Check if we just hit threshold 8
        if (interestedCount >= 8 && !match.notified_at_8) {
            console.log('Threshold 8 reached! Invoking Edge Function...');

            // Invoke Edge Function asynchronously (don't block user flow)
            supabase.functions.invoke('send-critical-mass-notification', {
                body: {
                    matchId: match.id,
                    threshold: 8
                }
            }).then(({ data, error }) => {
                if (error) {
                    console.error('Error invoking critical mass notification (threshold 8):', error);
                } else {
                    console.log('Critical mass notification (threshold 8) sent:', data);
                }
            }).catch(error => {
                console.error('Failed to invoke critical mass notification (threshold 8):', error);
            });
        }

    } catch (error) {
        console.error('Error in checkCriticalMassThresholds:', error);
        // Don't throw - we don't want to break the user flow
    }
}

        // In selectCircle, after filtering:
window.selectCircle = async function(circleId) {
    selectedCircle = circles.find(c => c.id === circleId);
    
    localStorage.setItem('friendle_last_circle', circleId);
    
    const savedActivityIds = await loadUserPreferences(selectedCircle.id);
    const allActivities = await loadActivities(selectedCircle.id);
    
    activities = allActivities.filter(activity => savedActivityIds.includes(activity.id));
    
        skipAutoLoad = true;
    showPage('activities');
    
    const selector = document.getElementById('circle-selector');
    if (selector) {
        selector.value = circleId;
    }
    
    renderActivities();
}

async function populateCircleSelector() {
    const selector = document.getElementById('circle-selector');
    if (!selector) return;
    
    selector.innerHTML = '<option value="">Choose a circle...</option>';
    
    circles.forEach(circle => {
        const option = document.createElement('option');
        option.value = circle.id;
        option.textContent = circle.name;
        selector.appendChild(option);
    });
    
    if (skipAutoLoad) {
        skipAutoLoad = false;
        return;
    }
    
    // Auto-select last used circle or first circle
    const lastCircleId = localStorage.getItem('friendle_last_circle');
    if (lastCircleId && circles.find(c => c.id === lastCircleId)) {
        selector.value = lastCircleId;
        await handleCircleChange(false);
    } else if (circles.length > 0) {
        selector.value = circles[0].id;
        await handleCircleChange(false);
    }
}

window.handleCircleChange = async function(shouldScroll = true) {
    const selector = document.getElementById('circle-selector');
    const circleId = selector.value;
    const eventsSection = document.getElementById('home-events-section');

    if (!circleId) {
        hideLoader(); // Clear any existing loader
        selectedCircle = null;
        activities = [];
        document.getElementById('activities-grid').innerHTML = '';
        document.getElementById('frequent-grid').innerHTML = '';
        document.getElementById('frequent-section').style.display = 'none';
        if (eventsSection) eventsSection.style.display = 'none';
        return;
    }

    localStorage.setItem('friendle_last_circle', circleId);

    showLoader('Loading...');

    selectedCircle = circles.find(c => c.id === circleId);

    const savedActivityIds = await loadUserPreferences(selectedCircle.id);
    const allActivities = await loadActivities(selectedCircle.id);

    activities = allActivities;

    await renderActivitiesGrid();

    // Load and display upcoming events for this circle
    await loadHomeEvents(circleId);

    hideLoader();

    if (shouldScroll) {
        const searchElement = document.getElementById('activity-search');
        if (searchElement) {
            searchElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }
};

// Load and display upcoming events for the home screen
async function loadHomeEvents(circleId) {
    try {
        const now = new Date();
        const today = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;

        // Get upcoming events from this circle (including planning events)
        const { data: upcomingEvents, error } = await supabase
            .from('events')
            .select(`
                *,
                event_participants(profile_id, status, profiles(id, name, avatar))
            `)
            .eq('circle_id', circleId)
            .or(`scheduled_date.gte.${today},status.eq.planning`)
            .neq('status', 'cancelled')
            .order('scheduled_date', { ascending: true, nullsFirst: false })
            .order('scheduled_time', { ascending: true })
            .limit(3);

        if (error) throw error;

        const eventsSection = document.getElementById('home-events-section');
        const eventsList = document.getElementById('home-events-list');

        if (!upcomingEvents || upcomingEvents.length === 0) {
            eventsSection.style.display = 'none';
            return;
        }

        eventsSection.style.display = 'block';

        // Fetch activity and circle data for events
        const activityIds = [...new Set(upcomingEvents.map(e => e.activity_id))];

        const { data: eventActivities } = await supabase
            .from('activities')
            .select('*')
            .in('id', activityIds);

        const activityMap = new Map((eventActivities || []).map(a => [a.id, a]));

        // Get current circle info
        const circle = circles.find(c => c.id === circleId);

        // Process events
        const processedEvents = upcomingEvents.map(event => {
            const activity = activityMap.get(event.activity_id);
            const isUserJoined = (event.event_participants || []).some(p => p.profile_id === currentUser.id);
            const participantCount = (event.event_participants || []).length;

            return {
                ...event,
                activity,
                circle,
                isUserJoined,
                participantCount
            };
        });

        // Render event cards
        eventsList.innerHTML = processedEvents.map(event => renderEventCard(event)).join('');

    } catch (error) {
        console.error('Error loading home events:', error);
    }
}

// Render activities in grid mode for browsing (not selection)
async function renderActivitiesGrid() {
    if (!selectedCircle) {
        document.getElementById('activities-grid').innerHTML = '<div style="text-align: center; padding: 40px 20px; color: #666;"><div style="font-size: 3em; margin-bottom: 20px;"></div><h3 style="margin-bottom: 15px; color: #333;">Select a Circle First</h3><p>Choose a circle from the dropdown above to see available activities.</p></div>';
        document.getElementById('frequent-grid').innerHTML = '';
        document.getElementById('frequent-section').style.display = 'none';
        return;
    }

    const frequentGrid = document.getElementById('frequent-grid');
    const activitiesGrid = document.getElementById('activities-grid');
    frequentGrid.innerHTML = '';
    activitiesGrid.innerHTML = '';

    const allPossibleActivities = await loadActivities(selectedCircle.id);

    // Load user's interests for this circle
    const userInterests = await loadUserPreferences(selectedCircle.id);
    const interestsSet = new Set(userInterests);

    // Create activity cards that open detail page on click
    for (const activity of allPossibleActivities) {
        const card = document.createElement('div');
        card.className = 'activity-card';
        card.dataset.activityId = activity.id;

        // Highlight if user has this as an interest
        const isInterest = interestsSet.has(activity.id);
        if (isInterest) {
            card.classList.add('selected');
        }

        card.innerHTML = `
            <div class="activity-emoji">${activity.emoji}</div>
            <div class="activity-name">${activity.name}</div>
            ${isInterest ? '<div class="activity-interest-badge"></div>' : ''}
        `;

        card.onclick = (event) => {
            event.stopPropagation();
            openActivityDetail(activity);
        };

        activitiesGrid.appendChild(card);
    }

    // Hide frequent section for now (can add back later if needed)
    document.getElementById('frequent-section').style.display = 'none';
}

// Activity Detail Modal Functions
let currentDetailActivity = null;
let currentDetailCircle = null;

window.openActivityDetail = async function(activity) {
    if (!selectedCircle) {
        showNotification('Please select a circle first', 'error');
        return;
    }

    currentDetailActivity = activity;
    currentDetailCircle = selectedCircle; // Store the circle with the activity

    // Set title
    document.getElementById('activity-detail-title').textContent = `${activity.emoji} ${activity.name}`;

    // Set description (placeholder for now, can be enhanced later)
    document.getElementById('activity-detail-description').textContent =
        `Tap "Plan This Activity" to create an event for ${activity.name} in ${currentDetailCircle.name}.`;

    // Load interested users
    try {
        const { data: preferences, error } = await supabase
            .from('preferences')
            .select('profile_id, profiles(name)')
            .eq('circle_id', currentDetailCircle.id)
            .eq('activity_id', activity.id)
            .eq('selected', true);

        if (error) throw error;

        const interestedList = document.getElementById('activity-interested-list');

        if (!preferences || preferences.length === 0) {
            interestedList.innerHTML = '<em>No one has selected this activity in their interests yet</em>';
        } else {
            const names = preferences.map(p => p.profiles.name).join(', ');
            interestedList.textContent = names;
        }

    } catch (error) {
        console.error('Error loading interested users:', error);
        document.getElementById('activity-interested-list').textContent = 'Unable to load interested users';
    }

    // Show modal
    document.getElementById('activity-detail-modal').style.display = 'flex';
};

window.closeActivityDetail = function() {
    document.getElementById('activity-detail-modal').style.display = 'none';
    currentDetailActivity = null;
    currentDetailCircle = null;
};

window.planActivityFromDetail = async function() {
    if (!currentDetailActivity || !currentDetailCircle) {
        showNotification('Please select an activity and circle', 'error');
        return;
    }

    // Store references before closing modal
    const activity = currentDetailActivity;
    const circle = currentDetailCircle;

    // Close the detail modal
    closeActivityDetail();

    // Find or create a match for this activity in this circle
    try {
        showLoader('Creating event...');

        // Check if match already exists
        let { data: existingMatch, error: matchError } = await supabase
            .from('matches')
            .select('id')
            .eq('circle_id', circle.id)
            .eq('activity_id', activity.id)
            .maybeSingle();

        if (matchError) throw matchError;

        let matchId;
        if (existingMatch) {
            matchId = existingMatch.id;
        } else {
            // Create new match
            const { data: newMatch, error: createError } = await supabase
                .from('matches')
                .insert([{
                    circle_id: circle.id,
                    activity_id: activity.id
                }])
                .select()
                .single();

            if (createError) throw createError;
            matchId = newMatch.id;
        }

        hideLoader();

        // Open planning event modal with this match
        openPlanningEventModal(matchId);

    } catch (error) {
        console.error('Error creating event:', error);
        hideLoader();
        showNotification('Error creating event', 'error');
    }
};

// View mode switching
let viewMode = 'swipe'; // Default to swipe view

window.switchToGridView = async function() {
    viewMode = 'grid';
    document.getElementById('swipe-view-container').style.display = 'none';
    document.getElementById('grid-view-container').style.display = 'block';

    // Update button styles using CSS variables for dark mode compatibility
    const gridBtn = document.getElementById('grid-view-btn');
    const swipeBtn = document.getElementById('swipe-view-btn');
    gridBtn.style.background = 'var(--primary-color)';
    gridBtn.style.color = 'white';
    swipeBtn.style.background = 'var(--bg-secondary)';
    swipeBtn.style.color = 'var(--text-primary)';

    // Show save button in grid mode
    document.getElementById('grid-save-button').style.display = 'block';

    await renderActivities(); // Render grid view
}

window.switchToSwipeView = async function() {
    viewMode = 'swipe';
    document.getElementById('grid-view-container').style.display = 'none';
    document.getElementById('swipe-view-container').style.display = 'block';

    // Update button styles using CSS variables for dark mode compatibility
    const swipeBtn = document.getElementById('swipe-view-btn');
    const gridBtn = document.getElementById('grid-view-btn');
    swipeBtn.style.background = 'var(--primary-color)';
    swipeBtn.style.color = 'white';
    gridBtn.style.background = 'var(--bg-secondary)';
    gridBtn.style.color = 'var(--text-primary)';

    // Hide save button in swipe mode
    document.getElementById('grid-save-button').style.display = 'none';

    await initializeSwipeView(); // Initialize swipe cards
}

// Swipe view state
let currentCardIndex = 0;
let swipeHistory = [];
let sortedActivities = [];
let cachedSwipeState = null; // Cache for instant refresh

window.initializeSwipeView = async function(useCache = true) {
    if (!selectedCircle) {
        document.getElementById('card-stack').innerHTML = '<div style="text-align: center; padding: 60px; color: #666;">Please select a circle first</div>';
        return;
    }

    // If we have cached state and useCache is true, show it immediately
    if (useCache && cachedSwipeState && cachedSwipeState.circleId === selectedCircle.id) {
        sortedActivities = cachedSwipeState.sortedActivities;
        currentCardIndex = cachedSwipeState.currentCardIndex;
        swipeHistory = [];
        showNextCard();
    }

    // Load and sort activities in background
    const newActivities = await loadActivitiesForSwiping(selectedCircle.id);

    // Only update if user hasn't started swiping (to avoid race condition)
    const userHasStartedSwiping = currentCardIndex > 0 || swipeHistory.length > 0;

    if (!userHasStartedSwiping) {
        sortedActivities = newActivities;
        currentCardIndex = 0;
        swipeHistory = [];

        // Cache the new state
        cachedSwipeState = {
            circleId: selectedCircle.id,
            sortedActivities: newActivities,
            currentCardIndex: 0
        };

        if (sortedActivities.length === 0) {
            document.getElementById('card-stack').innerHTML = '<div class="empty-state"><div class="empty-state-icon"></div><div class="empty-state-title">No Activities Available</div><div class="empty-state-description">Add some activities to your circle to get started!</div></div>';
            return;
        }

        // Update card with fresh data
        showNextCard();
    } else {
        // User is already swiping, just update the cache for next time
        cachedSwipeState = {
            circleId: selectedCircle.id,
            sortedActivities: newActivities,
            currentCardIndex: 0
        };
    }
}

async function loadActivitiesForSwiping(circleId) {
    // Load activities and all circle preferences in parallel (single query for all prefs)
    const [allActivities, allPrefsResult] = await Promise.all([
        loadActivities(circleId),
        supabase
            .from('preferences')
            .select('activity_id, profile_id, selected')
            .eq('circle_id', circleId)
    ]);

    if (allPrefsResult.error) {
        console.error('Error loading preferences:', allPrefsResult.error);
    }

    const allPrefs = allPrefsResult.data || [];

    // Split into user prefs and others' prefs
    const userPrefs = allPrefs
        .filter(p => p.profile_id === currentUser.id && p.selected)
        .map(p => p.activity_id);

    const circlePrefs = allPrefs.filter(p => p.profile_id !== currentUser.id);

    // Convert all IDs to strings for consistent comparison
    const alreadySelectedIds = new Set(userPrefs.map(id => id.toString()));

    // Filter out activities user has already selected
    // Convert both to strings for comparison since IDs might be mixed types
    const availableActivities = allActivities.filter(activity =>
        !alreadySelectedIds.has(activity.id.toString())
    );
    
    // Count popularity
    const popularityCounts = {};
    circlePrefs?.forEach(pref => {
        popularityCounts[pref.activity_id] = (popularityCounts[pref.activity_id] || 0) + 1;
    });
    
    // Sort activities by priority
    return availableActivities.sort((a, b) => {
        const aPopular = popularityCounts[a.id] || 0;
        const bPopular = popularityCounts[b.id] || 0;
        const aFrequent = activityCounts[a.id] || 0;
        const bFrequent = activityCounts[b.id] || 0;
        const aCore = coreActivityIds.includes(a.id) ? 1 : 0;
        const bCore = coreActivityIds.includes(b.id) ? 1 : 0;
        
        // Priority: popular > frequent > core > alphabetical
        if (aPopular !== bPopular) return bPopular - aPopular;
        if (aFrequent !== bFrequent) return bFrequent - aFrequent;
        if (aCore !== bCore) return bCore - aCore;
        return a.name.localeCompare(b.name);
    }).map(activity => ({
        ...activity,
        popularityCount: popularityCounts[activity.id] || 0
    }));
}

function filterSwipeActivities(searchTerm) {
    if (!searchTerm.trim()) {
        // No search term - reload all activities
        initializeSwipeView();
        return;
    }
    
    // Re-load and filter activities
    loadActivitiesForSwiping(selectedCircle.id).then(allActivities => {
        sortedActivities = allActivities.filter(a => 
            a.name.toLowerCase().includes(searchTerm.toLowerCase())
        );
        
        currentCardIndex = 0;
        swipeHistory = [];
        
        document.getElementById('card-stack').innerHTML = '';
        
        if (sortedActivities.length === 0) {
            document.getElementById('card-stack').innerHTML = 
                '<div class="empty-state"><div class="empty-state-icon"></div><div class="empty-state-title">No Matches Found</div><div class="empty-state-description">Try a different search term</div></div>';
            document.getElementById('swipe-progress').textContent = 'No results';
        } else {
            showNextCard();
        }
    });
}

function showNextCard() {
    if (currentCardIndex >= sortedActivities.length) {
    // All done!
    document.getElementById('card-stack').innerHTML = `
        <div style="text-align: center; padding: 60px;">
            <div style="font-size: 4em;"></div>
            <h2>All done!</h2>
            <p>You've reviewed all activities</p>
            <button class="btn" onclick="showPage('matches')">View Matches</button>
        </div>
    `;
    document.getElementById('swipe-progress').textContent = 'Complete!';
    return;
}

    const activity = sortedActivities[currentCardIndex];
    const card = renderSwipeCard(activity);
    // Replace card atomically to avoid flashing/delay
    document.getElementById('card-stack').replaceChildren(card);
    updateProgress();

    // Update cache with current position
    if (cachedSwipeState && cachedSwipeState.circleId === selectedCircle?.id) {
        cachedSwipeState.currentCardIndex = currentCardIndex;
    }
}

function updateProgress() {
    const total = sortedActivities.length;
    const current = Math.min(currentCardIndex + 1, total);
    document.getElementById('swipe-progress').textContent = `${current} of ${total}`;
}

function renderSwipeCard(activity) {
    const card = document.createElement('div');
    card.className = 'swipe-card';
    card.id = `card-${activity.id}`;

    // Check for dark mode
    const isDarkMode = document.body.classList.contains('dark-mode');
    const bgColor = isDarkMode ? '#1a1a1e' : 'white';
    const borderColor = isDarkMode ? '#2a2a2e' : '#e1e5e9';
    const textColor = isDarkMode ? '#e5e5e7' : '#1a1a1a';

    card.style.cssText = `
        position: absolute;
        width: 100%;
        max-width: 350px;
        height: 340px;
        background: ${bgColor};
        border: 3px solid ${borderColor};
        border-radius: 20px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 30px;
        cursor: grab;
        user-select: none;
        transition: transform 0.1s ease-out;
    `;

    const isAlreadySelected = activities.some(a => a.id === activity.id);

    card.innerHTML = `
        <div style="font-size: 4.5em; margin-bottom: 15px;">${activity.emoji}</div>
        <h2 style="font-size: 1.6em; margin-bottom: 10px; text-align: center; color: ${textColor};">${activity.name}</h2>
        ${activity.popularityCount > 0 ? `
            <div style="
                background: linear-gradient(135deg, #667eea, #764ba2);
                color: white;
                padding: 8px 16px;
                border-radius: 20px;
                font-size: 0.9em;
                margin-top: 10px;
            ">
                 ${activity.popularityCount} friend${activity.popularityCount > 1 ? 's' : ''} interested
            </div>
        ` : ''}
        ${isAlreadySelected ? `
            <div style="
                background: #4CAF50;
                color: white;
                padding: 6px 12px;
                border-radius: 15px;
                font-size: 0.85em;
                margin-top: 10px;
            ">
                 Already selected
            </div>
        ` : ''}
    `;

    setupSwipeDetection(card, activity);
    return card;
}

// Animation functions (must be defined before setupSwipeDetection)
async function animateSwipeRight(card, activity) {
    
    card.style.transition = 'all 0.3s ease-out';
    card.style.transform = 'translateX(500px) rotate(30deg)';
    card.style.opacity = '0';
    
    // Add to selected activities
    if (!activities.some(a => a.id === activity.id)) {
        activities.push(activity);
        console.log('Added activity to array');
    } else {
        console.log('Activity already in array - skipping');
    }
    
    console.log('activities array after add:', activities.map(a => a.id));
    
    // Save to history for undo
    swipeHistory.push({ activity, wasSelected: true });
    
    // Auto-save preference immediately
    const selectedActivityIds = activities.map(a => a.id);
    console.log('Saving to database:', selectedActivityIds.length, 'activities');
    await saveUserPreferences(selectedCircle.id, selectedActivityIds);

    // Check critical mass thresholds for this activity
    await checkCriticalMassThresholds(selectedCircle.id, activity.id);

    // Update activity counts
    activityCounts[activity.id] = (activityCounts[activity.id] || 0) + 1;
    localStorage.setItem('friendle_activity_counts', JSON.stringify(activityCounts));
    
    // Check if match exists and get other interested users
    const { data: existingMatch } = await supabase
        .from('matches')
        .select('id')
        .eq('circle_id', selectedCircle.id)
        .eq('activity_id', activity.id)
        .single();

    if (existingMatch) {
        // Get other users in the chat (not just interested - keeps users anonymous until they join)
        const { data: otherParticipants } = await supabase
            .from('match_participants')
            .select('profile_id, profiles(id, name, avatar)')
            .eq('match_id', existingMatch.id)
            .neq('profile_id', currentUser.id);

        const otherUsers = otherParticipants?.map(p => p.profiles) || [];

        // Show match notification if there are others in the chat
        if (otherUsers.length > 0) {
            showMatchNotification(activity, existingMatch.id, otherUsers);
        } else {
            // User is first to choose this activity - show "You're First!" popup
            showFirstToChoosePopup(activity, existingMatch.id);
        }
    } else {
        // No match exists yet - it will be created in checkForMatches
        // We'll show the "first to choose" popup after that
        console.log('Calling checkForMatches...');
        await checkForMatches();

        // Now get the newly created match
        const { data: newMatch } = await supabase
            .from('matches')
            .select('id')
            .eq('circle_id', selectedCircle.id)
            .eq('activity_id', activity.id)
            .single();

        if (newMatch) {
            showFirstToChoosePopup(activity, newMatch.id);
        }

        // Continue to load matches
        console.log('Calling loadMatches...');
        await loadMatches();

        // Don't advance to next card - wait for user to choose Plan Event or Stay Interested
        return; // Exit early since we already handled everything
    }

    console.log('Calling checkForMatches...');
    // Check for new matches and send notifications
    await checkForMatches();

    console.log('Calling loadMatches...');
    // Reload matches to see any changes
    await loadMatches();

    // Don't advance to next card - wait for user to choose Plan Event or Stay Interested
}

function animateSwipeLeft(card, activity) {
    card.style.transition = 'all 0.3s ease-out';
    card.style.transform = 'translateX(-500px) rotate(-30deg)';
    card.style.opacity = '0';
    
    // Remove from selected activities if it was there
    const index = activities.findIndex(a => a.id === activity.id);
    const wasSelected = index > -1;
    if (wasSelected) {
        activities.splice(index, 1);
    }
    
    // Save to history for undo
    swipeHistory.push({ activity, wasSelected });
    
    setTimeout(() => {
        currentCardIndex++;
        showNextCard();
    }, 300);
}

function setupSwipeDetection(card, activity) {
    let startX = 0;
    let startY = 0;
    let currentX = 0;
    let currentY = 0;
    let isDragging = false;
    
    // Touch events for mobile
    card.addEventListener('touchstart', (e) => {
        startX = e.touches[0].clientX;
        startY = e.touches[0].clientY;
        isDragging = true;
        card.style.cursor = 'grabbing';
    });
    
    card.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        
        currentX = e.touches[0].clientX;
        currentY = e.touches[0].clientY;
        const deltaX = currentX - startX;
        const deltaY = currentY - startY;
        
        // Move card and rotate slightly
        card.style.transform = `translateX(${deltaX}px) translateY(${deltaY}px) rotate(${deltaX * 0.1}deg)`;
        card.style.transition = 'none';
        
        // Color hint
        if (deltaX > 50) {
            card.style.borderColor = '#4CAF50'; // Green for like
        } else if (deltaX < -50) {
            card.style.borderColor = '#f44336'; // Red for pass
        } else {
            card.style.borderColor = '#e1e5e9';
        }
    });
    
    card.addEventListener('touchend', (e) => {
        if (!isDragging) return;
        isDragging = false;
        card.style.cursor = 'grab';
        
        const deltaX = currentX - startX;
        
        if (deltaX > 100) {
            // Swiped right - interested
            animateSwipeRight(card, activity);
        } else if (deltaX < -100) {
            // Swiped left - pass
            animateSwipeLeft(card, activity);
        } else {
            // Reset position
            card.style.transition = 'transform 0.3s ease-out';
            card.style.transform = '';
            card.style.borderColor = '#e1e5e9';
        }
    });
    
    // Mouse events for desktop
    card.addEventListener('mousedown', (e) => {
        startX = e.clientX;
        startY = e.clientY;
        isDragging = true;
        card.style.cursor = 'grabbing';
    });
    
    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        currentX = e.clientX;
        currentY = e.clientY;
        const deltaX = currentX - startX;
        const deltaY = currentY - startY;
        
        // Move card and rotate slightly
        card.style.transform = `translateX(${deltaX}px) translateY(${deltaY}px) rotate(${deltaX * 0.1}deg)`;
        card.style.transition = 'none';
        
        // Color hint
        if (deltaX > 50) {
            card.style.borderColor = '#4CAF50';
        } else if (deltaX < -50) {
            card.style.borderColor = '#f44336';
        } else {
            card.style.borderColor = '#e1e5e9';
        }
    });
    
    document.addEventListener('mouseup', (e) => {
        if (!isDragging) return;
        isDragging = false;
        card.style.cursor = 'grab';
        
        const deltaX = currentX - startX;
        
        if (deltaX > 100) {
            animateSwipeRight(card, activity);
        } else if (deltaX < -100) {
            animateSwipeLeft(card, activity);
        } else {
            card.style.transition = 'transform 0.3s ease-out';
            card.style.transform = '';
            card.style.borderColor = '#e1e5e9';
        }
    });
}

function animateSwipeLeft(card, activity) {
    card.style.transition = 'all 0.3s ease-out';
    card.style.transform = 'translateX(-500px) rotate(-30deg)';
    card.style.opacity = '0';
    
    // Remove from selected activities if it was there
    const index = activities.findIndex(a => a.id === activity.id);
    const wasSelected = index > -1;
    if (wasSelected) {
        activities.splice(index, 1);
    }
    
    // Save to history for undo
    swipeHistory.push({ activity, wasSelected });
    
    setTimeout(() => {
        currentCardIndex++;
        showNextCard();
    }, 300);
}

// Button functions for non-touch devices
window.swipeRight = function() {
    if (currentCardIndex >= sortedActivities.length) return;
    
    const card = document.getElementById(`card-${sortedActivities[currentCardIndex].id}`);
    const activity = sortedActivities[currentCardIndex];
    
    if (card) {
        animateSwipeRight(card, activity);
    }
}

window.swipeLeft = function() {
    if (currentCardIndex >= sortedActivities.length) return;
    
    const card = document.getElementById(`card-${sortedActivities[currentCardIndex].id}`);
    const activity = sortedActivities[currentCardIndex];
    
    if (card) {
        animateSwipeLeft(card, activity);
    }
}

window.undoSwipe = async function() {
    
    if (swipeHistory.length === 0) {
        showNotification('Nothing to undo', 'error');
        return;
    }
    
    const lastAction = swipeHistory.pop();
    console.log('Undoing action:', lastAction);
    
    // Reverse the swipe action
    if (lastAction.wasSelected) {
        // If they swiped right (selected), now remove it
        const index = activities.findIndex(a => a.id === lastAction.activity.id);
        if (index > -1) {
            activities.splice(index, 1);
            console.log('Removed activity:', lastAction.activity.id);
        }
    } else {
        // If they swiped left (passed), now add it back
        if (!activities.some(a => a.id === lastAction.activity.id)) {
            activities.push(lastAction.activity);
            console.log('Added back activity:', lastAction.activity.id);
        }
    }
    
    console.log('activities AFTER undo:', activities.map(a => a.id));
    
    // Save the reverted preference state immediately
    const selectedActivityIds = activities.map(a => a.id);
    console.log('Saving preferences:', selectedActivityIds);
    await saveUserPreferences(selectedCircle.id, selectedActivityIds);
    
    console.log('Skipping loadMatches to avoid auto-join');
    // Don't call loadMatches here - it might trigger auto-join logic
    // await loadMatches();
    
    // Go back one card
    currentCardIndex = Math.max(0, currentCardIndex - 1);
    showNextCard();
    
    console.log('=== UNDO END ===');
    showNotification('Undone!');
}

async function loadActivities(circleId) {
    try {
        // Load custom activities and visibility settings in parallel
        const [customResult, visibilityResult] = await Promise.all([
            supabase
                .from('activities')
                .select('*')
                .eq('circle_id', circleId),
            supabase
                .from('circle_activities')
                .select('activity_id, is_visible')
                .eq('circle_id', circleId)
        ]);

        if (customResult.error) throw customResult.error;
        if (visibilityResult.error) throw visibilityResult.error;

        const customActivities = customResult.data;
        const circleActivities = visibilityResult.data;

        const visibilityMap = {};
        circleActivities?.forEach(ca => {
            visibilityMap[ca.activity_id] = ca.is_visible;
        });

        const visibleDefaultActivities = defaultActivities.filter(a => {
            if (visibilityMap.hasOwnProperty(a.id)) {
                return visibilityMap[a.id];
            }
            return coreActivityIds.includes(a.id);
        });

        return [...visibleDefaultActivities, ...customActivities];
    } catch (error) {
        console.error('Error loading activities:', error);
        return [];
    }
}

let coreActivityIds = [];
let extendedActivityIds = [];
let defaultActivities = [];

async function loadDefaultActivities() {
    try {
        // Load all default activities from database (where circle_id is null)
        const { data, error } = await supabase
            .from('activities')
            .select('*')
            .is('circle_id', null);

        if (error) throw error;

        defaultActivities = data || [];

        // Warn if no default activities found
        if (!defaultActivities || defaultActivities.length === 0) {
            console.warn(' No default activities found in database! Users will need to create custom activities.');
            console.warn('To fix: Run MIGRATION_seed_default_activities.sql in your Supabase SQL editor.');
            defaultActivities = [];
        }

        // Split into core and extended based on a category or naming convention
        // For now, let's say activities with IDs < 200 are core (adjust as needed)
        coreActivityIds = defaultActivities.filter(a => {
            // Define which activities are "core" - adjust these names as needed
            const coreNames = ['Coffee', 'Dinner', 'Drinks', 'Brunch', 'Pizza Night', 'Ice Cream',
                               'Hiking', 'Beach', 'Bowling', 'Walk in the Park',
                               'Movie', 'Trivia Night', 'Arcade', 'Board Games'];
            return coreNames.includes(a.name);
        }).map(a => a.id);

        extendedActivityIds = defaultActivities.filter(a => !coreActivityIds.includes(a.id)).map(a => a.id);

        console.log('Loaded default activities:', defaultActivities.length, 'activities');
        console.log('Core activity IDs:', coreActivityIds.length, 'core activities');
        console.log('Extended activity IDs:', extendedActivityIds.length, 'extended activities');

    } catch (error) {
        console.error('Error loading default activities:', error);
        defaultActivities = [];
        coreActivityIds = [];
        extendedActivityIds = [];
    }
}
        // Activity Management
        async function renderActivities(searchTerm = '') {
     		// Check if no circle is selected
    if (!selectedCircle) {
        document.getElementById('activities-grid').innerHTML = '<div style="text-align: center; padding: 40px 20px; color: #666;"><div style="font-size: 3em; margin-bottom: 20px;"></div><h3 style="margin-bottom: 15px; color: #333;">Select a Circle First</h3><p>Choose a circle from the dropdown above to see available activities.</p></div>';
        document.getElementById('frequent-grid').innerHTML = '';
        document.getElementById('frequent-section').style.display = 'none';
        return;
    }

    const frequentGrid = document.getElementById('frequent-grid');
    const activitiesGrid = document.getElementById('activities-grid');
    frequentGrid.innerHTML = ''; 
    activitiesGrid.innerHTML = '';
    
    const sortedCounts = Object.entries(activityCounts).sort(([,a],[,b]) => b-a);
    const frequentIds = sortedCounts.slice(0, 4).map(([id]) => parseInt(id));

    // Load activities and availability data in parallel
    const [allPossibleActivities, availabilityMap] = await Promise.all([
        loadActivities(selectedCircle.id),
        loadAllActivityAvailability()
    ]);

    const filteredActivities = allPossibleActivities.filter(a =>
        a.name.toLowerCase().includes(searchTerm.toLowerCase())
    );

    const frequentActivities = filteredActivities.filter(a => frequentIds.includes(a.id));
    document.getElementById('frequent-section').style.display =
        frequentActivities.length > 0 && !searchTerm ? 'block' : 'none';
    for (const activity of frequentActivities) {
        createActivityCard(activity, frequentGrid, availabilityMap);
    }

    const nonFrequentActivities = filteredActivities.filter(a => !frequentIds.includes(a.id));
    for (const activity of nonFrequentActivities) {
        createActivityCard(activity, activitiesGrid, availabilityMap);
    }
}
        function createActivityCard(activity, grid, availabilityMap) {
    const card = document.createElement('div');
    card.className = 'activity-card';
    card.dataset.activityId = activity.id;

    const isSelected = activities.some(a => a.id === activity.id);
    if (isSelected) card.classList.add('selected');

    // Check if marked as "today" using the pre-loaded availability map
    const isToday = availabilityMap && availabilityMap.has(activity.id);

    card.innerHTML = `
        <div class="activity-emoji">${activity.emoji}</div>
        <div class="activity-name">${activity.name}</div>
    `;

    card.onclick = (event) => {
        event.stopPropagation();
        toggleActivity(card, activity);
    };

    grid.appendChild(card);
}

// Batch load all activity availability data for the current circle
async function loadAllActivityAvailability() {
    if (!selectedCircle || !currentUser) return new Map();

    try {
        const { data, error } = await supabase
            .from('activity_availability')
            .select('activity_id, available_until')
            .eq('profile_id', currentUser.id)
            .eq('circle_id', selectedCircle.id);

        if (error) throw error;

        const availabilityMap = new Map();
        const now = new Date();
        const toDelete = [];

        if (data) {
            for (const item of data) {
                const availableUntil = new Date(item.available_until);
                if (availableUntil > now) {
                    availabilityMap.set(parseInt(item.activity_id), true);
                } else {
                    // Mark expired items for deletion
                    toDelete.push(item.activity_id);
                }
            }

            // Clean up expired items in the background
            if (toDelete.length > 0) {
                supabase
                    .from('activity_availability')
                    .delete()
                    .eq('profile_id', currentUser.id)
                    .eq('circle_id', selectedCircle.id)
                    .in('activity_id', toDelete)
                    .then(() => {})
                    .catch(err => console.error('Error cleaning up expired availability:', err));
            }
        }

        return availabilityMap;
    } catch (error) {
        console.error('Error loading activity availability:', error);
        return new Map();
    }
}

async function isActivityAvailableToday(activityId) {
    if (!selectedCircle || !currentUser) return false;

    try {
        const { data, error } = await supabase
            .from('activity_availability')
            .select('available_until')
            .eq('profile_id', currentUser.id)
            .eq('circle_id', selectedCircle.id)
            .eq('activity_id', activityId.toString())
            .maybeSingle();

        if (error) throw error;

        // Check if still valid
        if (data && new Date(data.available_until) > new Date()) {
            return true;
        }

        // If expired, clean it up
        if (data) {
            await supabase
                .from('activity_availability')
                .delete()
                .eq('profile_id', currentUser.id)
                .eq('circle_id', selectedCircle.id)
                .eq('activity_id', activityId.toString());
        }

        return false;
    } catch (error) {
        console.error('Error checking activity availability:', error);
        return false;
    }
}

window.setActivityMode = async function(activityId, isToday) {
    if (!selectedCircle) return;
    
    try {
        if (isToday) {
            // Set to TODAY
            const endOfDay = new Date();
            endOfDay.setHours(23, 59, 59, 999);
            
            await supabase
                .from('activity_availability')
                .upsert({
                    profile_id: currentUser.id,
                    circle_id: selectedCircle.id,
                    activity_id: activityId.toString(),
                    available_until: endOfDay.toISOString()
                }, {
                    onConflict: 'profile_id,circle_id,activity_id'
                });
            
            showNotification('Available for this activity today!');
        } else {
            // Set to ANYTIME (remove from today)
            await supabase
                .from('activity_availability')
                .delete()
                .eq('profile_id', currentUser.id)
                .eq('circle_id', selectedCircle.id)
                .eq('activity_id', activityId.toString());
            
            showNotification('Switched to "Anytime"');
        }
        
        // Refresh the card
        await renderActivities();
        
        // Refresh matches
        await checkForMatches();
        
    } catch (error) {
        console.error('Error setting activity mode:', error);
        showNotification('Error updating availability', 'error');
    }
}

        function toggleActivity(card, activity) {
            lastActivitiesState = [...activities];
            card.classList.toggle('selected');
            const index = activities.findIndex(a => a.id === activity.id);
            if (index > -1) activities.splice(index, 1);
            else activities.push(activity);
        }
        window.handleSearch = async (event) => {
    const searchTerm = event.target.value;

    if (viewMode === 'grid') {
        await renderActivities(searchTerm);
    } else {
        filterSwipeActivities(searchTerm);
    }
}
        window.saveActivities = async function() {
    if (!selectedCircle) return showNotification('Please select a circle first', 'error');

    // SECURITY: Rate limiting - max 10 preference updates per minute
    if (!RateLimiter.checkLimit('save_activities', 10, 60000)) {
        return showNotification('Please wait before saving again.', 'error');
    }

    // Hide the save button immediately to prevent visual shifting
    const saveButton = document.getElementById('grid-save-button');
    if (saveButton) saveButton.style.display = 'none';

    showLoader('Saving preferences...');

    try {
        const selectedActivityIds = activities.map(activity => activity.id);
        
        // Get previously selected activities to find what was deselected
        const previousPrefs = await loadUserPreferences(selectedCircle.id);
        const deselectedActivityIds = previousPrefs.filter(id => !selectedActivityIds.includes(id));
        
        // For each deselected activity, check if user has any events
        for (const activityId of deselectedActivityIds) {
            // Find the match for this activity
            const { data: match } = await supabase
                .from('matches')
                .select('id')
                .eq('circle_id', selectedCircle.id)
                .eq('activity_id', activityId)
                .single();
            
            if (match) {
                // Check if user has any events for this match
                const { data: userEvents } = await supabase
                    .from('event_participants')
                    .select('event_id, events!inner(match_id)')
                    .eq('profile_id', currentUser.id)
                    .eq('events.match_id', match.id);
                
                // If no events, remove user from match participants
                if (!userEvents || userEvents.length === 0) {
                    await supabase
                        .from('match_participants')
                        .delete()
                        .eq('match_id', match.id)
                        .eq('profile_id', currentUser.id);
                }
            }
        }
        
        // Save new preferences
        await saveUserPreferences(selectedCircle.id, selectedActivityIds);
        
        activities.forEach(act => { 
            activityCounts[act.id] = (activityCounts[act.id] || 0) + 1; 
        });
        localStorage.setItem('friendle_activity_counts', JSON.stringify(activityCounts));
        
        await checkForMatches();
        await loadMatches();
        
        hideLoader();
        showPage('matches');
        
    } catch (error) {
        hideLoader();
        // Restore the save button if there's an error
        const saveButton = document.getElementById('grid-save-button');
        if (saveButton) saveButton.style.display = '';
        console.error('Error saving activities:', error);
        showNotification('Error saving preferences', 'error');
    }
}
        window.openSuggestModal = () => {
    document.getElementById('suggest-modal-overlay').style.display = 'flex';
}
        window.closeSuggestModal = () => document.getElementById('suggest-modal-overlay').style.display = 'none';
        window.suggestActivity = async function() {
    const name = document.getElementById('suggest-name').value.trim();
    if (!name) { 
        return showNotification('Please provide an activity name', 'error'); 
    }

    try {
        // Check if we're in circle creation mode (no selectedCircle yet)
        const isCircleCreation = !selectedCircle;
        
        if (isCircleCreation) {
            // Save current selections before re-rendering
            const currentlySelected = new Set(
                Array.from(document.querySelectorAll('#circle-creation-activities-grid .activity-card.selected'))
                    .map(card => card.dataset.activityId)
            );
            
            // Add to default activities temporarily (for this session only)
            const newActivity = {
                id: 'temp_' + Date.now(), // Temporary ID
                name: name,
                emoji: '',
                category: 'custom',
                circle_id: null // Will be set when circle is created
            };
            
            defaultActivities.push(newActivity);

            showNotification(`Activity "${name}" added and selected!`);
            document.getElementById('suggest-name').value = '';
            closeSuggestModal();

            // Re-render circle creation activities with previous selections + new one
            await renderCircleCreationActivities(currentlySelected, newActivity.id);
            
        } else {
            // Normal flow - circle already exists
            const { data, error } = await supabase
                .from('activities')
                .insert([{
                    name: name,
                    emoji: '',
                    category: 'custom',
                    circle_id: selectedCircle.id
                }])
                .select()
                .single();

            if (error) throw error;

            showNotification(`Activity "${name}" added!`);
            document.getElementById('suggest-name').value = '';
            closeSuggestModal();

            // Send notifications to all circle members
            sendNewActivityNotification(selectedCircle.id, data, currentUser.name).catch(err => {
                console.error('Failed to send new activity notification:', err);
            });

            const savedActivityIds = await loadUserPreferences(selectedCircle.id);
            const allActivities = await loadActivities(selectedCircle.id);
            activities = allActivities.filter(activity => savedActivityIds.includes(activity.id));

            renderActivities();
        }
    } catch (error) {
        console.error('Error adding custom activity:', error);
        showNotification('Error adding activity', 'error');
    }
}
        
        window.undoLastActivityChange = function() {
            activities = [...lastActivitiesState];
            renderActivities();
            document.getElementById('undo-container').style.display = 'none';
            clearTimeout(undoTimeout);
        }
async function findMatches(circleId) {
    try {
        // Get current user's preferences
        const userPrefs = await loadUserPreferences(circleId);
        if (userPrefs.length === 0) {
            return [];
        }

        const groupMatches = [];

        // For each activity the user likes, find or create a match
        for (const activityId of userPrefs) {

            // BUGFIX: Use upsert to prevent race condition duplicates
            // First, try to get existing match
            const { data: existingMatches } = await supabase
                .from('matches')
                .select('id, circle_id, activity_id, created_at')
                .eq('circle_id', circleId)
                .eq('activity_id', activityId)
                .limit(1);

            let match = existingMatches?.[0] || null;

            if (!match) {
                // Create new match - wrap in try/catch to handle potential duplicate race condition
                try {
                    const { data: newMatch, error: createError } = await supabase
                        .from('matches')
                        .insert([{
                            circle_id: circleId,
                            activity_id: activityId
                        }])
                        .select('*')
                        .single();

                    if (createError) {
                        // If insert failed, likely due to race condition - query again
                        console.log('Insert failed, re-querying for match:', createError.message);
                        const { data: retryMatch } = await supabase
                            .from('matches')
                            .select('id, circle_id, activity_id, created_at')
                            .eq('circle_id', circleId)
                            .eq('activity_id', activityId)
                            .limit(1)
                            .single();

                        match = retryMatch;
                        if (!match) {
                            console.error('Could not create or find match:', createError);
                            continue;
                        }
                    } else {
                        match = newMatch;
                    }
                } catch (err) {
                    console.error('Error in match creation:', err);
                    continue;
                }
            }

            // Get all users who swiped right (interested but anonymous count)
            const { data: interestedUsers, error: prefsError } = await supabase
                .from('preferences')
                .select('profile_id')
                .eq('circle_id', circleId)
                .eq('activity_id', activityId)
                .eq('selected', true);

            if (prefsError) {
                console.error('Error loading interested users:', prefsError);
            }

            const interestedCount = interestedUsers?.length || 0;

            // Get who's actually in the chat (revealed their identity by joining)
            const { data: chatParticipants, error: chatError } = await supabase
                .from('match_participants')
                .select('profile_id, profiles(id, name, avatar)')
                .eq('match_id', match.id);

            if (chatError) {
                console.error('Error loading chat participants:', chatError);
            }

            const chatParticipantIds = new Set(chatParticipants?.map(p => p.profile_id) || []);
            const userInChat = chatParticipantIds.has(currentUser.id);

            // Get activity details
            const activity = activities.find(a => a.id === activityId);
            if (!activity) {
                // Load activity if not in current array
                const { data: activityData } = await supabase
                    .from('activities')
                    .select('*')
                    .eq('id', activityId)
                    .single();

                if (activityData) {
                    activities.push(activityData);
                }
            }

            groupMatches.push({
                id: match.id,
                circleId: circleId,
                activity: activity || activities.find(a => a.id === activityId),
                interestedUsers: chatParticipants?.map(p => p.profiles) || [],
                interestedCount: interestedCount,
                inChatCount: chatParticipants?.length || 0,
                userInChat: userInChat,
                isRead: true // We'll handle notifications differently now
            });
        }

        return groupMatches;
    } catch (error) {
        console.error('Error finding matches:', error);
        return [];
    }
}

// Helper function to check if user is in match chat
async function isUserInMatchChat(matchId) {
    try {
        const { data: existing } = await supabase
            .from('match_participants')
            .select('profile_id')
            .eq('match_id', matchId)
            .eq('profile_id', currentUser.id)
            .maybeSingle();

        return !!existing;
    } catch (error) {
        console.error('Error checking match chat participation:', error);
        return false;
    }
}

// Helper function to join match chat
async function joinMatchChat(matchId) {
    try {
        // Check if already in chat
        const { data: existing } = await supabase
            .from('match_participants')
            .select('profile_id')
            .eq('match_id', matchId)
            .eq('profile_id', currentUser.id)
            .maybeSingle();

        if (existing) {
            console.log('Already in chat');
            return true;
        }

        // Add to match_participants
        const { error } = await supabase
            .from('match_participants')
            .insert([{
                match_id: matchId,
                profile_id: currentUser.id
            }]);

        if (error) throw error;

        console.log(' Joined match chat');
        return true;

    } catch (error) {
        console.error('Error joining match chat:', error);
        return false;
    }
}

// Helper function to leave match chat
async function leaveMatchChat(matchId) {
    try {
        // First, remove user from all event participants for events in this match
        const { data: userEvents } = await supabase
            .from('event_participants')
            .select('event_id, events!inner(match_id)')
            .eq('profile_id', currentUser.id)
            .eq('events.match_id', matchId);

        if (userEvents && userEvents.length > 0) {
            const eventIds = userEvents.map(e => e.event_id);
            const { error: eventError } = await supabase
                .from('event_participants')
                .delete()
                .eq('profile_id', currentUser.id)
                .in('event_id', eventIds);

            if (eventError) throw eventError;
        }

        // Then remove from match participants
        const { error } = await supabase
            .from('match_participants')
            .delete()
            .eq('match_id', matchId)
            .eq('profile_id', currentUser.id);

        if (error) throw error;

        console.log(' Left match chat');
        return true;

    } catch (error) {
        console.error('Error leaving match chat:', error);
        return false;
    }
}

// Join chat as first person
// Deprecated: Match chat replaced with event-based planning
// Functions removed: joinMatchChatFirst, skipJoinChat

// Stay Interested - reset inactivity timer
window.stayInterested = async function(matchId) {
    try {
        showLoader('Updating...');

        // Call edge function to update last_interaction_at
        const { data, error } = await supabase.functions.invoke('stay-interested', {
            body: {
                matchId: matchId,
                profileId: currentUser.id
            }
        });

        if (error) throw error;

        hideLoader();
        showNotification('Great! We\'ll keep you in the match.');

        // Reload matches to update UI
        await loadMatches();
    } catch (error) {
        console.error('Error updating interaction:', error);
        hideLoader();
        showNotification('Failed to update. Please try again.', 'error');
    }
}

// Mark as uninterested - remove from match
window.markAsUninterested = async function(matchId, activityId, circleId) {
    try {
        // Confirm with user
        if (!confirm('Are you sure you want to remove this activity from your preferences? You can always add it back later.')) {
            return;
        }

        showLoader('Removing activity...');

        // Check if user has any events for this match
        const { data: userEvents } = await supabase
            .from('event_participants')
            .select('event_id, events!inner(match_id)')
            .eq('profile_id', currentUser.id)
            .eq('events.match_id', matchId);

        // Remove user's preference for this activity
        const { error: prefError } = await supabase
            .from('preferences')
            .delete()
            .eq('profile_id', currentUser.id)
            .eq('circle_id', circleId)
            .eq('activity_id', activityId);

        if (prefError) throw prefError;

        // Remove user from event participants for all events in this match
        if (userEvents && userEvents.length > 0) {
            const eventIds = userEvents.map(e => e.event_id);
            const { error: eventParticipantError } = await supabase
                .from('event_participants')
                .delete()
                .eq('profile_id', currentUser.id)
                .in('event_id', eventIds);

            if (eventParticipantError) throw eventParticipantError;
        }

        // Remove user from match participants
        const { error: participantError } = await supabase
            .from('match_participants')
            .delete()
            .eq('match_id', matchId)
            .eq('profile_id', currentUser.id);

        if (participantError) throw participantError;

        hideLoader();
        showNotification('Activity removed from your preferences');

        // Reload matches to update UI
        await loadMatches();
    } catch (error) {
        console.error('Error marking as uninterested:', error);
        hideLoader();
        showNotification('Failed to remove activity. Please try again.', 'error');
    }
}

// Join chat as normal (not first)
window.joinMatchChatNormal = async function(matchId) {
    showLoader('Joining chat...');

    const success = await joinMatchChat(matchId);

    if (success) {
        hideLoader();
        showNotification('Joined match!');
        await loadMatches();
    } else {
        hideLoader();
        showNotification('Error joining match', 'error');
    }
}

// Open threaded chat view
// Match chat has been replaced with event-based planning
// This stub exists for backward compatibility with old notifications
// Deprecated match chat functions removed - now using event-based planning system

function createEventCard(event, matchId, isPast = false) {
    const eventCard = document.createElement('div');

    // Check if user has joined this event
    const isUserJoined = event.event_participants?.some(p => p.profile_id === currentUser.id) || false;

    // Apply CSS classes instead of inline styles
    eventCard.className = 'event-item';
    if (!isUserJoined && !isPast) {
        eventCard.className += ' pending';
    }
    if (isPast) {
        eventCard.style.cssText = `opacity: 0.7; background: var(--card-bg);`;
    }

    // Format date and time
    const date = event.scheduled_date ? new Date(event.scheduled_date) : null;
    const dateStr = date ? date.toLocaleDateString('en-US', {
        weekday: 'short',
        month: 'short',
        day: 'numeric'
    }) : 'Date TBD';

    // Format time if available (convert 24h to 12h format)
    let timeStr = '';
    if (event.scheduled_time) {
        const [hours, minutes] = event.scheduled_time.split(':');
        const hour = parseInt(hours);
        const ampm = hour >= 12 ? 'PM' : 'AM';
        const displayHour = hour === 0 ? 12 : (hour > 12 ? hour - 12 : hour);
        timeStr = `, ${displayHour}:${minutes} ${ampm}`;
    }

    // Get participant count and check capacity
    const participantCount = event.event_participants?.length || 0;
    const maxParticipants = event.max_participants;
    const isFull = maxParticipants && participantCount >= maxParticipants;

    // Format participant display: "X/Y" if limit set, otherwise just "X"
    const participantDisplay = maxParticipants
        ? `${participantCount}/${maxParticipants}`
        : `${participantCount}`;
    const participantLabel = participantCount === 1 ? 'person' : 'people';

    eventCard.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; gap: 10px;">
            <div style="flex: 1;">
                <div style="font-weight: 500; margin-bottom: 6px; font-size: 15px; display: flex; align-items: center; gap: 6px;">
                     ${dateStr}${timeStr}
                </div>
                ${event.location ? `<div class="event-meta" style="font-size: 13px;"> ${event.location}</div>` : ''}
                <div class="event-meta" style="font-size: 12px; margin-top: 4px; cursor: pointer; text-decoration: underline;" onclick="event.stopPropagation(); showEventAttendees('${event.id}')" title="Click to view attendees">${participantDisplay} ${participantLabel} ${isUserJoined ? 'going' : 'interested'}${isFull && !isUserJoined ? ' (full)' : ''}</div>
            </div>
            ${isUserJoined ? `
                <button class="event-chat-btn btn btn-secondary" data-event-id="${event.id}" style="font-size: 13px; padding: 6px 12px; width: auto; margin: 0; white-space: nowrap;">
                     Event Chat
                </button>
            ` : isFull ? `
                <button class="btn" disabled style="font-size: 13px; padding: 6px 12px; width: auto; margin: 0; white-space: nowrap; background: #888; cursor: not-allowed;">
                    Event Full
                </button>
            ` : participantCount === 0 ? `
                <div style="display: flex; flex-direction: column; gap: 6px;">
                    <button class="join-event-btn btn" data-event-id="${event.id}" style="font-size: 13px; padding: 6px 12px; width: auto; margin: 0; white-space: nowrap; background: #4CAF50;">
                         Join Event
                    </button>
                    <button class="delete-event-btn btn btn-secondary" data-event-id="${event.id}" style="font-size: 11px; padding: 4px 8px; width: auto; margin: 0; white-space: nowrap; background: #dc3545; color: white;">
                         Delete
                    </button>
                </div>
            ` : `
                <button class="join-event-btn btn" data-event-id="${event.id}" style="font-size: 13px; padding: 6px 12px; width: auto; margin: 0; white-space: nowrap; background: #4CAF50;">
                     Join Event
                </button>
            `}
        </div>
    `;

    // Add event listeners properly instead of inline onclick
    const eventChatBtn = eventCard.querySelector('.event-chat-btn');
    if (eventChatBtn) {
        eventChatBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            openEventChat(event.id);
        });
    }

    const joinBtns = eventCard.querySelectorAll('.join-event-btn');
    joinBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            joinEvent(btn.dataset.eventId);
        });
    });

    const deleteBtn = eventCard.querySelector('.delete-event-btn');
    if (deleteBtn) {
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            deleteEmptyEvent(deleteBtn.dataset.eventId);
        });
    }

    return eventCard;
}

// Message Pagination Helper Functions
function createLoadOlderButton(chatType) {
    const messagesContainer = document.getElementById('chat-messages');
    const existingButton = document.getElementById('load-older-messages-btn');

    // Remove existing button if present
    if (existingButton) {
        existingButton.remove();
    }

    // Check if we have more messages to load
    if (!messagePagination[chatType].hasMore) {
        return;
    }

    const buttonContainer = document.createElement('div');
    buttonContainer.id = 'load-older-messages-btn';
    buttonContainer.style.cssText = `
        padding: 12px;
        text-align: center;
        border-bottom: 1px solid var(--border-color);
        background: var(--bg-secondary);
    `;

    const loadButton = document.createElement('button');
    loadButton.style.cssText = `
        background: var(--primary-color);
        color: white;
        border: none;
        border-radius: 8px;
        padding: 10px 20px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        width: 100%;
        max-width: 200px;
    `;
    loadButton.textContent = messagePagination[chatType].loading ? 'Loading...' : 'Load older messages';
    loadButton.disabled = messagePagination[chatType].loading;
    loadButton.onclick = () => loadOlderMessages(chatType);

    loadButton.onmouseover = function() {
        if (!this.disabled) this.style.background = 'var(--primary-hover)';
    };
    loadButton.onmouseout = function() {
        this.style.background = 'var(--primary-color)';
    };

    buttonContainer.appendChild(loadButton);

    // Insert at the beginning of messages container
    messagesContainer.insertBefore(buttonContainer, messagesContainer.firstChild);
}

async function loadOlderMessages(chatType) {
    if (messagePagination[chatType].loading || !messagePagination[chatType].hasMore) {
        return;
    }

    const messagesContainer = document.getElementById('chat-messages');
    const scrollHeightBefore = messagesContainer.scrollHeight;
    const scrollTopBefore = messagesContainer.scrollTop;

    messagePagination[chatType].loading = true;

    // Update button to show loading state
    const button = document.querySelector('#load-older-messages-btn button');
    if (button) {
        button.textContent = 'Loading...';
        button.disabled = true;
    }

    try {
        let messages, error;
        const offset = messagePagination[chatType].loadedCount;

        if (chatType === 'match') {
            const matchId = currentMatchId;
            const result = await supabase
                .from('match_messages')
                .select('*, sender:profiles(id, name, avatar)')
                .eq('match_id', matchId)
                .order('created_at', { ascending: false })
                .range(offset, offset + MESSAGE_PAGE_SIZE - 1);

            messages = result.data;
            error = result.error;

        } else if (chatType === 'event') {
            const context = getCurrentChatContext();
            const result = await supabase
                .from('event_messages')
                .select('*, sender:profiles(id, name, avatar)')
                .eq('event_id', context.id)
                .order('created_at', { ascending: false })
                .range(offset, offset + MESSAGE_PAGE_SIZE - 1);

            messages = result.data;
            error = result.error;

        } else if (chatType === 'circle') {
            const circleId = currentCircleChat?.id;
            const result = await supabase
                .from('circle_messages')
                .select('*, sender:profiles(id, name, avatar)')
                .eq('circle_id', circleId)
                .order('created_at', { ascending: false })
                .range(offset, offset + MESSAGE_PAGE_SIZE - 1);

            messages = result.data;
            error = result.error;
        }

        if (error) throw error;

        // Reverse to show oldest first (since we queried descending)
        if (messages) {
            messages.reverse();
        }

        // Update pagination state
        messagePagination[chatType].loadedCount += messages.length;
        messagePagination[chatType].hasMore = messages.length === MESSAGE_PAGE_SIZE;
        messagePagination[chatType].loading = false;

        // Remove the load button temporarily
        const loadButton = document.getElementById('load-older-messages-btn');
        if (loadButton) loadButton.remove();

        // Get reference to first message for scroll position calculation
        const firstMessageBefore = messagesContainer.querySelector('[data-message-id]');

        // Prepend older messages
        if (messages && messages.length > 0) {
            // Create a document fragment to batch DOM operations
            const fragment = document.createDocumentFragment();
            const tempContainer = document.createElement('div');

            messages.forEach(message => {
                const isOwnMessage = message.sender_id === currentUser.id;
                const messageTime = formatMessageTimestamp(message.created_at);

                const context = getCurrentChatContext();
                const messageType = context.type;

                const sanitizedContent = message.is_deleted
                    ? '<span style="font-style: italic;">[Deleted]</span>'
                    : sanitizeHTML(message.content);
                const sanitizedSenderName = sanitizeHTML(message.sender.name);
                const escapedContentForEdit = message.content.replace(/`/g, '\\`').replace(/\$/g, '\\$').replace(/'/g, "\\'");

                const messageDiv = document.createElement('div');
                messageDiv.setAttribute('data-message-id', message.id);
                messageDiv.style.cssText = `
                    display: flex;
                    flex-direction: column;
                    align-items: ${isOwnMessage ? 'flex-end' : 'flex-start'};
                    margin-bottom: 15px;
                    width: 100%;
                `;

                messageDiv.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; ${isOwnMessage ? 'flex-direction: row-reverse;' : ''}">
                        ${renderAvatar(message.sender.avatar, 32)}
                        <span style="font-size: 13px; color: #666; font-weight: 500;">
                            ${isOwnMessage ? 'You' : sanitizedSenderName}
                        </span>
                        <span style="font-size: 11px; color: #999;">
                            ${messageTime}
                        </span>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: flex-start; ${isOwnMessage ? 'flex-direction: row-reverse;' : ''}; max-width: 100%;">
                        <div style="background: ${message.is_deleted ? 'var(--bg-secondary)' : (isOwnMessage ? '#4CAF50' : '#f0f0f0')}; color: ${message.is_deleted ? 'var(--text-secondary)' : (isOwnMessage ? 'white' : 'black')}; padding: 10px 14px; border-radius: 12px; max-width: 280px; word-wrap: break-word; overflow-wrap: break-word;">
                            ${sanitizedContent}
                        </div>
                        ${!message.is_deleted ? `
                            <div class="message-actions" style="position: relative;">
                                <button onclick="toggleEventMessageActions('${message.id}')" style="background: none; border: none; color: #aaa; cursor: pointer; font-size: 1.2em; padding: 5px;"></button>
                                <div id="event-menu-${message.id}" class="message-actions-menu">
                                    ${isOwnMessage ? `
                                        ${!message.content.includes('<img') && !message.content.includes('<a') ? `<button onclick="editEventMessage('${message.id}', \`${escapedContentForEdit}\`)"> Edit</button>` : ''}
                                        <button onclick="deleteEventMessage('${message.id}')" class="delete-btn"> Delete</button>
                                    ` : `
                                        <button onclick="openReportModal('message', '${message.id}', '${sanitizedSenderName}', '${message.sender_id}')"> Report</button>
                                        <button onclick="openBlockUserModal('${message.sender_id}', '${sanitizedSenderName}')"> Block User</button>
                                    `}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                    <div class="message-reactions-wrapper" style="margin-top: 4px; display: flex; gap: 6px; align-items: center; flex-wrap: wrap;">
                        <button
                            onclick="showReactionPicker('${message.id}', '${messageType}', event)"
                            style="
                                background: none;
                                border: 1px solid var(--border-color);
                                border-radius: 12px;
                                padding: 4px 8px;
                                font-size: 16px;
                                cursor: pointer;
                                color: var(--text-secondary);
                                transition: all 0.2s;
                            "
                            onmouseover="this.style.background='var(--bg-secondary)'"
                            onmouseout="this.style.background='none'"
                            title="Add reaction"
                        >
                            +
                        </button>
                    </div>
                `;

                tempContainer.appendChild(messageDiv);

                // Fetch reactions
                if (messageType !== 'none') {
                    fetchMessageReactions(message.id, messageType).then(() => {
                        updateReactionDisplay(message.id, messageType);
                    });
                }
            });

            // Insert all messages before the first existing message
            if (firstMessageBefore) {
                messagesContainer.insertBefore(tempContainer, firstMessageBefore);
            } else {
                messagesContainer.appendChild(tempContainer);
            }
        }

        // Recreate load button if there are more messages
        if (messagePagination[chatType].hasMore) {
            createLoadOlderButton(chatType);
        }

        // Maintain scroll position - user should stay looking at the same message
        requestAnimationFrame(() => {
            const scrollHeightAfter = messagesContainer.scrollHeight;
            const scrollDiff = scrollHeightAfter - scrollHeightBefore;
            messagesContainer.scrollTop = scrollTopBefore + scrollDiff;
        });

    } catch (error) {
        console.error('Error loading older messages:', error);
        messagePagination[chatType].loading = false;
        showNotification('Failed to load older messages', 'error');

        // Re-enable button
        if (button) {
            button.textContent = 'Load older messages';
            button.disabled = false;
        }
    }
}

// Removed: loadAndDisplayGeneralMessages() - deprecated with match chat system
// Removed: setupMatchChatSubscription() - deprecated with match chat system

// ========== CIRCLE CHAT FUNCTIONS ==========

window.openCircleChat = async function(circleId) {
    try {
        console.log(' Opening circle chat:', circleId);
        showLoader('Loading circle chat...');

        // Find the circle
        const circle = circles.find(c => c.id === circleId);
        if (!circle) {
            hideLoader();
            showNotification('Circle not found', 'error');
            return;
        }

        // Mark circle as read
        await markCircleAsRead(circleId);

        // Set circle chat context
        setCircleChatContext(circle);

        // Show mute button for circle chats
        const muteChatBtn = document.getElementById('mute-chat-btn');
        if (muteChatBtn) {
            muteChatBtn.style.display = 'inline-block';
            await updateMuteButton(null, null, circleId);
        }

        // Hide create event button in circle chats
        const createEventBtn = document.getElementById('create-event-header-btn');
        if (createEventBtn) createEventBtn.style.display = 'none';

        // Hide event details banner in circle chats
        const eventDetailsDiv = document.getElementById('event-details');
        if (eventDetailsDiv) eventDetailsDiv.style.display = 'none';

        // Get all circle members
        const { data: members, error: membersError } = await supabase
            .from('circle_members')
            .select(`
                profile_id,
                profiles!inner(id, name, avatar)
            `)
            .eq('circle_id', circleId);

        if (membersError) throw membersError;

        // Update header
        document.getElementById('event-activity-name').textContent = ` ${circle.name}`;
        document.getElementById('event-participants').innerHTML = `${members?.length || 0} members in circle`;

        // Render circle chat
        await renderCircleChat(circleId);

        // Setup subscription for real-time messages
        await setupCircleChatSubscription(circleId);

        hideLoader();
        showPage('chat');

        // Save circle chat context for refresh persistence
        localStorage.setItem('friendle_current_chat_context', JSON.stringify({
            type: 'circle',
            id: circleId
        }));

        // Force scroll to bottom after page is shown (especially for notifications)
        setTimeout(() => forceScrollToBottom(), 300);

    } catch (error) {
        hideLoader();
        console.error('Error opening circle chat:', error);
        showNotification('Error loading circle chat', 'error');
    }
}

async function renderCircleChat(circleId) {
    const messagesContainer = document.getElementById('chat-messages');
    messagesContainer.innerHTML = '';

    // Header
    const header = document.createElement('div');
    header.style.cssText = 'margin: 20px 0 10px 0; padding-bottom: 8px; border-bottom: 2px solid #e0e0e0;';
    header.innerHTML = '<h4 style="margin: 0; font-size: 14px; color: #666; font-weight: 600;"> CIRCLE CHAT</h4>';
    messagesContainer.appendChild(header);

    // Load and display messages
    await loadAndDisplayCircleMessages(circleId);

    // Scroll to bottom
    setTimeout(() => {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }, 100);
}

async function loadAndDisplayCircleMessages(circleId, preserveScroll = false, savedScrollPosition = null) {
    try {
        const messagesContainer = document.getElementById('chat-messages');

        // Save scroll position if preserving
        const scrollPos = preserveScroll && !savedScrollPosition ? messagesContainer.scrollTop : savedScrollPosition;

        // Reset pagination state for initial load
        if (!preserveScroll) {
            messagePagination.circle = { loadedCount: 0, hasMore: true, loading: false };
        }

        // Load most recent messages (descending order, then reverse)
        const { data: messages, error } = await supabase
            .from('circle_messages')
            .select(`
                *,
                sender:profiles(id, name, avatar)
            `)
            .eq('circle_id', circleId)
            .order('created_at', { ascending: false })
            .limit(MESSAGE_PAGE_SIZE);

        if (error) throw error;

        // Reverse to show oldest-to-newest
        if (messages) {
            messages.reverse();
        }

        // Update pagination state
        messagePagination.circle.loadedCount = messages?.length || 0;
        messagePagination.circle.hasMore = messages?.length === MESSAGE_PAGE_SIZE;

        // Clear messages but preserve the header
        const header = messagesContainer.querySelector('h4');
        messagesContainer.innerHTML = '';

        // Re-add header if it existed
        if (header) {
            const headerContainer = document.createElement('div');
            headerContainer.style.cssText = 'margin: 20px 0 10px 0; padding-bottom: 8px; border-bottom: 2px solid #e0e0e0;';
            headerContainer.appendChild(header);
            messagesContainer.appendChild(headerContainer);
        }

        if (!messages || messages.length === 0) {
            const placeholder = document.createElement('p');
            placeholder.style.cssText = 'text-align: center; color: #999; padding: 20px; font-size: 14px;';
            placeholder.textContent = 'No messages yet. Start the conversation!';
            messagesContainer.appendChild(placeholder);
            messagePagination.circle.hasMore = false;
            return;
        }

        // Display each message
        messages.forEach(message => {
            appendMessage(message);
        });

        // Add "Load older messages" button if there are more messages
        if (messagePagination.circle.hasMore) {
            createLoadOlderButton('circle');
        }

        // Scroll handling - preserve position or scroll to bottom
        setTimeout(() => {
            if (preserveScroll && scrollPos !== null) {
                messagesContainer.scrollTop = scrollPos;
                console.log(' Restored scroll position to:', scrollPos);
            } else {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        }, 50);

        // Mark all visible messages as read
        setTimeout(() => {
            markAllVisibleMessagesAsRead('circle');
        }, 500);

    } catch (error) {
        console.error('Error loading circle messages:', error);
    }
}

async function setupCircleChatSubscription(circleId) {
    console.log(' Setting up circle chat subscription for:', circleId);

    // Clean up existing subscription
    if (circleMessageSubscription) {
        await supabase.removeChannel(circleMessageSubscription);
        const index = allActiveSubscriptions.indexOf(circleMessageSubscription);
        if (index > -1) allActiveSubscriptions.splice(index, 1);
        circleMessageSubscription = null;
    }

    // Subscribe to broadcast messages
    circleMessageSubscription = supabase
        .channel(`circle_chat_${circleId}`)
        .on('broadcast', { event: 'new_circle_message' }, (payload) => {
            console.log(' Circle message received:', payload.payload);

            // Don't duplicate messages we sent ourselves
            if (payload.payload.sender_id === currentUser.id) {
                console.log(' Skipping own message');
                return;
            }

            // Append message to chat
            const message = {
                id: payload.payload.id,
                sender_id: payload.payload.sender_id,
                content: payload.payload.content,
                created_at: payload.payload.created_at,
                sender: {
                    id: payload.payload.sender_id,
                    name: payload.payload.sender_name,
                    avatar: payload.payload.sender_avatar
                }
            };

            appendMessage(message);

            // Update badge if we're not currently viewing this circle chat
            const currentContext = getCurrentChatContext();
            if (!currentContext || currentContext.id !== payload.payload.circle_id) {
                updateNotificationBadge();
            }
        })
        .on('broadcast', { event: 'message_edited' }, (payload) => {
            console.log(' Circle message edited:', payload);
            loadAndDisplayCircleMessages(circleId);
        })
        .on('broadcast', { event: 'message_deleted' }, (payload) => {
            console.log(' Circle message deleted:', payload);
            loadAndDisplayCircleMessages(circleId);
        })
        .on('broadcast', { event: 'reaction_changed' }, async (payload) => {
            console.log(' Circle message reaction changed:', payload);
            const messageId = payload.payload.messageId;
            await fetchMessageReactions(messageId, 'circle');
            updateReactionDisplay(messageId, 'circle');
        })
        .on('broadcast', { event: 'message_read' }, async (payload) => {
            console.log(' Circle message read:', payload);
            const messageId = payload.payload.messageId;
            // Find the message and update its read count if it's the current user's message
            const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageElement) {
                // Get the sender_id from the message element or refetch
                const { data: message } = await supabase
                    .from('circle_messages')
                    .select('sender_id')
                    .eq('id', messageId)
                    .single();
                if (message) {
                    updateReadCountDisplay(messageId, 'circle', message.sender_id);
                }
            }
        })
        .on('broadcast', { event: 'messages_read' }, async (payload) => {
            console.log(' Circle messages read by user:', payload.payload.userId);
            // Refresh read counts for all user's own messages
            const messageElements = document.querySelectorAll('[data-message-id]');
            for (const messageElement of messageElements) {
                const messageId = messageElement.getAttribute('data-message-id');
                const { data: message } = await supabase
                    .from('circle_messages')
                    .select('sender_id')
                    .eq('id', messageId)
                    .single();
                if (message && message.sender_id === currentUser.id) {
                    updateReadCountDisplay(messageId, 'circle', message.sender_id);
                }
            }
        })
        .subscribe((status) => {
            console.log('Circle chat subscription status:', status);
        });

    allActiveSubscriptions.push(circleMessageSubscription);
}

async function markCircleAsRead(circleId) {
    try {
        const { error } = await supabase
            .from('circle_members')
            .update({ last_read_at: new Date().toISOString() })
            .eq('circle_id', circleId)
            .eq('profile_id', currentUser.id);

        if (error) throw error;

        console.log(' Marked circle as read:', circleId);

        // Refresh circles list to update badges
        if (window.location.hash === '#circles') {
            await renderCircles();
        }

    } catch (error) {
        console.error('Error marking circle as read:', error);
    }
}

// ========== END CIRCLE CHAT FUNCTIONS ==========

// Load a single message with sender info
async function loadSingleMessage(messageId) {
    try {
        const { data: message, error } = await supabase
            .from('match_messages')
            .select(`
                *,
                sender:profiles(id, name, avatar)
            `)
            .eq('id', messageId)
            .single();
        
        if (error) throw error;
        
        if (message) {
            appendGeneralMessage(message);
        }
    } catch (error) {
        console.error('Error loading single message:', error);
    }
}

// View event thread (expand messages within the event card)
window.viewEventThread = async function(eventId) {
    // For now, just open the event chat
    // Later we can make this show inline thread
    openEventChat(eventId);
}

// Join event from within the chat
window.joinEventFromChat = async function(eventId, matchId) {
    try {
        showLoader('Joining event...');

        // First, check if event has a participant limit
        const { data: eventCheck, error: checkError } = await supabase
            .from('events')
            .select('max_participants, event_participants(profile_id)')
            .eq('id', eventId)
            .single();

        if (checkError) throw checkError;

        // Check if event is full
        const currentCount = eventCheck.event_participants?.length || 0;
        if (eventCheck.max_participants && currentCount >= eventCheck.max_participants) {
            hideLoader();
            showNotification('This event is full', 'error');
            return;
        }

        // Add user to event participants
        const { error } = await supabase
            .from('event_participants')
            .insert([{
                event_id: eventId,
                profile_id: currentUser.id,
                status: 'accepted'
            }]);

        if (error) throw error;

        // Auto-join general chat if not already in it (and notify others if this is a new join)
        const wasAlreadyInChat = await isUserInMatchChat(matchId);
        await joinMatchChat(matchId);

        // Get event details for notification
        const { data: event, error: eventError } = await supabase
            .from('events')
            .select(`
                id,
                scheduled_date,
                scheduled_time,
                activity_id,
                activities(name, emoji),
                event_participants(profile_id)
            `)
            .eq('id', eventId)
            .single();
        
        if (eventError) {
            console.error('Error loading event details:', eventError);
        }

        // Send notification to existing participants (non-blocking - fire and forget)
        if (event) {
            sendEventJoinNotification(event).catch(err => {
                console.error('Error sending event join notification:', err);
            });
        }

        hideLoader();
        showNotification('Joined event! You can now access the event chat.');
        
        // Refresh the threaded chat view
        const match = matches.find(m => m.id === matchId);
        if (match) {
            const { data: allEvents } = await supabase
                .from('events')
                .select(`
                    *,
                    event_participants(profile_id, profiles(id, name, avatar))
                `)
                .eq('match_id', matchId)
                .order('scheduled_date', { ascending: true });

            // Match chat deprecated - user already joined event, no need to refresh chat
        }
        
    } catch (error) {
        hideLoader();
        console.error('Error joining event:', error);
        showNotification('Error joining event', 'error');
    }
}

// Add to Calendar function
window.addToCalendar = async function(eventId) {
    
    // Find the event - try from current context first, then query database
    let event = null;
    
    // Try to find in matches (if we're on matches page)
    if (matches && matches.length > 0) {
        for (const match of matches) {
            if (match.events) {
                event = match.events.find(e => e && e.id === eventId);
                if (event) break;
            }
        }
    }
    
    // If not found, query from database
    if (!event) {
        const { data, error } = await supabase
            .from('events')
            .select('*')
            .eq('id', eventId)
            .single();
        
        if (error || !data) {
            showNotification('Event not found', 'error');
            return;
        }
        event = data;
    }
    
    if (!event) {
        showNotification('Event not found', 'error');
        return;
    }
    
    // Get activity details
    const match = matches.find(m => m.events?.some(e => e.id === eventId));
    
    let activity = match?.activity || activities.find(a => a.id === (match?.activity_id || event.activity_id));
    
    // If still not found, query database
    if (!activity) {
        const { data: activityData } = await supabase
            .from('activities')
            .select('*')
            .eq('id', event.activity_id)
            .single();
        
        activity = activityData;
    }
    
    if (!activity) {
        showNotification('Activity details not found', 'error');
        return;
    }
    
    // Show modal with calendar options
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.style.display = 'flex';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 350px;">
            <span class="close-modal-btn" onclick="this.closest('.modal-overlay').remove()"></span>
            <div class="modal-header">Add to Calendar</div>
            <button onclick="downloadICSFile('${eventId}')" class="btn" style="width: 100%; margin-bottom: 10px;">
                 Download .ics file
            </button>
            <button onclick="openGoogleCalendar('${eventId}')" class="btn btn-secondary" style="width: 100%; margin-bottom: 10px;">
                 Google Calendar
            </button>
            <button onclick="downloadICSFile('${eventId}')" class="btn btn-secondary" style="width: 100%;">
                 Apple Calendar
            </button>
            <p style="font-size: 12px; color: #666; margin-top: 15px; text-align: center;">
                Apple Calendar: Download the file and open it
            </p>
        </div>
    `;
    document.body.appendChild(modal);
}

// Download .ics file
window.downloadICSFile = async function(eventId) {
    // Find event (same logic as addToCalendar)
    let event = null;
    if (matches && matches.length > 0) {
        for (const match of matches) {
            if (match.events) {
                event = match.events.find(e => e && e.id === eventId);
                if (event) break;
            }
        }
    }
    
    if (!event) {
        const { data } = await supabase
            .from('events')
            .select('*')
            .eq('id', eventId)
            .single();
        event = data;
    }
    
    if (!event) return;
    
    // Find activity
    const match = matches.find(m => m.events?.some(e => e.id === eventId));
    let activity = match?.activity || activities.find(a => a.id === (match?.activity_id || event.activity_id));
    
    if (!activity) {
        const { data: activityData } = await supabase
            .from('activities')
            .select('*')
            .eq('id', event.activity_id)
            .single();
        activity = activityData;
    }
    
    if (!activity) return;

    const formatTimestamp = (date) => {
        const year = date.getUTCFullYear();
        const month = String(date.getUTCMonth() + 1).padStart(2, '0');
        const day = String(date.getUTCDate()).padStart(2, '0');
        const hours = String(date.getUTCHours()).padStart(2, '0');
        const minutes = String(date.getUTCMinutes()).padStart(2, '0');
        const seconds = String(date.getUTCSeconds()).padStart(2, '0');
        return `${year}${month}${day}T${hours}${minutes}${seconds}Z`;
    };

    let dtStart, dtEnd;

    if (event.scheduled_time) {
        // Timed event - parse date and time
        const [year, month, day] = event.scheduled_date.split('-');
        const [hours, minutes] = event.scheduled_time.split(':');

        // Create date in local timezone
        const startDate = new Date(
            parseInt(year),
            parseInt(month) - 1,
            parseInt(day),
            parseInt(hours),
            parseInt(minutes)
        );

        // End time is 1 hour later
        const endDate = new Date(startDate.getTime() + 60 * 60 * 1000);

        dtStart = `DTSTART:${formatTimestamp(startDate)}`;
        dtEnd = `DTEND:${formatTimestamp(endDate)}`;
    } else {
        // All-day event
        const [year, month, day] = event.scheduled_date.split('-');

        const formatDateOnly = (y, m, d) => `${y}${m}${d}`;

        const startDateStr = formatDateOnly(year, month, day);
        const nextDay = new Date(parseInt(year), parseInt(month) - 1, parseInt(day) + 1);
        const endDateStr = formatDateOnly(
            nextDay.getFullYear(),
            String(nextDay.getMonth() + 1).padStart(2, '0'),
            String(nextDay.getDate()).padStart(2, '0')
        );

        dtStart = `DTSTART;VALUE=DATE:${startDateStr}`;
        dtEnd = `DTEND;VALUE=DATE:${endDateStr}`;
    }

    const icsContent = [
        'BEGIN:VCALENDAR',
        'VERSION:2.0',
        'PRODID:-//Friendle//Event//EN',
        'BEGIN:VEVENT',
        `UID:${event.id}@friendle.app`,
        `DTSTAMP:${formatTimestamp(new Date())}`,
        dtStart,
        dtEnd,
        `SUMMARY:${activity.emoji} ${activity.name}`,
        event.location ? `LOCATION:${event.location}` : '',
        event.notes ? `DESCRIPTION:${event.notes}\\n\\nOrganized via Friendle` : 'DESCRIPTION:Organized via Friendle',
        'STATUS:CONFIRMED',
        'END:VEVENT',
        'END:VCALENDAR'
    ].filter(line => line).join('\r\n');
    
    // Create blob and download
    const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `friendle-${activity.name.replace(/\s+/g, '-')}-${event.id}.ics`;
    link.click();
    
    // Close only the calendar modal
    const calendarModals = document.querySelectorAll('.modal-overlay');
    calendarModals.forEach(m => {
        if (m.querySelector('.modal-header')?.textContent === 'Add to Calendar') {
            m.remove();
        }
    });
    
    showNotification('Calendar event downloaded!');
}

// Open in Google Calendar
window.openGoogleCalendar = async function(eventId) {
    // Find event (same logic as addToCalendar)
    let event = null;
    if (matches && matches.length > 0) {
        for (const match of matches) {
            if (match.events) {
                event = match.events.find(e => e && e.id === eventId);
                if (event) break;
            }
        }
    }
    
    if (!event) {
        const { data } = await supabase
            .from('events')
            .select('*')
            .eq('id', eventId)
            .single();
        event = data;
    }
    
    if (!event) return;
    
    // Find activity
    const match = matches.find(m => m.events?.some(e => e.id === eventId));
    let activity = match?.activity || activities.find(a => a.id === (match?.activity_id || event.activity_id));
    
    if (!activity) {
        const { data: activityData } = await supabase
            .from('activities')
            .select('*')
            .eq('id', event.activity_id)
            .single();
        activity = activityData;
    }
    
    if (!activity) return;

    const formatTimestamp = (date) => {
        const year = date.getUTCFullYear();
        const month = String(date.getUTCMonth() + 1).padStart(2, '0');
        const day = String(date.getUTCDate()).padStart(2, '0');
        const hours = String(date.getUTCHours()).padStart(2, '0');
        const minutes = String(date.getUTCMinutes()).padStart(2, '0');
        const seconds = String(date.getUTCSeconds()).padStart(2, '0');
        return `${year}${month}${day}T${hours}${minutes}${seconds}Z`;
    };

    let datesParam;

    if (event.scheduled_time) {
        // Timed event
        const [year, month, day] = event.scheduled_date.split('-');
        const [hours, minutes] = event.scheduled_time.split(':');

        // Create date in local timezone
        const startDate = new Date(
            parseInt(year),
            parseInt(month) - 1,
            parseInt(day),
            parseInt(hours),
            parseInt(minutes)
        );

        // End time is 1 hour later
        const endDate = new Date(startDate.getTime() + 60 * 60 * 1000);

        datesParam = `${formatTimestamp(startDate)}/${formatTimestamp(endDate)}`;
    } else {
        // All-day event
        const [year, month, day] = event.scheduled_date.split('-');

        const formatDateOnly = (y, m, d) => `${y}${m}${d}`;

        const startDateStr = formatDateOnly(year, month, day);
        const nextDay = new Date(parseInt(year), parseInt(month) - 1, parseInt(day) + 1);
        const endDateStr = formatDateOnly(
            nextDay.getFullYear(),
            String(nextDay.getMonth() + 1).padStart(2, '0'),
            String(nextDay.getDate()).padStart(2, '0')
        );

        datesParam = `${startDateStr}/${endDateStr}`;
    }

    // Build Google Calendar URL
    const googleUrl = new URL('https://calendar.google.com/calendar/render');
    googleUrl.searchParams.set('action', 'TEMPLATE');
    googleUrl.searchParams.set('text', `${activity.emoji} ${activity.name}`);
    googleUrl.searchParams.set('dates', datesParam);
    if (event.location) googleUrl.searchParams.set('location', event.location);
    if (event.notes) googleUrl.searchParams.set('details', event.notes + '\n\nOrganized via Friendle');
    
    // Close only the calendar modal
    const calendarModals = document.querySelectorAll('.modal-overlay');
    calendarModals.forEach(m => {
        if (m.querySelector('.modal-header')?.textContent === 'Add to Calendar') {
            m.remove();
        }
    });
    
    // Open in new tab
    window.open(googleUrl.toString(), '_blank');
    
    showNotification('Opening Google Calendar...');
}

// Add to calendar from event chat header
window.addToCalendarFromHeader = function() {
    if (currentEvent && currentEvent.id) {
        addToCalendar(currentEvent.id);
    } else {
        showNotification('No event selected', 'error');
    }
}

// Helper function to check if user is first in match
async function isFirstInMatch(matchId) {
    try {
        const { data: participants, error } = await supabase
            .from('match_participants')
            .select('profile_id')
            .eq('match_id', matchId);
        
        if (error) throw error;
        
        return !participants || participants.length === 0;
        
    } catch (error) {
        console.error('Error checking first in match:', error);
        return false;
    }
}

// Save matches to Supabase
async function saveMatchesToSupabase(matches, circleId) {
    try {
        // Clear existing matches for this user and circle
        await supabase
            .from('matches')
            .delete()
            .eq('circle_id', circleId);

        // Insert new matches
        if (matches.length > 0) {
            const matchData = matches.map(match => ({
                id: match.id,
                circle_id: circleId,
                activity_id: match.activity.id
                // Note: We'll need to modify your matches table structure to store user pairs
            }));

            const { error } = await supabase
                .from('matches')
                .insert(matchData);

            if (error) throw error;
        }
    } catch (error) {
        console.error('Error saving matches:', error);
    }
}
        // Match System
        async function checkForMatches() {
    if (!selectedCircle) return;
    
    console.log(' Checking for matches...');
    
    // Store old matches to detect NEW ones
    const oldMatchIds = new Set(matches.map(m => m.id));
    
    // Find real matches based on preferences
    const foundMatches = await findMatches(selectedCircle.id);
    
    // Update global matches array
    matches = foundMatches;
    
    // Save to localStorage for now (we can migrate this later)
    localStorage.setItem('friendle_matches', JSON.stringify(matches));
    
    updateNotificationBadge();

    // Detect NEW matches (matches that didn't exist before)
    const newMatches = foundMatches.filter(m => !oldMatchIds.has(m.id));

    console.log(' Match summary:', {
        total: foundMatches.length,
        new: newMatches.length,
        existing: foundMatches.length - newMatches.length
    });

    // DON'T send notifications here - users are just swiping right (interested but anonymous)
    // Notifications are only sent when users actually join the chat via sendMatchJoinNotification

    if (matches.length > 0) {
        if (newMatches.length > 0) {
            // Silent - just log it, don't notify others
            console.log(`Found ${newMatches.length} new match${newMatches.length > 1 ? 'es' : ''} (silent)`);
        }
    } else {
        showNotification('No matches found yet. Try selecting more activities or invite more friends!');
    }
}

async function sendNewMatchNotification(match) {
    try {
        // Validate match has required data
        if (!match || !match.id) {
            console.log(' Cannot send new match notification: match.id is undefined');
            return;
        }

        console.log(' Sending new match notification for:', match.activity?.name);

        // Get all users who are interested in this activity (have it in preferences)
        const { data: interestedUsers, error } = await supabase
            .from('preferences')
            .select('profile_id, profiles(id, name, onesignal_player_id, notify_new_matches)')
            .eq('circle_id', match.circleId || match.circle_id)
            .eq('activity_id', match.activity_id || match.activity.id)
            .neq('profile_id', currentUser.id); // Don't notify yourself

        if (error) throw error;

        if (!interestedUsers || interestedUsers.length === 0) {
            console.log(' No other interested users to notify');
            return;
        }

        console.log(` Notifying ${interestedUsers.length} interested user(s)`);

        // Get names of all interested users (including current user)
        const allInterestedNames = [currentUser.name, ...interestedUsers.map(u => u.profiles.name)];

        // Create notification message
        let message = '';
        if (allInterestedNames.length === 2) {
            message = `You matched with ${allInterestedNames.find(n => n !== currentUser.name)} for ${match.activity.emoji} ${match.activity.name}!`;
        } else {
            const otherNames = allInterestedNames.filter(n => n !== currentUser.name).slice(0, 2).join(', ');
            const remaining = allInterestedNames.length - 3; // -3 because we show 2 names + current user
            if (remaining > 0) {
                message = `You matched with ${otherNames}, and ${remaining} other${remaining > 1 ? 's' : ''} for ${match.activity.emoji} ${match.activity.name}!`;
            } else {
                message = `You matched with ${otherNames} for ${match.activity.emoji} ${match.activity.name}!`;
            }
        }

        // Send notifications via Edge Function
        const recipientIds = interestedUsers
            .filter(u => u.profiles.onesignal_player_id) // Only users with player IDs
            .map(u => u.profile_id);
        
        if (recipientIds.length === 0) {
            console.log(' No users with notification IDs to notify');
            return;
        }
        
        console.log(' Calling send-notification Edge Function');
        
        const { data, error: notifError } = await supabase.functions.invoke('send-notification', {
            body: {
                senderId: currentUser.id,
                recipientIds: recipientIds,
                message: message,
                activityName: `${match.activity.emoji} ${match.activity.name}`,
                chatType: 'match',
                chatId: match.id,
                notificationType: 'new_match'
            }
        });

        if (notifError) {
            console.error(' Error sending match notification:', notifError);
        } else {
            console.log(' Match notifications sent successfully:', data);
        }
        
    } catch (error) {
        console.error(' Error in sendNewMatchNotification:', error);
        // Don't throw - we don't want to block the match creation if notifications fail
    }
}

// Removed: sendMatchJoinNotification - match chat deprecated

async function sendEventJoinNotification(event) {
    try {
        console.log(' Sending event join notification for:', event.id);

        const activity = event.activities;

        // Get existing participants (exclude current user who just joined)
        const existingParticipantIds = event.event_participants
            .map(p => p.profile_id)
            .filter(id => id !== currentUser.id);

        if (existingParticipantIds.length === 0) {
            console.log(' No existing participants to notify (user is first)');
            return;
        }

        // Get profiles with OneSignal IDs
        const { data: profiles, error: profileError } = await supabase
            .from('profiles')
            .select('id, name, onesignal_player_id')
            .in('id', existingParticipantIds)
            .not('onesignal_player_id', 'is', null);

        if (profileError) throw profileError;

        if (!profiles || profiles.length === 0) {
            console.log(' No participants with notification IDs');
            return;
        }

        // Format event date
        const eventDate = new Date(event.scheduled_date + 'T00:00:00');
        const dateStr = eventDate.toLocaleDateString('en-US', {
            weekday: 'short',
            month: 'short',
            day: 'numeric'
        });

        // Create notification message
        const message = `${currentUser.name} is coming to ${activity.emoji} ${activity.name} on ${dateStr}!`;

        console.log(' Notifying:', message);

        // Get recipient IDs for the Edge Function
        const recipientIds = profiles.map(p => p.id);

        // Send notification via Edge Function
        const { data, error: notifError } = await supabase.functions.invoke('send-notification', {
            body: {
                senderId: currentUser.id,
                recipientIds: recipientIds,
                message: message,
                activityName: `${activity.emoji} ${activity.name}`,
                chatType: 'event',
                chatId: event.id,
                notificationType: 'event_join'
            }
        });

        if (notifError) {
            console.error(' Error sending event join notification:', notifError);
        } else {
            console.log(' Event join notifications sent successfully:', data);
        }

    } catch (error) {
        console.error(' Error in sendEventJoinNotification:', error);
        // Don't throw - we don't want to block event joining if notifications fail
    }
}

async function sendEventCreatedNotification(matchId, event) {
    try {
        console.log(' Sending event created notification for:', event.id);
        console.log(' Event data:', { scheduled_date: event.scheduled_date, scheduled_time: event.scheduled_time });

        // Fetch the activity data
        const { data: activity, error: activityError } = await supabase
            .from('activities')
            .select('name, emoji')
            .eq('id', event.activity_id)
            .single();

        if (activityError) throw activityError;

        // Get all users who have selected this activity in their interests (preferences)
        // Exclude current user who created the event
        const { data: interestedUsers, error: prefsError } = await supabase
            .from('preferences')
            .select('profile_id')
            .eq('circle_id', event.circle_id)
            .eq('activity_id', event.activity_id)
            .eq('selected', true)
            .neq('profile_id', currentUser.id);

        if (prefsError) throw prefsError;

        if (!interestedUsers || interestedUsers.length === 0) {
            console.log(' No users with this activity in their interests to notify');
            return;
        }

        const recipientIds = interestedUsers.map(p => p.profile_id);

        // Format event date and time based on status
        let dateTimeStr = '';
        let message = '';

        if (event.status === 'planning') {
            // Planning event - show proposed timeframe
            const timeframe = event.proposed_timeframe || 'when everyone can make it';
            message = `${currentUser.name} wants to plan ${activity.emoji} ${activity.name} ${timeframe}. Join the chat to coordinate!`;
        } else {
            // Scheduled event - show actual date/time
            dateTimeStr = 'soon';
            if (event.scheduled_date) {
                // Parse the date (format: YYYY-MM-DD from database)
                const eventDate = new Date(event.scheduled_date);
                console.log(' Parsed eventDate:', eventDate, 'isValid:', !isNaN(eventDate.getTime()));

                if (!isNaN(eventDate.getTime())) {
                    // Format date: "Mon, Dec 25"
                    dateTimeStr = eventDate.toLocaleDateString('en-US', {
                        weekday: 'short',
                        month: 'short',
                        day: 'numeric'
                    });

                    // Add time if provided (format HH:MM, removing seconds)
                    if (event.scheduled_time) {
                        // Remove seconds if present (HH:MM:SS -> HH:MM)
                        const timeStr = event.scheduled_time.substring(0, 5);
                        dateTimeStr += ` at ${timeStr}`;
                    }
                }
            }
            console.log(' Formatted dateTimeStr:', dateTimeStr);
            message = `${currentUser.name} created a ${activity.emoji} ${activity.name} event on ${dateTimeStr}!`;
        }

        console.log(' Notifying:', message);

        // Send notification via Edge Function
        const { data, error: notifError } = await supabase.functions.invoke('send-notification', {
            body: {
                senderId: currentUser.id,
                recipientIds: recipientIds,
                message: message,
                activityName: `${activity.emoji} ${activity.name}`,
                chatType: 'event',
                chatId: event.id,
                notificationType: 'event_created'
            }
        });

        if (notifError) {
            console.error(' Error sending event created notification:', notifError);
        } else {
            console.log(' Event created notifications sent successfully:', data);
        }

    } catch (error) {
        console.error(' Error in sendEventCreatedNotification:', error);
        // Don't throw - we don't want to block event creation if notifications fail
    }
}

// Send notification when a new activity is suggested
async function sendNewActivityNotification(circleId, activity, suggestedBy) {
    try {
        console.log(' Sending new activity notification for:', activity.name);

        // Get all circle members except the person who suggested it
        const { data: circleMembers, error: membersError } = await supabase
            .from('circle_members')
            .select('profile_id')
            .eq('circle_id', circleId)
            .neq('profile_id', currentUser.id);

        if (membersError) throw membersError;

        if (!circleMembers || circleMembers.length === 0) {
            console.log(' No other members in circle to notify');
            return;
        }

        const recipientIds = circleMembers.map(m => m.profile_id);

        const message = `${suggestedBy} suggested a new activity: ${activity.emoji} ${activity.name}. Check your activity interests in Settings!`;

        console.log(' Notifying:', message);

        // Send notification via Edge Function
        const { data, error: notifError } = await supabase.functions.invoke('send-notification', {
            body: {
                senderId: currentUser.id,
                recipientIds: recipientIds,
                message: message,
                activityName: `${activity.emoji} ${activity.name}`,
                notificationType: 'new_activity'
            }
        });

        if (notifError) {
            console.error(' Error sending new activity notification:', notifError);
        } else {
            console.log(' New activity notifications sent successfully:', data);
        }

    } catch (error) {
        console.error(' Error in sendNewActivityNotification:', error);
        // Don't throw - we don't want to block activity creation if notifications fail
    }
}

// Load all events from all user's circles for the Events page
async function loadEvents() {
    if (!currentUser) return;

    showLoader('Loading events...');

    try {
        const userCircles = circles.map(c => c.id);

        if (userCircles.length === 0) {
            renderEvents([], []);
            return;
        }

        // Use local timezone for "today" instead of UTC to avoid timezone bugs
    const now = new Date();
    const today = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}`;

        // Get upcoming events from user's circles (including planning events)
        const { data: upcomingEvents, error: upcomingError } = await supabase
            .from('events')
            .select(`
                *,
                event_participants(profile_id, status, profiles(id, name, avatar))
            `)
            .in('circle_id', userCircles)
            .or(`scheduled_date.gte.${today},status.eq.planning`)
            .neq('status', 'cancelled')
            .order('scheduled_date', { ascending: true, nullsFirst: false })
            .order('scheduled_time', { ascending: true });

        if (upcomingError) throw upcomingError;

        // Get past events from user's circles
        const { data: pastEvents, error: pastError } = await supabase
            .from('events')
            .select(`
                *,
                event_participants(profile_id, status, profiles(id, name, avatar))
            `)
            .in('circle_id', userCircles)
            .lt('scheduled_date', today)
            .neq('status', 'cancelled')
            .order('scheduled_date', { ascending: false })
            .order('scheduled_time', { ascending: false });

        if (pastError) throw pastError;

        const allEvents = upcomingEvents || [];
        const allPastEvents = pastEvents || [];

        if (allEvents.length === 0 && allPastEvents.length === 0) {
            renderEvents([], []);
            return;
        }

        // Batch fetch activities, matches, and unread counts
        const matchIds = [...new Set([...allEvents.map(e => e.match_id), ...allPastEvents.map(e => e.match_id)])];
        const activityIds = new Set();

        // Get matches to get activity IDs and circle info
        const { data: eventMatches } = await supabase
            .from('matches')
            .select('id, activity_id, circle_id')
            .in('id', matchIds);

        const matchMap = new Map((eventMatches || []).map(m => [m.id, m]));

        // Collect activity IDs
        eventMatches?.forEach(m => activityIds.add(m.activity_id));

        // Batch fetch missing activities
        const missingActivityIds = [...activityIds].filter(actId =>
            !activities.find(a => a.id === actId)
        );

        if (missingActivityIds.length > 0) {
            const { data: activitiesData } = await supabase
                .from('activities')
                .select('*')
                .in('id', missingActivityIds);

            if (activitiesData) {
                activities.push(...activitiesData);
            }
        }

        // Batch fetch event participations for unread counts
        const eventIds = [...allEvents.map(e => e.id), ...allPastEvents.map(e => e.id)];
        let eventParticipationMap = new Map();
        let latestEventMessageMap = new Map();

        try {
            const { data: eventParticipations } = await supabase
                .from('event_participants')
                .select('event_id, last_read_at')
                .eq('profile_id', currentUser.id)
                .in('event_id', eventIds);

            eventParticipationMap = new Map(
                (eventParticipations || []).map(p => [p.event_id, p])
            );

            const { data: eventMessages } = await supabase
                .from('event_messages')
                .select('event_id, created_at, sender_id')
                .in('event_id', eventIds)
                .order('created_at', { ascending: false });

            (eventMessages || []).forEach(msg => {
                if (!latestEventMessageMap.has(msg.event_id)) {
                    latestEventMessageMap.set(msg.event_id, msg);
                }
            });
        } catch (err) {
            console.log('Event read tracking not available yet');
        }

        // Process events with all enriched data
        const processEvent = (event) => {
            const match = matchMap.get(event.match_id);
            const activity = activities.find(a => a.id === match?.activity_id);
            const circle = circles.find(c => c.id === match?.circle_id);

            const userParticipation = event.event_participants?.find(p => p.profile_id === currentUser.id);
            const isUserJoined = !!userParticipation;

            // Calculate unread count
            let unreadCount = 0;
            if (isUserJoined) {
                const eventParticipation = eventParticipationMap.get(event.id);
                if (eventParticipation?.last_read_at) {
                    const latestMessage = latestEventMessageMap.get(event.id);
                    if (latestMessage &&
                        new Date(latestMessage.created_at) > new Date(eventParticipation.last_read_at) &&
                        latestMessage.sender_id !== currentUser.id) {
                        unreadCount = 1;
                    }
                }
            }

            const participantCount = event.event_participants?.length || 0;

            return {
                ...event,
                activity,
                circle,
                match,
                isUserJoined,
                unreadCount,
                participantCount
            };
        };

        const processedEvents = allEvents.map(processEvent);
        const processedPastEvents = allPastEvents.map(processEvent);

        renderEvents(processedEvents, processedPastEvents);

    } catch (error) {
        console.error('Error loading events:', error);
        renderEvents([], []);
    } finally {
        hideLoader();
    }
}

// Helper function to render events grouped by time periods
function renderEventsByTimePeriod(events) {
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    const thisWeekend = getNextWeekend(now);
    const nextWeek = getNextWeekRange(now);

    // Separate planning events from scheduled events
    const planningEvents = events.filter(e => e.status === 'planning');
    const scheduledEvents = events.filter(e => e.status !== 'planning');

    const periods = {
        'PLANNING': planningEvents,
        'TODAY': [],
        'TOMORROW': [],
        'THIS WEEKEND': [],
        'NEXT WEEK': [],
        'LATER': []
    };

    scheduledEvents.forEach(event => {
        const eventDate = new Date(event.scheduled_date);
        const eventDay = new Date(eventDate.getFullYear(), eventDate.getMonth(), eventDate.getDate());

        if (eventDay.getTime() === today.getTime()) {
            periods['TODAY'].push(event);
        } else if (eventDay.getTime() === tomorrow.getTime()) {
            periods['TOMORROW'].push(event);
        } else if (thisWeekend && eventDay >= thisWeekend.start && eventDay <= thisWeekend.end) {
            periods['THIS WEEKEND'].push(event);
        } else if (nextWeek && eventDay >= nextWeek.start && eventDay <= nextWeek.end) {
            periods['NEXT WEEK'].push(event);
        } else {
            periods['LATER'].push(event);
        }
    });

    let html = '';

    // Render periods
    for (const [periodName, periodEvents] of Object.entries(periods)) {
        if (periodEvents.length === 0) continue;

        const icon = periodName === 'PLANNING' ? '' : '';

        html += `
            <details class="event-period" ${periodName === 'TODAY' ? 'open' : ''}>
                <summary class="event-period-header">
                    <span style="display: flex; align-items: center; gap: 8px;">
                        <span class="event-period-chevron"></span>
                        ${icon} ${periodName}
                    </span>
                    <span>${periodEvents.length} ${periodEvents.length === 1 ? 'event' : 'events'}</span>
                </summary>
                <div class="event-period-content">
                    ${periodEvents.map(event => renderEventCard(event)).join('')}
                </div>
            </details>
        `;
    }

    return html;
}

function renderEvents(events, pastEvents = []) {
    const eventsList = document.getElementById('events-list');

    // Separate into "Your events" (joined) and "Other events" (not joined)
    const yourEvents = (events || []).filter(e => e.isUserJoined);
    const otherEvents = (events || []).filter(e => !e.isUserJoined);

    console.log('renderEvents called with:', events?.length, 'events');
    console.log('Your events:', yourEvents.length);
    console.log('Other events:', otherEvents.length);

    // Show empty state if no events at all
    if (yourEvents.length === 0 && otherEvents.length === 0 && (!pastEvents || pastEvents.length === 0)) {
        eventsList.innerHTML = `
            <div class="events-empty-state">
                <div class="events-empty-icon"></div>
                <div class="events-empty-title">No Upcoming Events</div>
                <div class="events-empty-message">Events from your circles will appear here. Browse activities to plan an event!</div>
                <button class="btn" onclick="showPage('activities')" style="margin-top: 20px;"> Browse Activities</button>
            </div>
        `;
        return;
    }

    let html = '';

    // Render YOUR EVENTS section
    if (yourEvents.length > 0) {
        html += `<div style="margin-bottom: 30px;">`;
        html += `<h2 style="margin: 0 0 15px 0; font-size: 20px; font-weight: 600; color: var(--text-primary);"> Your Events</h2>`;
        html += renderEventsByTimePeriod(yourEvents);
        html += `</div>`;
    }

    // Render OTHER EVENTS section
    if (otherEvents.length > 0) {
        html += `<div style="margin-bottom: 30px;">`;
        html += `<h2 style="margin: 0 0 15px 0; font-size: 20px; font-weight: 600; color: var(--text-primary);"> Other Events in Your Circles</h2>`;
        html += renderEventsByTimePeriod(otherEvents);
        html += `</div>`;
    }

    // Render upcoming scheduled events (LEGACY - keeping for compatibility)
    const scheduledEvents = (events || []).filter(e => e.status !== 'planning');
    if (scheduledEvents.length > 0 && yourEvents.length === 0 && otherEvents.length === 0) {
        // Group events by time periods
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const tomorrow = new Date(today);
        tomorrow.setDate(tomorrow.getDate() + 1);
        const thisWeekend = getNextWeekend(now);
        const nextWeek = getNextWeekRange(now);

        const periods = {
            'TODAY': [],
            'TOMORROW': [],
            'THIS WEEKEND': [],
            'NEXT WEEK': [],
            'LATER': []
        };

        scheduledEvents.forEach(event => {
            const eventDate = new Date(event.scheduled_date);
            const eventDay = new Date(eventDate.getFullYear(), eventDate.getMonth(), eventDate.getDate());

            if (eventDay.getTime() === today.getTime()) {
                periods['TODAY'].push(event);
            } else if (eventDay.getTime() === tomorrow.getTime()) {
                periods['TOMORROW'].push(event);
            } else if (thisWeekend && eventDay >= thisWeekend.start && eventDay <= thisWeekend.end) {
                periods['THIS WEEKEND'].push(event);
            } else if (nextWeek && eventDay >= nextWeek.start && eventDay <= nextWeek.end) {
                periods['NEXT WEEK'].push(event);
            } else {
                periods['LATER'].push(event);
            }
        });

        // Render periods
        for (const [periodName, periodEvents] of Object.entries(periods)) {
            if (periodEvents.length === 0) continue;

            html += `
                <details class="event-period">
                    <summary class="event-period-header">
                        <span style="display: flex; align-items: center; gap: 8px;">
                            <span class="event-period-chevron"></span>
                            ${periodName}
                        </span>
                        <span>${periodEvents.length} ${periodEvents.length === 1 ? 'event' : 'events'}</span>
                    </summary>
                    <div class="event-period-content">
                        ${periodEvents.map(event => renderEventCard(event)).join('')}
                    </div>
                </details>
            `;
        }
    }

    // Render past events grouped by month
    if (pastEvents && pastEvents.length > 0) {
        // Group past events by month
        const monthGroups = {};

        pastEvents.forEach(event => {
            const eventDate = new Date(event.scheduled_date);
            const monthKey = `${eventDate.getFullYear()}-${String(eventDate.getMonth() + 1).padStart(2, '0')}`;
            const monthName = eventDate.toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'long'
            });

            if (!monthGroups[monthKey]) {
                monthGroups[monthKey] = {
                    name: monthName,
                    events: []
                };
            }
            monthGroups[monthKey].events.push(event);
        });

        // Render past events section (collapsed by default)
        const totalPastEvents = pastEvents.length;
        html += `
            <details class="event-period" style="margin-top: 30px;">
                <summary class="event-period-header">
                    <span style="display: flex; align-items: center; gap: 8px;">
                        <span class="event-period-chevron"></span>
                        PAST EVENTS
                    </span>
                    <span>${totalPastEvents} ${totalPastEvents === 1 ? 'event' : 'events'}</span>
                </summary>
                <div class="event-period-content">
        `;

        // Render each month group within past events
        const sortedMonthKeys = Object.keys(monthGroups).sort().reverse();
        sortedMonthKeys.forEach(monthKey => {
            const group = monthGroups[monthKey];
            html += `
                <details class="event-period" style="margin: 10px; border: 1px solid var(--border-color);">
                    <summary class="event-period-header" style="padding: 12px 16px;">
                        <span style="display: flex; align-items: center; gap: 8px;">
                            <span class="event-period-chevron"></span>
                            ${group.name}
                        </span>
                        <span>${group.events.length} ${group.events.length === 1 ? 'event' : 'events'}</span>
                    </summary>
                    <div class="event-period-content">
                        ${group.events.map(event => renderEventCard(event)).join('')}
                    </div>
                </details>
            `;
        });

        html += `
                </div>
            </details>
        `;
    }

    eventsList.innerHTML = html;
}

function renderEventCard(event) {
    if (!event.activity || !event.circle) return '';

    const isUserJoined = event.isUserJoined || false;
    const activityEmoji = event.activity.emoji || '';
    const activityName = event.activity.name || 'Event';
    const circleName = event.circle.name || 'Circle';

    // Format date and time (match card style)
    const date = event.scheduled_date ? new Date(event.scheduled_date) : null;
    const dateStr = date ? date.toLocaleDateString('en-US', {
        weekday: 'short',
        month: 'short',
        day: 'numeric'
    }) : 'Date TBD';

    // Format time if available (convert 24h to 12h format)
    let timeStr = '';
    if (event.scheduled_time) {
        const [hours, minutes] = event.scheduled_time.split(':');
        const hour = parseInt(hours);
        const ampm = hour >= 12 ? 'PM' : 'AM';
        const displayHour = hour === 0 ? 12 : (hour > 12 ? hour - 12 : hour);
        timeStr = `, ${displayHour}:${minutes} ${ampm}`;
    }

    // Get participant count and check capacity
    const participantCount = event.participantCount || 0;
    const maxParticipants = event.max_participants;
    const isFull = maxParticipants && participantCount >= maxParticipants;
    const participantDisplay = formatParticipantNames(
        event.event_participants || [],
        event.id,
        2,
        isUserJoined ? 'going' : 'interested',
        maxParticipants
    );

    return `
        <div class="event-card">
            <div style="display: flex; justify-content: space-between; align-items: start; gap: 10px;">
                <div style="flex: 1;">
                    <div style="font-weight: 600; margin-bottom: 6px; font-size: 16px; display: flex; align-items: center; gap: 6px;">
                        ${activityEmoji} ${activityName} <span style="font-size: 13px; color: var(--text-secondary); font-weight: 400; margin-left: 4px;">  ${circleName}</span>
                    </div>
                    <div style="font-weight: 500; margin-bottom: 6px; font-size: 15px; display: flex; align-items: center; gap: 6px;">
                         ${dateStr}${timeStr}
                    </div>
                    ${event.location ? `<div class="event-meta" style="font-size: 13px;"> ${event.location}</div>` : ''}
                    <div class="event-meta" style="font-size: 12px; margin-top: 4px;">${participantDisplay}</div>
                </div>
                <div style="display: flex; flex-direction: column; gap: 6px; align-items: flex-end;">
                ${isUserJoined ? `
                    <button class="btn btn-secondary" onclick="openEventChat('${event.id}')" style="font-size: 13px; padding: 6px 12px; width: auto; margin: 0; white-space: nowrap;">
                         Event Chat
                    </button>
                ` : isFull ? `
                    <button class="btn" disabled style="font-size: 13px; padding: 6px 12px; width: auto; margin: 0; white-space: nowrap; background: #888; cursor: not-allowed;">
                        Event Full
                    </button>
                ` : `
                    <button class="btn" onclick="joinEvent('${event.id}')" style="font-size: 13px; padding: 6px 12px; width: auto; margin: 0; white-space: nowrap; background: #4CAF50;">
                         Join Event
                    </button>
                `}
                ${participantCount === 0 && !isUserJoined ? `
                    <button class="btn btn-secondary" onclick="deleteEmptyEvent('${event.id}')" style="font-size: 11px; padding: 4px 8px; width: auto; margin: 0; white-space: nowrap; background: #dc3545; color: white;">
                         Delete
                    </button>
                ` : ''}
                </div>
            </div>
        </div>
    `;
}

// Show full attendee list in a modal
async function showEventAttendees(eventId) {
    try {
        const { data: event, error } = await supabase
            .from('events')
            .select(`
                *,
                event_participants (
                    profile_id,
                    profiles (
                        id,
                        name,
                        avatar
                    )
                )
            `)
            .eq('id', eventId)
            .single();

        if (error) throw error;

        const attendeesList = event.event_participants
            ?.map(p => {
                const name = p.profiles?.name || 'Someone';
                const avatar = p.profiles?.avatar || '';
                return `
                    <div style="display: flex; align-items: center; gap: 10px; padding: 10px; border-radius: 8px; background: var(--bg-secondary);">
                        ${renderAvatar(avatar, 40)}
                        <div style="font-weight: 500;">${name}</div>
                    </div>
                `;
            })
            .join('') || '<div style="text-align: center; color: var(--text-secondary);">No attendees yet</div>';

        showModal('Event Attendees', `
            <div style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto;">
                ${attendeesList}
            </div>
        `);
    } catch (error) {
        console.error('Error loading attendees:', error);
        showToast('Failed to load attendees', 'error');
    }
}

// Show full list of match participants (people in chat)
async function showMatchParticipants(matchId) {
    try {
        const { data: participants, error } = await supabase
            .from('match_participants')
            .select(`
                profile_id,
                profiles (
                    id,
                    name,
                    avatar
                )
            `)
            .eq('match_id', matchId);

        if (error) throw error;

        const participantsList = participants
            ?.map(p => {
                const name = p.profiles?.name || 'Someone';
                const avatar = p.profiles?.avatar || '';
                return `
                    <div style="display: flex; align-items: center; gap: 10px; padding: 10px; border-radius: 8px; background: var(--bg-secondary);">
                        ${renderAvatar(avatar, 40)}
                        <div style="font-weight: 500;">${name}</div>
                    </div>
                `;
            })
            .join('') || '<div style="text-align: center; color: var(--text-secondary);">No one in chat yet</div>';

        showModal('People in Chat', `
            <div style="display: flex; flex-direction: column; gap: 8px; max-height: 400px; overflow-y: auto;">
                ${participantsList}
            </div>
        `);
    } catch (error) {
        console.error('Error loading match participants:', error);
        showToast('Failed to load participants', 'error');
    }
}

// Format participant names for display (e.g., "Alice, Bob and 3 more going")
function formatParticipantNames(participants, eventId, maxNames = 2, verb = 'going', maxParticipants = null) {
    const count = participants?.length || 0;

    // Format capacity display (e.g., "2/5" or just "2")
    const capacityDisplay = maxParticipants ? `${count}/${maxParticipants}` : `${count}`;
    const isFull = maxParticipants && count >= maxParticipants;
    const fullIndicator = isFull ? ' (full)' : '';

    if (count === 0) {
        return `${capacityDisplay} people ${verb}${fullIndicator}`;
    }

    if (count === 1) {
        const name = participants[0].profiles?.name || 'Someone';
        return maxParticipants
            ? `${name} (${capacityDisplay}) ${verb}${fullIndicator}`
            : `${name} ${verb}`;
    }

    if (count <= maxNames) {
        const names = participants.map(p => p.profiles?.name || 'Someone').join(', ');
        return maxParticipants
            ? `${names} (${capacityDisplay}) ${verb}${fullIndicator}`
            : `${names} ${verb}`;
    }

    // More than maxNames - show first few and "x more" as clickable
    const shownNames = participants.slice(0, maxNames).map(p => p.profiles?.name || 'Someone').join(', ');
    const remaining = count - maxNames;
    const capacitySuffix = maxParticipants ? ` (${capacityDisplay})` : '';
    return `${shownNames} and <span style="cursor: pointer; text-decoration: underline;" onclick="event.stopPropagation(); showEventAttendees('${eventId}')" title="Click to view all attendees">${remaining} more</span>${capacitySuffix} ${verb}${fullIndicator}`;
}

// Helper functions for time period grouping
function getNextWeekend(now) {
    const dayOfWeek = now.getDay();

    // Saturday is 6, Sunday is 0
    let daysToSaturday;
    if (dayOfWeek === 6) {
        // Today is Saturday
        daysToSaturday = 0;
    } else if (dayOfWeek === 0) {
        // Today is Sunday
        daysToSaturday = -1;
    } else {
        // Days until next Saturday
        daysToSaturday = 6 - dayOfWeek;
    }

    const saturday = new Date(now);
    saturday.setDate(saturday.getDate() + daysToSaturday);
    saturday.setHours(0, 0, 0, 0);

    const sunday = new Date(saturday);
    sunday.setDate(sunday.getDate() + 1);

    // Only return if weekend is within next 7 days
    if (daysToSaturday <= 7 && daysToSaturday >= 0) {
        return {
            start: saturday,
            end: sunday
        };
    }

    return null;
}

function getNextWeekRange(now) {
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const nextWeekStart = new Date(today);
    nextWeekStart.setDate(nextWeekStart.getDate() + 7);

    const nextWeekEnd = new Date(nextWeekStart);
    nextWeekEnd.setDate(nextWeekEnd.getDate() + 6);

    return {
        start: nextWeekStart,
        end: nextWeekEnd
    };
}

function formatEventDate(date) {
    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

    return `${days[date.getDay()]}, ${months[date.getMonth()]} ${date.getDate()}`;
}

function formatTime(timeString) {
    if (!timeString) return '';

    const [hours, minutes] = timeString.split(':');
    const hour = parseInt(hours);
    const ampm = hour >= 12 ? 'PM' : 'AM';
    const hour12 = hour % 12 || 12;

    return `${hour12}:${minutes} ${ampm}`;
}

function formatMessageTimestamp(timestamp) {
    if (!timestamp) return '';

    const messageDate = new Date(timestamp);
    const now = new Date();

    // Get start of today (midnight)
    const startOfToday = new Date(now);
    startOfToday.setHours(0, 0, 0, 0);

    // Get start of yesterday
    const startOfYesterday = new Date(startOfToday);
    startOfYesterday.setDate(startOfYesterday.getDate() - 1);

    // Get start of this week (Sunday)
    const startOfWeek = new Date(startOfToday);
    startOfWeek.setDate(startOfWeek.getDate() - startOfWeek.getDay());

    // Format time
    const timeStr = messageDate.toLocaleTimeString('en-US', {
        hour: 'numeric',
        minute: '2-digit'
    });

    // Today: just show time
    if (messageDate >= startOfToday) {
        return timeStr;
    }

    // Yesterday: show "Yesterday" + time
    if (messageDate >= startOfYesterday) {
        return `Yesterday ${timeStr}`;
    }

    // This week: show day name + time
    if (messageDate >= startOfWeek) {
        const dayName = messageDate.toLocaleDateString('en-US', { weekday: 'short' });
        return `${dayName} ${timeStr}`;
    }

    // This year: show month/day + time
    if (messageDate.getFullYear() === now.getFullYear()) {
        const dateStr = messageDate.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric'
        });
        return `${dateStr}, ${timeStr}`;
    }

    // Older: show full date + time
    const dateStr = messageDate.toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
    });
    return `${dateStr}, ${timeStr}`;
}

window.openEventMenu = function(eventId) {
    // TODO: Implement event menu (share, add to calendar, etc.)
    alert('Event menu for event: ' + eventId);
}

async function loadMatches() {

    if (!currentUser) return;
    
    showLoader('Loading matches...');
    
    try {
        const userCircles = circles.map(c => c.id);
        
        // Get user's preferences (circle + activity pairs)
        const { data: userPrefs } = await supabase
            .from('preferences')
            .select('activity_id, circle_id')
            .eq('profile_id', currentUser.id)
            .eq('selected', true)
            .in('circle_id', userCircles);
        
        if (!userPrefs || userPrefs.length === 0) {
            matches = [];
            await displayMatches();
            return;
        }
        
        // Create a Set of "circleId|activityId" strings for filtering
        const prefSet = new Set(userPrefs.map(p => `${p.circle_id}|${p.activity_id}`));
        
        // Get all potential matches
        const activityIds = [...new Set(userPrefs.map(p => p.activity_id))];
        const { data: allMatches, error: matchError } = await supabase
            .from('matches')
            .select('*')
            .in('activity_id', activityIds)
            .in('circle_id', userCircles);
        
        if (matchError) throw matchError;
        
        // Filter to only matches where user has that activity selected in THAT circle
        const filteredMatches = (allMatches || []).filter(match =>
            prefSet.has(`${match.circle_id}|${match.activity_id}`)
        );

        // BUGFIX: Deduplicate matches by (circle_id, activity_id) pair
        // This prevents showing multiple matches for the same activity in a circle
        const matchMap = new Map();
        filteredMatches.forEach(match => {
            const key = `${match.circle_id}|${match.activity_id}`;
            const existing = matchMap.get(key);
            // Keep the most recent match if duplicates exist
            if (!existing || new Date(match.created_at) > new Date(existing.created_at)) {
                matchMap.set(key, match);
            }
        });
        matches = Array.from(matchMap.values());
        
        // PERFORMANCE FIX: Batch all queries instead of N+1 pattern

        // 1. Batch fetch missing activities
        const missingActivityIds = [...new Set(matches.map(m => m.activity_id))]
            .filter(actId => !activities.find(a => a.id === actId));

        if (missingActivityIds.length > 0) {
            const { data: activitiesData } = await supabase
                .from('activities')
                .select('*')
                .in('id', missingActivityIds);

            if (activitiesData) {
                activities.push(...activitiesData);
            }
        }

        // 2. Batch fetch all interested users for all circle+activity combinations
        const circleActivityPairs = matches.map(m => ({
            circle_id: m.circle_id,
            activity_id: m.activity_id
        }));

        // Build OR conditions for batch query
        let interestedQuery = supabase
            .from('preferences')
            .select('profile_id, circle_id, activity_id')
            .eq('selected', true);

        // Add filters to match any circle+activity pair
        const orConditions = circleActivityPairs
            .map(pair => `and(circle_id.eq.${pair.circle_id},activity_id.eq.${pair.activity_id})`)
            .join(',');

        const { data: allInterested } = await interestedQuery.or(orConditions);

        // 3. Batch fetch all chat participants for all matches
        const matchIds = matches.map(m => m.id);
        const { data: allChatParticipants } = await supabase
            .from('match_participants')
            .select('profile_id, match_id, profiles(id, name, avatar)')
            .in('match_id', matchIds);

        // Map batched data back to each match
        for (let match of matches) {
            // Attach activity
            match.activity = activities.find(a => a.id === match.activity_id);

            // Get interested count for this specific circle+activity (anonymous count)
            const interested = (allInterested || []).filter(i =>
                i.circle_id === match.circle_id && i.activity_id === match.activity_id
            );
            match.interestedCount = interested.length;

            // Attach chat participants for this match
            const chatParticipants = (allChatParticipants || []).filter(p =>
                p.match_id === match.id
            );
            match.chatParticipants = chatParticipants.map(p => p.profiles);
            match.inChatCount = match.chatParticipants.length;
            match.userInChat = chatParticipants.some(p => p.profile_id === currentUser.id);

            // For display: only show names of people who have actually joined (in chat)
            match.interestedUsers = match.chatParticipants;
        }
        
        await displayMatches();
        
    } catch (error) {
        console.error('Error loading matches:', error);
    } finally {
        hideLoader();
        // Update badge count after loading matches
        await updateNotificationBadge();
    }
}

        async function displayMatches() {
    const matchesList = document.getElementById('matches-list');
    const showPastEvents = document.getElementById('show-past-events')?.checked ?? true;
    
    if (!matches || matches.length === 0) {
        matchesList.innerHTML = `
            <div class="empty-state">
                <div class="empty-state-icon"></div>
                <div class="empty-state-title">No Matches Yet</div>
                <div class="empty-state-description">Select some activities to find friends who want to hang out!</div>
                <button class="btn" onclick="showPage('activities')" style="margin-top: 20px;"> Choose Activities</button>
            </div>`;
        return;
    }

    // Get activities marked as available today
    const { data: todayActivities } = await supabase
        .from('activity_availability')
        .select('activity_id')
        .eq('profile_id', currentUser.id)
        .gte('available_until', new Date().toISOString());
    
    const todayActivityIds = new Set(
        (todayActivities || []).map(a => a.activity_id.toString())
    );

    // PERFORMANCE OPTIMIZATION: Batch fetch all data at once instead of N+1 queries
    const matchIds = matches.map(m => m.id);

    // Fetch all match participations at once
    const { data: allMatchParticipations } = await supabase
        .from('match_participants')
        .select('match_id, last_read_at')
        .eq('profile_id', currentUser.id)
        .in('match_id', matchIds);

    // Fetch inactivity warnings for user
    const { data: inactivityWarnings } = await supabase
        .from('inactivity_warnings')
        .select('match_id, profile_id, warned_at')
        .eq('profile_id', currentUser.id)
        .eq('status', 'pending')
        .in('match_id', matchIds);

    const warningsMap = new Map(
        (inactivityWarnings || []).map(w => [w.match_id, w])
    );

    const matchParticipationMap = new Map(
        (allMatchParticipations || []).map(p => [p.match_id, p])
    );

    // Note: Match chat has been removed. No longer fetching match_messages.

    let matchesWithEvents = await Promise.all(
    matches.map(async (match) => {
        // Get all events for this match
        const query = supabase
            .from('events')
            .select(`
                *,
                event_participants(profile_id, status, profiles(id, name, avatar))
            `)
            .eq('match_id', match.id)
            .order('scheduled_date', { ascending: true });

        const { data: allEvents, error } = await query;

        if (error) {
            console.error('Error loading events:', error);
            return { match, events: [], matchUnreadCount: 0 };
        }

        // Note: Match chat has been removed. No unread count for matches.
        let matchUnreadCount = 0;

        // Get all event IDs for batch fetching
        const eventIds = (allEvents || []).map(e => e.id);

        // Fetch all event participations and messages for this match's events at once
        let eventParticipationMap = new Map();
        let latestEventMessageMap = new Map();

        if (eventIds.length > 0) {
            try {
                const { data: eventParticipations } = await supabase
                    .from('event_participants')
                    .select('event_id, last_read_at')
                    .eq('profile_id', currentUser.id)
                    .in('event_id', eventIds);

                eventParticipationMap = new Map(
                    (eventParticipations || []).map(p => [p.event_id, p])
                );

                const { data: eventMessages } = await supabase
                    .from('event_messages')
                    .select('event_id, created_at, sender_id')
                    .in('event_id', eventIds)
                    .order('created_at', { ascending: false });

                // Group by event_id and keep only latest
                (eventMessages || []).forEach(msg => {
                    if (!latestEventMessageMap.has(msg.event_id)) {
                        latestEventMessageMap.set(msg.event_id, msg);
                    }
                });
            } catch (err) {
                console.log('Event read tracking not available yet - run migration to enable');
            }
        }

        // Mark which events user has joined and calculate unread counts
        const eventsWithUnread = (allEvents || []).map(event => {
            const userParticipation = event.event_participants?.find(p => p.profile_id === currentUser.id);
            const isUserJoined = !!userParticipation;

            // Calculate unread count using cached data
            let eventUnreadCount = 0;
            if (isUserJoined) {
                const eventParticipation = eventParticipationMap.get(event.id);
                const latestMessage = latestEventMessageMap.get(event.id);

                // Count as unread if there's a message that's either:
                // 1. Newer than last_read_at (if user has read before), OR
                // 2. Any message exists (if user has never read the chat)
                if (latestMessage && latestMessage.sender_id !== currentUser.id) {
                    if (eventParticipation?.last_read_at) {
                        // User has read before - check if message is newer
                        if (new Date(latestMessage.created_at) > new Date(eventParticipation.last_read_at)) {
                            eventUnreadCount = 1;
                        }
                    } else {
                        // User has never read the chat - any message counts as unread
                        eventUnreadCount = 1;
                    }
                }
            }

            return {
                ...event,
                isUserJoined,
                unreadCount: eventUnreadCount
            };
        });

        return { match, events: eventsWithUnread, matchUnreadCount };
    })
);

// Filter out matches with only past events if toggle is off
if (!showPastEvents) {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    matchesWithEvents = matchesWithEvents.filter(({ match, events }) => {
        // Keep if no events exist
        if (!events || events.length === 0) return true;
        
        // Keep if any event is upcoming
        const hasUpcoming = events.some(e => 
            new Date(e.scheduled_date) >= today && e.status === 'scheduled'
        );
        
        return hasUpcoming;
    });
}

    // Note: We no longer filter out matches based on minimum group size
    // Users should see all matches, even if waiting for more people
    // The UI will show a "waiting" state for matches below their minimum

    // Pre-load any missing activities
    const missingActivityIds = new Set();
    matchesWithEvents.forEach(({ match }) => {
        if (!activities.find(a => a.id === match.activity_id)) {
            missingActivityIds.add(match.activity_id);
        }
    });

    // Fetch missing activities
    const missingActivities = [];
    if (missingActivityIds.size > 0) {
        const { data } = await supabase
            .from('activities')
            .select('*')
            .in('id', Array.from(missingActivityIds));
        if (data) missingActivities.push(...data);
    }

    // Group matches by circle
    const matchesByCircle = new Map();
    matchesWithEvents.forEach(matchData => {
        const circleId = matchData.match.circle_id;
        if (!matchesByCircle.has(circleId)) {
            matchesByCircle.set(circleId, []);
        }
        matchesByCircle.get(circleId).push(matchData);
    });

    // Render grouped by circle
    matchesList.innerHTML = Array.from(matchesByCircle.entries()).map(([circleId, circleMatches]) => {
        const circleName = circles.find(c => c.id === circleId)?.name || 'Circle';
        const isExpanded = expandedMatchCircles.has(circleId);

        // Calculate aggregate state for this circle (highlighted > warnings > unread)
        let hasHighlightedEvent = false;
        let hasWarning = false;
        let hasUnread = false;

        circleMatches.forEach(({ match, events }) => {
            // Check for highlighted events
            if (events.some(e => e.id === highlightedEventId)) {
                hasHighlightedEvent = true;
            }
            // Check for warnings
            if (warningsMap.has(match.id)) {
                hasWarning = true;
            }
            // Check for unread events
            if (events.some(e => e.unreadCount > 0)) {
                hasUnread = true;
            }
        });

        // Determine priority state class
        let stateClass = '';
        if (hasHighlightedEvent) {
            stateClass = 'highlighted';
        } else if (hasWarning) {
            stateClass = 'has-warning';
        } else if (hasUnread) {
            stateClass = 'unread';
        }

        // Render circle group
        return `
            <div class="match-circle-group ${stateClass} ${isExpanded ? 'expanded' : ''}" data-circle-id="${circleId}">
                <div class="match-circle-header" onclick="toggleMatchCircleExpand('${circleId}')">
                    <div class="match-circle-name">${circleName}</div>
                    <div class="match-circle-header-right">
                        ${hasHighlightedEvent ? `<span class="match-circle-badge highlighted"> Event</span>` : ''}
                        ${!hasHighlightedEvent && hasWarning ? `<span class="match-circle-badge warning"> Action needed</span>` : ''}
                        ${!hasHighlightedEvent && !hasWarning && hasUnread ? `<span class="match-circle-badge unread"> New</span>` : ''}
                        <span class="match-circle-count">${circleMatches.length} ${circleMatches.length === 1 ? 'match' : 'matches'}</span>
                        <span class="match-circle-expand-icon"></span>
                    </div>
                </div>
                <div class="match-circle-content">
                    ${circleMatches.map(({ match, events, matchUnreadCount }) => {
        let activity = activities.find(a => a.id === match.activity_id);

        const activityName = activity ? activity.name : 'Unknown Activity';
        const activityEmoji = activity ? activity.emoji : '';

        // Check if user is first
        const isFirst = match.inChatCount === 0;

        // Check for inactivity warning
        const hasWarning = warningsMap.has(match.id);

        // Get in-chat users display (these are revealed)
        const inChatNames = match.chatParticipants?.slice(0, 2).map(u => u.name).join(', ') || '';
        const inChatMoreCount = match.inChatCount > 2 ? match.inChatCount - 2 : 0;

        let inChatDisplay = '';
        if (match.inChatCount === 1 && match.userInChat) {
            inChatDisplay = 'Just you';
        } else if (match.inChatCount === 1) {
            inChatDisplay = match.chatParticipants[0]?.name || '1 person';
        } else if (match.inChatCount === 2) {
            inChatDisplay = inChatNames;
        } else if (match.inChatCount > 2) {
            inChatDisplay = `${inChatNames} and <span onclick="event.preventDefault(); event.stopPropagation(); showMatchParticipants('${match.id}');" style="color: var(--primary-color); text-decoration: underline; cursor: pointer;">${inChatMoreCount} more</span>`;
        }

        
        // Compare dates at midnight to include events happening today
const now = new Date();
const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

console.log('Filtering events:', events.map(e => ({id: e.id, status: e.status, date: e.scheduled_date})));

const upcomingEvents = events.filter(e => {
    // Include planning events (no date yet)
    if (e.status === 'planning') {
        console.log(`Event ${e.id}: status=planning, included in upcoming`);
        return true;
    }
    // Include scheduled events that are today or in the future
    const isScheduled = e.status === 'scheduled';
    const isFuture = new Date(e.scheduled_date) >= today;
    console.log(`Event ${e.id}: status=${e.status}, isScheduled=${isScheduled}, isFuture=${isFuture}`);
    return isScheduled && isFuture;
});

const pastEvents = events.filter(e =>
    e.status === 'cancelled' || e.status === 'completed' ||
    (e.status === 'scheduled' && new Date(e.scheduled_date) < today)
);

console.log('Upcoming:', upcomingEvents.length, 'Past:', pastEvents.length);

        const circleName = circles.find(c => c.id === match.circle_id)?.name || 'Circle';

        // Calculate counts for display
        const totalInterestedCount = match.interestedCount || 0;

        // Get unique users who have joined any upcoming event (these are "going")
        const goingUserIds = new Set();
        const goingUsers = [];
        upcomingEvents.forEach(event => {
            (event.event_participants || []).forEach(participant => {
                if (!goingUserIds.has(participant.profile_id)) {
                    goingUserIds.add(participant.profile_id);
                    if (participant.profiles) {
                        goingUsers.push(participant.profiles);
                    }
                }
            });
        });

        const goingCount = goingUserIds.size;
        const watchingCount = Math.max(0, totalInterestedCount - goingCount); // Watching but haven't joined an event yet

        // Store going users for the modal
        match.goingUsers = goingUsers;

        // Calculate total interested people across all upcoming events
        const totalInterestedInEvents = upcomingEvents.reduce((sum, event) => {
            return sum + (event.event_participants?.length || 0);
        }, 0);

        // Check if user has any events for this match
        const userEvents = events.filter(e => e.isUserJoined);
        const userIsInMatch = match.userInChat; // User is in match_participants

        return `
    <details class="match-card${hasWarning ? ' has-warning' : ''}">
        <summary>
            <div class="match-summary-header">
                <div class="match-summary-top-line">
                    <span class="match-summary-activity">${activityEmoji} ${activityName}</span>
                    <span class="match-summary-circle">${circleName}</span>
                    <span class="dropdown-indicator"></span>
                </div>
                <div class="match-summary-stats">
                    ${hasWarning ? `<span class="match-summary-badge warning"> Still interested?</span>` : ''}
                    ${userIsInMatch && userEvents.length === 0 ? `<span class="match-summary-stat"> Watching</span>` : ''}
                    ${upcomingEvents.length > 0 ? `<span class="match-summary-stat"> ${upcomingEvents.length} upcoming</span>` : ''}
                </div>
            </div>
        </summary>
        <div class="match-card-content">
    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 20px;">
        <div style="flex: 1; padding-right: 15px;">
            ${userIsInMatch && userEvents.length === 0 ? `
                <p style="margin: 0; color: var(--text-secondary); font-size: 13px;">
                     You're watching for events
                </p>
            ` : ''}
        </div>
        <div style="display: flex; flex-direction: column; gap: 10px; min-width: 140px; align-items: flex-end;">
    <span class="circle-tag">
        ${circleName}
    </span>
    ${hasWarning ? `
        <div class="match-info-box warning" style="margin-bottom: 10px;">
            <p style="margin: 0 0 8px 0; font-size: 13px; font-weight: 500;"> Still interested?</p>
            <p style="margin: 0 0 10px 0; font-size: 12px; line-height: 1.4;">We haven't seen you active in a while. Let us know you're still interested!</p>
            <button onclick="stayInterested('${match.id}')" class="btn" style="font-size: 13px; padding: 10px 16px; width: 100%; background: #ff4d4f;">
                 Yes, I'm Still Interested
            </button>
        </div>
    ` : ''}
    ${userIsInMatch ? `
        ${userEvents.length === 0 ? `
            <button onclick="openPlanningEventModal('${match.id}')" class="btn" style="font-size: 14px; padding: 12px 16px; width: 100%; margin: 0 0 8px 0; background: #4CAF50;">
                + Plan Event
            </button>
        ` : `
            <button onclick="openPlanningEventModal('${match.id}')" class="btn btn-secondary" style="font-size: 13px; padding: 8px 16px; width: 100%; margin: 0 0 8px 0;">
                + Plan Another Event
            </button>
        `}
        <button onclick="markAsUninterested('${match.id}', '${match.activity_id}', '${match.circle_id}')" class="btn" style="font-size: 12px; padding: 6px 12px; width: 100%; margin: 0; background: #6c757d; opacity: 0.7;">
             No Longer Interested
        </button>
    ` : (() => {
        // Check if there are upcoming events the user hasn't joined
        const unjoinedEvents = upcomingEvents.filter(e => !e.isUserJoined);
        if (unjoinedEvents.length > 0) {
            const firstEvent = unjoinedEvents[0];
            const buttonText = firstEvent.status === 'planning' ? ' Join Planning' : ' Join Event';
            const buttonColor = firstEvent.status === 'planning' ? '#ffc107' : '#4CAF50';
            const textColor = firstEvent.status === 'planning' ? '#000' : '#fff';
            return `
                <button onclick="event.stopPropagation(); joinEvent('${firstEvent.id}');" class="btn" style="font-size: 14px; padding: 12px 16px; width: 100%; margin: 0 0 8px 0; background: ${buttonColor}; color: ${textColor};">
                    ${buttonText}
                </button>
                <button onclick="markAsUninterested('${match.id}', '${match.activity_id}', '${match.circle_id}')" class="btn" style="font-size: 12px; padding: 6px 12px; width: 100%; margin: 0; background: #6c757d; opacity: 0.7;">
                     No Longer Interested
                </button>
            `;
        } else {
            return `
                <button onclick="(async () => { pendingSwipeMatchId = '${match.id}'; await handleStayInterested(); })();" class="btn" style="font-size: 14px; padding: 12px 16px; width: 100%; margin: 0 0 8px 0; background: #4CAF50;">
                     Stay Interested
                </button>
                <button onclick="markAsUninterested('${match.id}', '${match.activity_id}', '${match.circle_id}')" class="btn" style="font-size: 12px; padding: 6px 12px; width: 100%; margin: 0; background: #6c757d; opacity: 0.7;">
                     No Longer Interested
                </button>
            `;
        }
    })()}
</div>
    </div>
                
                ${upcomingEvents.length > 0 ? `
    <div style="margin-bottom: 15px;">
    <h4 style="margin: 0 0 12px 0; font-size: 15px; color: #666; font-weight: 600;">Upcoming</h4>
        ${upcomingEvents.map(event => {
            const participantCount = event.event_participants?.length || 0;
            const maxParticipants = event.max_participants;
            const isFull = maxParticipants && participantCount >= maxParticipants;
            const capacitySuffix = maxParticipants ? ` (${participantCount}/${maxParticipants})` : '';
            const participantDisplay = formatParticipantNames(
                event.event_participants || [],
                event.id,
                2,
                event.isUserJoined ? 'going' : 'interested'
            ) + capacitySuffix + (isFull && !event.isUserJoined ? ' - full' : '');

            // Handle planning events differently
            if (event.status === 'planning') {
                const timeframeText = event.proposed_timeframe || 'TBD';
                const isHighlighted = highlightedEventId === event.id;
                const hasUnread = event.unreadCount > 0;
                const isDarkMode = document.body.classList.contains('dark-mode');
                // Priority: highlighted (yellow) > unread (teal) > default (planning yellow)
                const bgColor = isHighlighted ? '#ffeb3b' : (hasUnread ? (isDarkMode ? '#134e4a' : '#ccfbf1') : '#fff3cd');
                const borderColor = hasUnread ? '#14b8a6' : '#ffc107';
                return `
                    <div class="event-item${hasUnread ? ' unread' : ''}" style="background: ${bgColor}; border-left: 4px solid ${borderColor};" data-joined="${event.isUserJoined}" data-unread="${hasUnread}">
                        <div style="display: flex; justify-content: space-between; align-items: start; gap: 10px;">
                            <div style="flex: 1;">
                                <div style="font-weight: 500; margin-bottom: 6px; font-size: 15px; display: flex; align-items: center; gap: 6px;">
                                     Planning Mode
                                </div>
                                <div class="event-meta" style="font-size: 13px;"> Proposed: ${timeframeText}</div>
                                ${event.location ? `<div class="event-meta" style="font-size: 13px;"> Suggested: ${event.location}</div>` : ''}
                                <div class="event-meta" style="font-size: 12px; margin-top: 4px;">${participantDisplay}</div>
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 6px; align-items: flex-end;">
                            ${event.isUserJoined ? `
                                <button onclick="event.stopPropagation(); openEventChat('${event.id}');" class="btn" style="font-size: 13px; padding: 6px 12px; width: auto; margin: 0; white-space: nowrap;">
                                     Open Chat
                                </button>
                            ` : `
                                <button onclick="event.stopPropagation(); joinEvent('${event.id}');" class="btn" style="font-size: 13px; padding: 6px 12px; width: auto; margin: 0; white-space: nowrap; background: #4CAF50;">
                                     Join Planning
                                </button>
                            `}
                            </div>
                        </div>
                    </div>
                `;
            } else {
                // Scheduled event
                const date = new Date(event.scheduled_date);
                const dateStr = date.toLocaleDateString('en-US', {
                    weekday: 'short',
                    month: 'short',
                    day: 'numeric'
                });
                const isHighlighted = highlightedEventId === event.id;
                const highlightStyle = isHighlighted ? ' style="background: #ffeb3b !important;"' : '';

                return `
                    <div class="event-item${event.unreadCount > 0 ? ' unread' : (event.isUserJoined ? '' : ' pending')}" data-unread="${event.unreadCount > 0}" data-joined="${event.isUserJoined}"${highlightStyle}>
                        <div style="display: flex; justify-content: space-between; align-items: start; gap: 10px;">
                            <div style="flex: 1;">
                                <div style="font-weight: 500; margin-bottom: 6px; font-size: 15px; display: flex; align-items: center; gap: 6px;">
                                     ${dateStr}
                                </div>
                                ${event.location ? `<div class="event-meta" style="font-size: 13px;"> ${event.location}</div>` : ''}
                                <div class="event-meta" style="font-size: 12px; margin-top: 4px;">${participantDisplay}</div>
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 6px; align-items: flex-end;">
                            ${event.isUserJoined ? `
                                <button onclick="event.stopPropagation(); openEventChat('${event.id}');" class="btn btn-secondary" style="font-size: 13px; padding: 6px 12px; width: auto; margin: 0; white-space: nowrap;">
                                     Open Chat
                                </button>
                            ` : isFull ? `
                                <button class="btn" disabled style="font-size: 13px; padding: 6px 12px; width: auto; margin: 0; white-space: nowrap; background: #888; cursor: not-allowed;">
                                    Event Full
                                </button>
                            ` : `
                                <button onclick="event.stopPropagation(); joinEvent('${event.id}');" class="btn" style="font-size: 13px; padding: 6px 12px; width: auto; margin: 0; white-space: nowrap; background: #4CAF50;">
                                     Join Event
                                </button>
                            `}
                            ${participantCount === 0 && event.created_by === currentUser.id ? `
                                <button onclick="event.stopPropagation(); deleteEmptyEvent('${event.id}');" class="btn btn-secondary" style="font-size: 11px; padding: 4px 8px; width: auto; margin: 0; white-space: nowrap; background: #dc3545; color: white;">
                                     Delete
                                </button>
                            ` : ''}
                            </div>
                        </div>
                    </div>
                `;
            }
        }).join('')}
    </div>
` : `
                    <div class="empty-event-placeholder">
                         No events scheduled yet - schedule something!
                    </div>
                `}
                
                ${pastEvents.length > 0 ? `
                    <details style="margin-top: 10px;">
                        <summary style="cursor: pointer; color: var(--text-secondary); font-size: 14px;">Past Events (${pastEvents.length})</summary>
                        <div style="margin-top: 8px;">
                            ${pastEvents.map(event => {
                                const date = new Date(event.scheduled_date);
                                const dateStr = date.toLocaleDateString('en-US', { 
                                    month: 'short', 
                                    day: 'numeric'
                                });
                                const statusEmoji = event.status === 'completed' ? '' : event.status === 'cancelled' ? '' : '';
                                
                                return `
    <div class="event-item" style="padding: 8px; margin-bottom: 4px; background: var(--bg-secondary); border-radius: 4px; opacity: 0.7; font-size: 13px; display: flex; justify-content: space-between; align-items: center;">
        <div>
            ${statusEmoji} ${dateStr}${event.location ? `  ${event.location}` : ''}
        </div>
        <button onclick="openEventChat('${event.id}')" class="btn btn-secondary" style="font-size: 12px; padding: 4px 8px; width: auto; margin: 0; opacity: 1;">
            Chat
        </button>
    </div>
`;
                            }).join('')}
                        </div>
                    </details>
                ` : ''}
        </div>
    </details>
        `;
                    }).join('')}
                </div>
            </div>
        `;
    }).join('');

    // Update button visibility based on today activities
    matches.forEach(match => {
        const isToday = todayActivityIds.has(match.activity_id.toString());
        const button = document.getElementById(`today-btn-${match.id}`);
        if (button) {
            button.style.display = isToday ? 'none' : 'inline-block';
        }
    });
    
    document.querySelectorAll('.event-item').forEach(item => {
        item.addEventListener('mouseenter', function() {
            // Don't change background on hover if this is the highlighted event
            if (this.style.background && this.style.background.includes('rgb(255, 235, 59)')) {
                return; // Keep the yellow highlight
            }
            // Don't change background on hover if this is a planning event (yellow)
            if (this.style.background && (this.style.background.includes('rgb(255, 243, 205)') || this.style.background.includes('#fff3cd'))) {
                return; // Keep the planning yellow
            }
            const isDarkMode = document.body.classList.contains('dark-mode');
            this.style.background = isDarkMode ? '#2a2a2e' : '#e8e8e8';
        });
        item.addEventListener('mouseleave', function() {
            // Don't change background on hover out if this is the highlighted event
            if (this.style.background && this.style.background.includes('rgb(255, 235, 59)')) {
                return; // Keep the yellow highlight
            }
            const isDarkMode = document.body.classList.contains('dark-mode');
            if (this.style.opacity === '0.7') {
                // Past events
                this.style.background = isDarkMode ? '#1a1a1a' : '#fafafa';
            } else if (this.dataset.unread === 'true') {
                // Unread events
                this.style.background = isDarkMode ? '#134e4a' : '#ccfbf1';
            } else if (this.dataset.joined === 'true') {
                // Joined events
                this.style.background = isDarkMode ? '#1a1a1e' : '#f5f5f5';
            } else {
                // Not joined events
                this.style.background = isDarkMode ? '#2a2415' : '#fff8e1';
            }
        });
    });

    // If there's a highlighted event, expand the match and scroll to it
    if (highlightedEventId) {
        setTimeout(() => {
            // Find all event items and locate the highlighted one
            const allEventItems = document.querySelectorAll('.event-item');
            let highlightedElement = null;

            allEventItems.forEach(item => {
                // Check if any button within this event item has the highlighted event ID
                const openChatBtn = item.querySelector(`button[onclick*="openEventChat('${highlightedEventId}')"]`);
                const joinEventBtn = item.querySelector(`button[onclick*="joinEvent('${highlightedEventId}')"]`);

                if (openChatBtn || joinEventBtn) {
                    highlightedElement = item;
                }
            });

            if (highlightedElement) {
                // Find the parent circle group
                const circleGroup = highlightedElement.closest('.match-circle-group');
                if (circleGroup) {
                    const circleId = circleGroup.dataset.circleId;
                    if (circleId && !expandedMatchCircles.has(circleId)) {
                        expandedMatchCircles.add(circleId);
                        circleGroup.classList.add('expanded');
                    }
                }

                // Find the parent match card (details element)
                const matchCard = highlightedElement.closest('.match-card');
                if (matchCard) {
                    // Expand the match card
                    matchCard.open = true;

                    // Scroll to the highlighted event
                    setTimeout(() => {
                        highlightedElement.scrollIntoView({
                            behavior: 'smooth',
                            block: 'center'
                        });
                    }, 100);
                }
            }

            // Clear the highlighted event ID after a delay
            setTimeout(() => {
                highlightedEventId = null;
            }, 5000); // Clear after 5 seconds
        }, 200); // Small delay to ensure DOM is ready
    }
}

window.toggleMatchCircleExpand = function(circleId) {
  const card = document.querySelector(`.match-circle-group[data-circle-id="${circleId}"]`);
  if (!card) return;

  if (expandedMatchCircles.has(circleId)) {
    expandedMatchCircles.delete(circleId);
    card.classList.remove('expanded');
  } else {
    expandedMatchCircles.add(circleId);
    card.classList.add('expanded');
  }
};

window.joinMatch = async function(matchId) {
    try {
        const match = matches.find(m => m.id === matchId);
        if (!match) return;

        // Add user to match participants
        const { error } = await supabase
            .from('match_participants')
            .insert([{
                match_id: matchId,
                profile_id: currentUser.id
            }]);

        if (error) throw error;

        showNotification('Joined match! You can now chat and schedule events.');

        // Refresh matches to update UI
        await loadMatches();

    } catch (error) {
        console.error('Error joining match:', error);
        showNotification('Error joining match', 'error');
    }
}

window.joinEvent = async function(eventId) {
    try {
        showLoader('Joining event...');

        // First, check if event has a participant limit
        const { data: eventCheck, error: checkError } = await supabase
            .from('events')
            .select('max_participants, event_participants(profile_id)')
            .eq('id', eventId)
            .single();

        if (checkError) throw checkError;

        // Check if event is full
        const currentCount = eventCheck.event_participants?.length || 0;
        if (eventCheck.max_participants && currentCount >= eventCheck.max_participants) {
            hideLoader();
            showNotification('This event is full', 'error');
            return;
        }

        // Add user to event participants
        const { error } = await supabase
            .from('event_participants')
            .insert([{
                event_id: eventId,
                profile_id: currentUser.id,
                status: 'accepted'
            }]);

        if (error) throw error;

        // Get event details for notification
        const { data: event, error: eventError } = await supabase
            .from('events')
            .select(`
                id,
                match_id,
                scheduled_date,
                scheduled_time,
                activity_id,
                activities(name, emoji),
                event_participants(profile_id)
            `)
            .eq('id', eventId)
            .single();

        if (eventError) {
            console.error('Error loading event details:', eventError);
        }

        // Update last_interaction_at for inactivity tracking
        if (event && event.match_id) {
            await supabase
                .from('match_participants')
                .update({ last_interaction_at: new Date().toISOString() })
                .eq('match_id', event.match_id)
                .eq('profile_id', currentUser.id);
        }

        // Send notification to existing participants (non-blocking - fire and forget)
        if (event) {
            sendEventJoinNotification(event).catch(err => {
                console.error('Error sending event join notification:', err);
            });
        }

        hideLoader();
        showNotification('Joining event chat...');

        // Refresh matches to update UI
        await loadMatches();

        // Automatically open the event chat
        await openEventChat(eventId);

        // Refresh events page if currently viewing it
        const currentPage = document.querySelector('.page.active')?.id;
        if (currentPage === 'events') {
            await loadEvents();
        }

        // Match chat deprecated - no need to refresh after joining event

    } catch (error) {
        hideLoader();
        console.error('Error joining event:', error);
        showNotification('Error joining event', 'error');
    }
}

window.markActivityAsToday = async function(activityId, matchId) {
    if (!currentUser) return;
    
    try {
        // Find the circle ID from the match
        const match = matches.find(m => m.id === matchId);
        if (!match) return;
        
        // Set activity as available today
        const endOfDay = new Date();
        endOfDay.setHours(23, 59, 59, 999);
        
        await supabase
            .from('activity_availability')
            .upsert({
                profile_id: currentUser.id,
                circle_id: match.circle_id,
                activity_id: activityId.toString(),
                available_until: endOfDay.toISOString()
            }, {
                onConflict: 'profile_id,circle_id,activity_id'
            });
        
        showNotification('Marked as available today!');
        
        // Hide the button immediately
        const button = document.getElementById(`today-btn-${matchId}`);
        if (button) {
            button.style.display = 'none';
        }
        
        // Refresh matches to update participant list
        await loadMatches();
        
    } catch (error) {
        console.error('Error marking activity as today:', error);
        showNotification('Error updating availability', 'error');
    }
}

        window.sendMessage = async function() {
    const input = document.getElementById('message-input');
    if (!input.value.trim()) return;
    
    const messageContent = input.value.trim(); // Capture message FIRST
    
    const context = getCurrentChatContext();
    console.log(' Sending message in context:', context.type);
    
    try {
        if (context.type === 'event') {
            // EVENT CHAT
            const { data, error } = await supabase
                .from('event_messages')
                .insert({
                    event_id: context.id,
                    sender_id: currentUser.id,
                    content: messageContent
                })
                .select(`*, sender:profiles(id, name, avatar)`)
                .single();
            
            if (error) throw error;
            
            appendMessage(data);
            
            const channel = supabase.channel(`event_${context.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'new_message',
                payload: {
                    id: data.id,
                    sender_id: currentUser.id,
                    sender_name: currentUser.name,
                    sender_avatar: currentUser.avatar,
                    content: data.content,
                    created_at: data.created_at,
                    message_type: data.message_type,
                    poll_id: data.poll_id
                }
            });

        } else if (context.type === 'circle') {
            // CIRCLE CHAT
            const { data, error } = await supabase
                .from('circle_messages')
                .insert({
                    circle_id: context.id,
                    sender_id: currentUser.id,
                    content: messageContent
                })
                .select(`*, sender:profiles(id, name, avatar)`)
                .single();

            if (error) throw error;

            appendMessage(data);

            const channel = supabase.channel(`circle_chat_${context.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'new_circle_message',
                payload: {
                    id: data.id,
                    sender_id: currentUser.id,
                    sender_name: currentUser.name,
                    sender_avatar: currentUser.avatar,
                    content: data.content,
                    created_at: data.created_at,
                    circle_id: context.id
                }
            });

        } else {
            console.error(' No active chat context');
            showNotification('No active chat', 'error');
            return;
        }
        
        // Send push notification via Supabase Edge Function
        try {
            console.log(' Starting notification send process...');
            const context = getCurrentChatContext();
            let recipientIds = [];
            let activityName = 'Chat';
            
            if (context.type === 'event') {
                // Get event participants (excluding sender)
                const { data: participants } = await supabase
                    .from('event_participants')
                    .select('profile_id')
                    .eq('event_id', context.id)
                    .neq('profile_id', currentUser.id);
                
                recipientIds = participants?.map(p => p.profile_id) || [];
                
                // Get activity name
                const activity = activities.find(a => a.id === currentEvent?.activity_id);
                activityName = activity ? `${activity.emoji} ${activity.name}` : 'Event';

            } else if (context.type === 'circle') {
                // Get circle members (excluding sender)
                const { data: members } = await supabase
                    .from('circle_members')
                    .select('profile_id')
                    .eq('circle_id', context.id)
                    .neq('profile_id', currentUser.id);

                recipientIds = members?.map(m => m.profile_id) || [];

                // Get circle name
                const circle = circles.find(c => c.id === context.id);
                activityName = circle ? ` ${circle.name}` : 'Circle Chat';
            }

            console.log(' Recipient IDs (before mute filter):', recipientIds);

            // Filter out users who have muted this chat
            if (recipientIds.length > 0) {
                let muteQuery = supabase
                    .from('muted_chats')
                    .select('profile_id')
                    .in('profile_id', recipientIds);

                if (context.type === 'event') {
                    muteQuery = muteQuery.eq('event_id', context.id);
                } else if (context.type === 'circle') {
                    muteQuery = muteQuery.eq('circle_id', context.id);
                }

                const { data: mutedUsers, error: muteError } = await muteQuery;

                if (!muteError && mutedUsers && mutedUsers.length > 0) {
                    const mutedUserIds = mutedUsers.map(u => u.profile_id);
                    recipientIds = recipientIds.filter(id => !mutedUserIds.includes(id));
                    console.log(' Filtered out muted users:', mutedUserIds);
                }
            }

            console.log(' Recipient IDs (after mute filter):', recipientIds);

            if (recipientIds.length > 0) {
                console.log(' Calling Edge Function with:', {
                    senderId: currentUser.id,
                    recipientIds: recipientIds,
                    message: messageContent,
                    activityName: activityName,
                    chatType: context.type
                });

                const { data: notifData, error: notifError } = await supabase.functions.invoke('send-notification', {
                    body: {
                        senderId: currentUser.id,
                        recipientIds: recipientIds,
                        message: messageContent,
                        activityName: activityName,
                        chatType: context.type,
                        chatId: context.id,
                        notificationType: 'chat_message'
                    }
                });

                if (notifError) {
                    console.error(' Error sending chat notification:', notifError);
                } else {
                    console.log(' Chat notification sent successfully:', notifData);
                }
            }
        } catch (notifError) {
            console.error('Error sending notification:', notifError);
            // Don't block message send if notification fails
        }
        
        // Clear input LAST
        input.value = '';
        input.style.height = 'auto'; // Reset height after sending

    } catch (error) {
        console.error('Error sending message:', error);
        showNotification('Failed to send message', 'error');
    }
}
        
        window.handleMessageKeyPress = function(e) {
            // Auto-resize textarea as user types
            const textarea = e.target;
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 150) + 'px';

            // Send message on Enter, allow Shift+Enter for new lines
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        };

        // Initialize textarea auto-resize on page load
        window.initMessageInput = function() {
            const messageInput = document.getElementById('message-input');
            if (messageInput) {
                messageInput.addEventListener('input', function() {
                    this.style.height = 'auto';
                    this.style.height = Math.min(this.scrollHeight, 150) + 'px';
                });
            }
        };
        
window.toggleEventMessageActions = function(msgId) {
    const menu = document.getElementById(`event-menu-${msgId}`);
    if (menu) {
        menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
    }
    
    // Close other open menus
    document.querySelectorAll('.message-actions-menu').forEach(m => {
        if (m.id !== `event-menu-${msgId}`) {
            m.style.display = 'none';
        }
    });
}

window.editEventMessage = async function(msgId, currentContent) {
    const menu = document.getElementById(`event-menu-${msgId}`);
    if (menu) menu.style.display = 'none';
    
    if (currentContent.includes('<img') || currentContent.includes('<a')) {
        showNotification('Photos and links cannot be edited, only deleted', 'error');
        return;
    }
    
    const newContent = prompt('Edit your message:', currentContent);

    if (!newContent || newContent.trim() === currentContent.trim()) return;

    const context = getCurrentChatContext();
    console.log(' Editing message in context:', context.type);

    // Save scroll position before reload
    const messagesContainer = document.getElementById('chat-messages');
    const scrollPos = messagesContainer ? messagesContainer.scrollTop : 0;

    try {
        if (context.type === 'event') {
            const { error } = await supabase
                .from('event_messages')
                .update({ content: newContent.trim() })
                .eq('id', msgId)
                .eq('sender_id', currentUser.id);

            if (error) throw error;

            const channel = supabase.channel(`event_${context.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'message_edited',
                payload: { id: msgId, content: newContent.trim() }
            });

            await loadEventMessages(context.id, context.data.created_at, true, scrollPos);

        } else if (context.type === 'circle') {
            const { error } = await supabase
                .from('circle_messages')
                .update({ content: newContent.trim() })
                .eq('id', msgId)
                .eq('sender_id', currentUser.id);

            if (error) throw error;

            const channel = supabase.channel(`circle_chat_${context.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'message_edited',
                payload: { id: msgId, content: newContent.trim() }
            });

            await loadAndDisplayCircleMessages(context.id, true, scrollPos);
        }

        showNotification('Message updated');

    } catch (error) {
        console.error('Error editing message:', error);
        showNotification('Failed to edit message', 'error');
    }
}

window.deleteEventMessage = async function(msgId) {
    const menu = document.getElementById(`event-menu-${msgId}`);
    if (menu) menu.style.display = 'none';

    if (!confirm('Delete this message?')) return;

    const context = getCurrentChatContext();
    console.log(' Soft-deleting message in context:', context.type);

    // Save scroll position before reload
    const messagesContainer = document.getElementById('chat-messages');
    const scrollPos = messagesContainer ? messagesContainer.scrollTop : 0;

    try {
        // SECURITY: Use soft delete instead of hard delete to preserve message history
        if (context.type === 'event') {
            const { error } = await supabase
                .from('event_messages')
                .update({
                    is_deleted: true,
                    deleted_at: new Date().toISOString()
                })
                .eq('id', msgId)
                .eq('sender_id', currentUser.id);

            if (error) throw error;

            const channel = supabase.channel(`event_${context.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'message_deleted',
                payload: { id: msgId }
            });

            // Stay in event chat - just reload the event messages
            await loadEventMessages(context.id, context.data.created_at, true, scrollPos);

        } else if (context.type === 'circle') {
            const { error } = await supabase
                .from('circle_messages')
                .update({
                    is_deleted: true,
                    deleted_at: new Date().toISOString()
                })
                .eq('id', msgId)
                .eq('sender_id', currentUser.id);

            if (error) throw error;

            const channel = supabase.channel(`circle_chat_${context.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'message_deleted',
                payload: { id: msgId }
            });

            await loadAndDisplayCircleMessages(context.id, true, scrollPos);
        }

        showNotification('Message deleted');

    } catch (error) {
        console.error('CAUGHT ERROR in deleteEventMessage:', error);
        console.error('Error details:', error.message, error.code);
        showNotification('Failed to delete message', 'error');
    }
}

// ========== MESSAGE REACTIONS ==========
// Available reaction emojis
const REACTION_EMOJIS = ['', '', '', '', '', ''];

// Store reactions for all messages in memory
const messageReactions = new Map(); // messageId -> array of reactions

// Fetch reactions for a specific message
window.fetchMessageReactions = async function(messageId, messageType) {
    const tableName = messageType === 'event' ? 'event_message_reactions' :
                      messageType === 'match' ? 'match_message_reactions' :
                      'circle_message_reactions';

    try {
        const { data, error } = await supabase
            .from(tableName)
            .select('id, emoji, profile_id, created_at, profiles:profile_id(name, avatar)')
            .eq('message_id', messageId);

        if (error) throw error;

        // Store in cache
        messageReactions.set(messageId, data || []);
        return data || [];
    } catch (error) {
        console.error('Error fetching reactions:', error);
        return [];
    }
}

// Toggle a reaction on a message
window.toggleReaction = async function(messageId, emoji, messageType) {
    const tableName = messageType === 'event' ? 'event_message_reactions' :
                      messageType === 'match' ? 'match_message_reactions' :
                      'circle_message_reactions';

    try {
        // Check if user already reacted with this emoji
        const { data: existing, error: fetchError } = await supabase
            .from(tableName)
            .select('id')
            .eq('message_id', messageId)
            .eq('profile_id', currentUser.id)
            .eq('emoji', emoji)
            .maybeSingle();

        if (fetchError) throw fetchError;

        if (existing) {
            // Remove reaction
            const { error: deleteError } = await supabase
                .from(tableName)
                .delete()
                .eq('id', existing.id);

            if (deleteError) throw deleteError;
        } else {
            // Add reaction
            const { error: insertError } = await supabase
                .from(tableName)
                .insert({
                    message_id: messageId,
                    profile_id: currentUser.id,
                    emoji: emoji
                });

            if (insertError) throw insertError;
        }

        // Refresh reactions for this message
        await fetchMessageReactions(messageId, messageType);

        // Broadcast reaction change
        const context = getCurrentChatContext();
        const channelName = messageType === 'event' ? `event_${context.id}` :
                           messageType === 'match' ? `match_chat_${context.id}` :
                           `circle_chat_${context.id}`;

        const channel = supabase.channel(channelName);
        await channel.send({
            type: 'broadcast',
            event: 'reaction_changed',
            payload: { messageId }
        });

        // Update UI
        updateReactionDisplay(messageId, messageType);

    } catch (error) {
        console.error('Error toggling reaction:', error);
        showNotification('Failed to update reaction', 'error');
    }
}

// Show reaction picker for a message
window.showReactionPicker = function(messageId, messageType, event) {
    event.stopPropagation();

    // Close any existing pickers
    document.querySelectorAll('.reaction-picker').forEach(p => p.remove());

    const picker = document.createElement('div');
    picker.className = 'reaction-picker';
    picker.style.cssText = `
        position: absolute;
        background: var(--card-bg, white);
        border: 1px solid var(--border-color, #ddd);
        border-radius: 8px;
        padding: 8px;
        display: flex;
        gap: 4px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        z-index: 1000;
    `;

    REACTION_EMOJIS.forEach(emoji => {
        const button = document.createElement('button');
        button.textContent = emoji;
        button.style.cssText = `
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.2s;
        `;
        button.onmouseover = () => button.style.background = 'var(--bg-secondary)';
        button.onmouseout = () => button.style.background = 'none';
        button.onclick = async () => {
            await toggleReaction(messageId, emoji, messageType);
            picker.remove();
        };
        picker.appendChild(button);
    });

    // Position picker near the clicked element
    const rect = event.target.getBoundingClientRect();
    picker.style.top = `${rect.top - 50}px`;
    picker.style.left = `${rect.left}px`;

    document.body.appendChild(picker);

    // Close picker when clicking outside
    setTimeout(() => {
        document.addEventListener('click', function closePicker(e) {
            if (!picker.contains(e.target)) {
                picker.remove();
                document.removeEventListener('click', closePicker);
            }
        });
    }, 0);
}

// Render reactions display for a message
window.renderReactions = function(messageId, messageType) {
    const reactions = messageReactions.get(messageId) || [];

    if (reactions.length === 0) {
        return '';
    }

    // Group reactions by emoji
    const grouped = {};
    reactions.forEach(reaction => {
        if (!grouped[reaction.emoji]) {
            grouped[reaction.emoji] = [];
        }
        grouped[reaction.emoji].push(reaction);
    });

    // Create reaction buttons
    const reactionButtons = Object.entries(grouped).map(([emoji, reactionList]) => {
        const count = reactionList.length;
        const userReacted = reactionList.some(r => r.profile_id === currentUser.id);
        const names = reactionList.map(r => r.profiles.name).join(', ');

        return `
            <button
                onclick="toggleReaction('${messageId}', '${emoji}', '${messageType}')"
                onmouseenter="showReactionTooltip(event, '${names.replace(/'/g, "\\'")}')"
                onmouseleave="hideReactionTooltip()"
                style="
                    background: ${userReacted ? 'var(--primary-color)' : 'var(--card-bg)'};
                    color: ${userReacted ? 'white' : 'var(--text-primary)'};
                    border: 1px solid ${userReacted ? 'var(--primary-color)' : 'var(--border-color)'};
                    border-radius: 12px;
                    padding: 4px 8px;
                    font-size: 14px;
                    cursor: pointer;
                    display: inline-flex;
                    align-items: center;
                    gap: 4px;
                    transition: all 0.2s;
                "
                onmouseover="if(!${userReacted}) this.style.background='var(--bg-secondary)'"
                onmouseout="if(!${userReacted}) this.style.background='var(--card-bg)'"
            >
                <span>${emoji}</span>
                <span style="font-size: 12px;">${count}</span>
            </button>
        `;
    }).join('');

    return `
        <div class="message-reactions" style="
            display: flex;
            gap: 6px;
            margin-top: 6px;
            flex-wrap: wrap;
            align-items: center;
        ">
            ${reactionButtons}
        </div>
    `;
}

// Show tooltip with names of people who reacted
let reactionTooltip = null;
window.showReactionTooltip = function(event, names) {
    hideReactionTooltip();

    reactionTooltip = document.createElement('div');
    reactionTooltip.style.cssText = `
        position: fixed;
        background: var(--tooltip-bg, rgba(0, 0, 0, 0.8));
        color: white;
        padding: 6px 10px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 10000;
        pointer-events: none;
        white-space: nowrap;
        max-width: 200px;
        overflow: hidden;
        text-overflow: ellipsis;
    `;
    reactionTooltip.textContent = names;

    const rect = event.target.getBoundingClientRect();
    reactionTooltip.style.top = `${rect.top - 30}px`;
    reactionTooltip.style.left = `${rect.left}px`;

    document.body.appendChild(reactionTooltip);
}

window.hideReactionTooltip = function() {
    if (reactionTooltip) {
        reactionTooltip.remove();
        reactionTooltip = null;
    }
}

// Update reaction display for a specific message
window.updateReactionDisplay = function(messageId, messageType) {
    const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
    if (!messageElement) return;

    // Find or create reactions container
    let reactionsContainer = messageElement.querySelector('.message-reactions-wrapper');
    if (!reactionsContainer) {
        reactionsContainer = document.createElement('div');
        reactionsContainer.className = 'message-reactions-wrapper';
        messageElement.appendChild(reactionsContainer);
    }

    reactionsContainer.innerHTML = `
        ${renderReactions(messageId, messageType)}
        <button
            onclick="showReactionPicker('${messageId}', '${messageType}', event)"
            style="
                background: none;
                border: 1px solid var(--border-color);
                border-radius: 12px;
                padding: 4px 8px;
                font-size: 16px;
                cursor: pointer;
                color: var(--text-secondary);
                transition: all 0.2s;
            "
            onmouseover="this.style.background='var(--bg-secondary)'"
            onmouseout="this.style.background='none'"
            title="Add reaction"
        >
            +
        </button>
    `;
}

// ========== END MESSAGE REACTIONS ==========

// ========== MESSAGE READ COUNTS ==========

// Store read counts for messages in memory
const messageReadCounts = new Map(); // messageId -> { count, readers: [] }

// Fetch read count for a specific message
window.fetchMessageReadCount = async function(messageId, messageType) {
    const tableName = messageType === 'event' ? 'event_message_reads' :
                      messageType === 'match' ? 'match_message_reads' :
                      'circle_message_reads';

    try {
        const { data, error } = await supabase
            .from(tableName)
            .select('id, profile_id, read_at')
            .eq('message_id', messageId);

        if (error) throw error;

        const count = data ? data.length : 0;
        // Store in cache
        messageReadCounts.set(messageId, {
            count: count,
            readers: data || []
        });
        return count;
    } catch (error) {
        console.error('Error fetching read count:', error);
        return 0;
    }
}

// Update read count display for a specific message (only for user's own messages)
window.updateReadCountDisplay = async function(messageId, messageType, senderId) {
    // Only show read count on user's own messages
    if (senderId !== currentUser.id) return;

    const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
    if (!messageElement) return;

    // Fetch the read count
    const count = await fetchMessageReadCount(messageId, messageType);

    // Find or create read count container
    let readCountContainer = messageElement.querySelector('.message-read-count');
    if (!readCountContainer) {
        readCountContainer = document.createElement('div');
        readCountContainer.className = 'message-read-count';
        readCountContainer.style.cssText = `
            font-size: 11px;
            color: #999;
            margin-top: 4px;
            padding-left: 4px;
        `;

        // Insert after the reactions wrapper
        const reactionsWrapper = messageElement.querySelector('.message-reactions-wrapper');
        if (reactionsWrapper) {
            reactionsWrapper.parentNode.insertBefore(readCountContainer, reactionsWrapper.nextSibling);
        } else {
            messageElement.appendChild(readCountContainer);
        }
    }

    // Update the text
    if (count === 0) {
        readCountContainer.textContent = '';
    } else if (count === 1) {
        readCountContainer.textContent = 'Read by 1 person';
    } else {
        readCountContainer.textContent = `Read by ${count} people`;
    }
}

// Mark a single message as read
window.markMessageAsRead = async function(messageId, messageType) {
    const tableName = messageType === 'event' ? 'event_message_reads' :
                      messageType === 'match' ? 'match_message_reads' :
                      'circle_message_reads';

    try {
        // Insert or ignore if already exists (UNIQUE constraint)
        const { error } = await supabase
            .from(tableName)
            .upsert({
                message_id: messageId,
                profile_id: currentUser.id,
                read_at: new Date().toISOString()
            }, {
                onConflict: 'message_id,profile_id',
                ignoreDuplicates: true
            });

        if (error && !error.message.includes('duplicate')) {
            throw error;
        }

        // Broadcast read event
        const context = getCurrentChatContext();
        const channelName = messageType === 'event' ? `event_${context.id}` :
                           messageType === 'match' ? `match_chat_${context.id}` :
                           `circle_chat_${context.id}`;

        const channel = supabase.channel(channelName);
        await channel.send({
            type: 'broadcast',
            event: 'message_read',
            payload: { messageId }
        });

    } catch (error) {
        console.error('Error marking message as read:', error);
    }
}

// Mark all visible messages as read in the current chat
window.markAllVisibleMessagesAsRead = async function(messageType) {
    const messagesContainer = document.getElementById('chat-messages');
    if (!messagesContainer) return;

    const messageElements = messagesContainer.querySelectorAll('[data-message-id]');

    for (const messageElement of messageElements) {
        const messageId = messageElement.getAttribute('data-message-id');
        if (messageId) {
            // Mark as read without broadcasting (to avoid spam)
            const tableName = messageType === 'event' ? 'event_message_reads' :
                              messageType === 'match' ? 'match_message_reads' :
                              'circle_message_reads';

            try {
                await supabase
                    .from(tableName)
                    .upsert({
                        message_id: messageId,
                        profile_id: currentUser.id,
                        read_at: new Date().toISOString()
                    }, {
                        onConflict: 'message_id,profile_id',
                        ignoreDuplicates: true
                    });
            } catch (error) {
                // Ignore duplicate errors
                if (!error.message?.includes('duplicate')) {
                    console.error('Error marking message as read:', error);
                }
            }
        }
    }

    // Broadcast a single read event for efficiency
    const context = getCurrentChatContext();
    const channelName = messageType === 'event' ? `event_${context.id}` :
                       messageType === 'match' ? `match_chat_${context.id}` :
                       `circle_chat_${context.id}`;

    const channel = supabase.channel(channelName);
    await channel.send({
        type: 'broadcast',
        event: 'messages_read',
        payload: { userId: currentUser.id }
    });
}

// ========== END MESSAGE READ COUNTS ==========

// Global variable to track current event
let currentEvent = null;
let eventMessageSubscription = null;

// Open modal to create new event
function openCreateEventModal(matchId) {
    const match = matches.find(m => m.id === matchId);
    if (!match) return;
    
    document.getElementById('new-event-match-id').value = matchId;
    document.getElementById('create-event-form').reset();
    
    // Set min date to today
    const today = new Date();
    document.getElementById('new-event-date').min = today.toISOString().slice(0, 10);
    
    document.getElementById('create-event-modal').style.display = 'flex';
}

function closeCreateEventModal() {
    document.getElementById('create-event-modal').style.display = 'none';
}

// Open modal from header using current match context
function openCreateEventModalFromHeader() {
    if (!currentMatchId) {
        console.error('No current match context');
        return;
    }
    openCreateEventModal(currentMatchId);
}

// ========== NEW MODALS FOR PLANNING MODE ==========

// Swipe Action Modal (Plan Event / Stay Interested)
let pendingSwipeMatchId = null;
let pendingSwipeActivity = null;

async function openSwipeActionModal(matchId, activityName, activity = null) {
    pendingSwipeMatchId = matchId;
    pendingSwipeActivity = activity;

    // Get match data for interested counts
    const match = matches.find(m => m.id === matchId);
    const totalInterestedCount = match?.interestedCount || 0;

    // Fetch events for this match to check if any exist
    const { data: events, error } = await supabase
        .from('events')
        .select(`
            *,
            event_participants(profile_id)
        `)
        .eq('match_id', matchId)
        .in('status', ['planning', 'scheduled']);

    // Calculate going count from event participants (upcoming events only)
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const upcomingEvents = (events || []).filter(e => {
        if (e.status === 'planning') return true;
        const isScheduled = e.status === 'scheduled';
        const isFuture = new Date(e.scheduled_date) >= today;
        return isScheduled && isFuture;
    });

    const goingUserIds = new Set();
    upcomingEvents.forEach(event => {
        (event.event_participants || []).forEach(participant => {
            goingUserIds.add(participant.profile_id);
        });
    });

    const goingCount = goingUserIds.size;
    const watchingCount = Math.max(0, totalInterestedCount - goingCount);

    // Get the modal content container
    const modal = document.getElementById('swipe-action-modal');
    const modalContent = modal.querySelector('.modal-content');

    if (error) {
        console.error('Error fetching events:', error);
        // Fall back to default modal
        modalContent.innerHTML = `
            <span class="close-modal-btn" onclick="closeSwipeActionModal()"></span>
            <div class="modal-header">${activityName || ' Activity'} Match!</div>

            <div style="margin-bottom: 20px; color: #666; line-height: 1.6; text-align: center;">
                <p id="swipe-action-description">You matched! Would you like to plan an event or just stay interested for now?</p>
            </div>

            <button onclick="handlePlanEvent()" class="btn" style="width: 100%; margin-bottom: 10px; background: #007bff;">
                 Plan Event
            </button>

            <button onclick="handleStayInterested()" class="btn btn-secondary" style="width: 100%; background: #6c757d; color: white;">
                 Stay Interested
            </button>

            <div style="margin-top: 15px; font-size: 12px; color: #999; text-align: center;">
                "Stay Interested" lets you watch for events others create without planning one yourself.
            </div>
        `;
        modal.style.display = 'flex';
        return;
    }

    // Mark which events user has joined (upcomingEvents already filtered above)
    const upcomingEventsWithUserStatus = upcomingEvents.map(e => ({
        ...e,
        isUserJoined: e.event_participants?.some(p => p.profile_id === currentUser.id) || false
    }));

    // Check if user hasn't joined any events
    const unjoinedEvents = upcomingEventsWithUserStatus.filter(e => !e.isUserJoined);

    if (unjoinedEvents.length > 0) {
        // Show join buttons for unjoined events
        const firstEvent = unjoinedEvents[0];
        const buttonText = firstEvent.status === 'planning' ? ' Join Planning' : ' Join Event';
        const buttonColor = firstEvent.status === 'planning' ? '#ffc107' : '#4CAF50';
        const textColor = firstEvent.status === 'planning' ? '#000' : '#fff';

        let eventDetails = '';
        if (firstEvent.status === 'planning') {
            const timeframe = firstEvent.proposed_timeframe || 'TBD';
            eventDetails = `<p style="font-size: 14px; color: #666; margin: 10px 0;"> Proposed: ${timeframe}</p>`;
            if (firstEvent.location) {
                eventDetails += `<p style="font-size: 14px; color: #666; margin: 10px 0;"> Suggested: ${firstEvent.location}</p>`;
            }
        } else {
            const date = new Date(firstEvent.scheduled_date);
            const dateStr = date.toLocaleDateString('en-US', {
                weekday: 'short',
                month: 'short',
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit'
            });
            eventDetails = `<p style="font-size: 14px; color: #666; margin: 10px 0;"> ${dateStr}</p>`;
            if (firstEvent.location) {
                eventDetails += `<p style="font-size: 14px; color: #666; margin: 10px 0;"> ${firstEvent.location}</p>`;
            }
        }

        const participantCount = firstEvent.event_participants?.length || 0;
        const participantText = participantCount === 1 ? '1 person' : `${participantCount} people`;

        modalContent.innerHTML = `
            <span class="close-modal-btn" onclick="closeSwipeActionModal()"></span>
            <div class="modal-header">${activityName || ' Activity'} Match!</div>

            <div style="margin-bottom: 20px; color: #666; line-height: 1.6; text-align: center;">
                <p>${firstEvent.status === 'planning' ? 'There\'s a planning session you can join!' : 'There\'s an event you can join!'}</p>
                ${eventDetails}
                ${watchingCount > 0 ? `<p style="font-size: 13px; color: var(--text-secondary); margin-top: 5px;"> ${watchingCount} watching</p>` : ''}
                ${goingCount > 0 ? `<p style="font-size: 13px; color: var(--text-secondary); margin-top: 5px; cursor: pointer; text-decoration: underline;" onclick="openEventAttendeesModal('${matchId}')"> ${goingCount} going</p>` : ''}
            </div>

            <button onclick="joinEventFromSwipe('${firstEvent.id}')" class="btn" style="width: 100%; margin-bottom: 10px; background: ${buttonColor}; color: ${textColor};">
                ${buttonText}
            </button>

            <button onclick="handleStayInterested()" class="btn btn-secondary" style="width: 100%; margin-bottom: 10px; background: #6c757d; color: white;">
                 Just Stay Interested
            </button>

            <button onclick="handlePlanEvent()" class="btn btn-secondary" style="width: 100%; background: #6c757d; color: white;">
                 Plan Another Event
            </button>

            <div style="margin-top: 15px; font-size: 12px; color: #999; text-align: center;">
                "Stay Interested" lets you watch for events without joining this one.
            </div>
        `;
    } else if (upcomingEventsWithUserStatus.length > 0 && upcomingEventsWithUserStatus.every(e => e.isUserJoined)) {
        // User has already joined all events
        modalContent.innerHTML = `
            <span class="close-modal-btn" onclick="closeSwipeActionModal()"></span>
            <div class="modal-header">${activityName || ' Activity'} Match!</div>

            <div style="margin-bottom: 20px; color: #666; line-height: 1.6; text-align: center;">
                <p>You've already joined the event(s) for this activity!</p>
            </div>

            <button onclick="handlePlanEvent()" class="btn" style="width: 100%; margin-bottom: 10px; background: #007bff;">
                 Plan Another Event
            </button>

            <button onclick="handleStayInterested()" class="btn btn-secondary" style="width: 100%; background: #6c757d; color: white;">
                 Stay Interested
            </button>
        `;
    } else {
        // No events exist - show default flow
        modalContent.innerHTML = `
            <span class="close-modal-btn" onclick="closeSwipeActionModal()"></span>
            <div class="modal-header">${activityName || ' Activity'} Match!</div>

            <div style="margin-bottom: 20px; color: #666; line-height: 1.6; text-align: center;">
                <p id="swipe-action-description">You matched! Would you like to plan an event or just stay interested for now?</p>
            </div>

            <button onclick="handlePlanEvent()" class="btn" style="width: 100%; margin-bottom: 10px; background: #007bff;">
                 Plan Event
            </button>

            <button onclick="handleStayInterested()" class="btn btn-secondary" style="width: 100%; background: #6c757d; color: white;">
                 Stay Interested
            </button>

            <div style="margin-top: 15px; font-size: 12px; color: #999; text-align: center;">
                "Stay Interested" lets you watch for events others create without planning one yourself.
            </div>
        `;
    }

    modal.style.display = 'flex';
}

async function joinEventFromSwipe(eventId) {
    // Join the event
    await joinEvent(eventId);

    // Close the swipe modal
    document.getElementById('swipe-action-modal').style.display = 'none';

    // Clear pending state
    pendingSwipeActivity = null;

    // Advance to next card
    setTimeout(() => {
        currentCardIndex++;
        showNextCard();
    }, 300);

    pendingSwipeMatchId = null;
}

async function closeSwipeActionModal() {
    document.getElementById('swipe-action-modal').style.display = 'none';

    // If user closed without choosing, assume they're interested
    // The activity is already saved in preferences from the swipe right action
    // Just advance to the next card
    if (pendingSwipeActivity) {
        setTimeout(() => {
            currentCardIndex++;
            showNextCard();
        }, 300);
    }

    pendingSwipeMatchId = null;
    pendingSwipeActivity = null;
}

async function handlePlanEvent() {
    if (!pendingSwipeMatchId) return;

    // Save matchId before closing modal
    const matchId = pendingSwipeMatchId;

    // Clear the pending activity so closeSwipeActionModal doesn't undo the swipe
    pendingSwipeActivity = null;

    // Add user to match_participants
    await joinMatchChat(matchId);

    // Close swipe modal
    closeSwipeActionModal();

    // Open planning event modal
    openPlanningEventModal(matchId);

    // Advance to next card after user made their choice
    setTimeout(() => {
        currentCardIndex++;
        showNextCard();
    }, 300);
}

async function handleStayInterested() {
    if (!pendingSwipeMatchId) return;

    // Clear the pending activity so closeSwipeActionModal doesn't undo the swipe
    pendingSwipeActivity = null;

    // Add user to match_participants (but don't create event)
    const success = await joinMatchChat(pendingSwipeMatchId);

    closeSwipeActionModal();

    if (success) {
        showNotification(' You\'re watching for events! You\'ll be notified when someone plans something.');
        await loadMatches();
    } else {
        showNotification('Error joining match', 'error');
    }

    // Advance to next card after user made their choice
    setTimeout(() => {
        currentCardIndex++;
        showNextCard();
    }, 300);
}

// Planning Event Creation Modal
function openPlanningEventModal(matchId) {
    const match = matches.find(m => m.id === matchId);
    if (!match) return;

    const activity = activities.find(a => a.id === match.activity_id);
    const activityName = activity ? `${activity.emoji} ${activity.name}` : 'Activity';

    document.getElementById('planning-event-title').textContent = `Plan: ${activityName}`;
    document.getElementById('planning-event-form').reset();
    document.getElementById('planning-event-match-id').value = matchId;
    document.getElementById('planning-event-activity-name').value = activity ? activity.name : '';

    document.getElementById('planning-event-modal').style.display = 'flex';
}

function closePlanningEventModal() {
    document.getElementById('planning-event-modal').style.display = 'none';

    // Reset the lock details hidden input
    document.getElementById('lock-details-now').value = 'false';

    // Reset and re-enable the submit button
    const submitBtn = document.getElementById('planning-submit-btn');
    submitBtn.textContent = 'Start Planning';
    submitBtn.disabled = false;

    // Reset poll creation checkbox and fields
    const createPollCheckbox = document.getElementById('create-poll-on-start');
    if (createPollCheckbox) {
        createPollCheckbox.checked = false;
        createPollCheckbox.disabled = false;
    }

    const createPollFields = document.getElementById('create-poll-fields');
    if (createPollFields) {
        createPollFields.style.display = 'none';
    }

    // Reset poll inputs
    const pollQuestion = document.getElementById('planning-poll-question');
    if (pollQuestion) pollQuestion.value = '';

    const pollOptionsContainer = document.getElementById('planning-poll-options-container');
    if (pollOptionsContainer) {
        pollOptionsContainer.innerHTML = `
            <div class="poll-option-input" style="display: flex; gap: 10px; margin-bottom: 10px;">
                <input type="text" class="planning-poll-option" placeholder="Option 1" style="flex: 1;">
            </div>
            <div class="poll-option-input" style="display: flex; gap: 10px; margin-bottom: 10px;">
                <input type="text" class="planning-poll-option" placeholder="Option 2" style="flex: 1;">
            </div>
        `;
    }

    // Reset auto-lock checkbox and fields
    const enableAutoLock = document.getElementById('enable-auto-lock');
    if (enableAutoLock) {
        enableAutoLock.checked = false;
    }

    const autoLockFields = document.getElementById('auto-lock-fields');
    if (autoLockFields) {
        autoLockFields.style.display = 'none';
    }

    const autoLockThreshold = document.getElementById('auto-lock-threshold');
    if (autoLockThreshold) {
        autoLockThreshold.value = '3';
    }
}

// Event Attendees Modal Functions
function openEventAttendeesModal(matchId) {
    const match = matches.find(m => m.id === matchId);
    if (!match) return;

    const activity = activities.find(a => a.id === match.activity_id);
    const activityName = activity ? `${activity.emoji} ${activity.name}` : 'Activity';

    // Update modal title
    document.getElementById('attendees-modal-title').textContent = ` ${activityName} - Going`;

    // Get users who have joined events (going users)
    const attendees = match.goingUsers || [];

    // Populate attendees list
    const attendeesList = document.getElementById('attendees-list');
    if (attendees.length === 0) {
        attendeesList.innerHTML = `
            <div style="text-align: center; padding: 20px; color: var(--text-secondary);">
                <p>No one is going yet</p>
                <p style="font-size: 12px; margin-top: 10px;">Be the first to join an event!</p>
            </div>
        `;
    } else {
        attendeesList.innerHTML = attendees.map(user => {
            const avatar = user.avatar || '';
            const name = user.name || 'Anonymous User';
            const isCurrentUser = user.id === currentUser.id;

            // Check if avatar is a URL or emoji
            const avatarHtml = avatar.startsWith('http')
                ? `<img src="${avatar}" alt="${name}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;">`
                : avatar;

            return `
                <div style="display: flex; align-items: center; padding: 12px; border-bottom: 1px solid var(--border-color); ${isCurrentUser ? 'background: rgba(91, 79, 199, 0.1);' : ''}">
                    <div style="width: 40px; height: 40px; border-radius: 50%; background: var(--bg-secondary); display: flex; align-items: center; justify-content: center; font-size: 20px; margin-right: 12px; overflow: hidden;">
                        ${avatarHtml}
                    </div>
                    <div style="flex: 1;">
                        <div style="font-weight: 500; font-size: 14px; color: var(--text-primary);">
                            ${name} ${isCurrentUser ? '(You)' : ''}
                        </div>
                    </div>
                </div>
            `;
        }).join('');
    }

    // Show modal
    document.getElementById('event-attendees-modal').style.display = 'flex';
}

function closeEventAttendeesModal() {
    document.getElementById('event-attendees-modal').style.display = 'none';
}

// Toggle collapsible sections
function toggleCollapsible(header) {
    const content = header.nextElementSibling;
    const isActive = header.classList.contains('active');

    // Toggle active state
    header.classList.toggle('active');
    content.classList.toggle('active');

    // Update hidden input to track whether section is open
    const section = header.closest('.collapsible-section');
    const hiddenInput = section.querySelector('input[type="hidden"]');
    if (hiddenInput) {
        hiddenInput.value = !isActive ? 'true' : 'false';
    }

    // Handle special logic when toggling lock details
    if (section.querySelector('#lock-details-now')) {
        const submitBtn = document.getElementById('planning-submit-btn');
        const locationInput = document.getElementById('planning-location');
        const dateInput = document.getElementById('planning-lock-date');
        const timeframeInput = document.getElementById('planning-timeframe');

        if (!isActive) { // Opening lock details section
            submitBtn.textContent = 'Create Event';
            locationInput.required = true;
            dateInput.required = true;
            timeframeInput.required = false;

            // Set min date to today
            const today = new Date().toISOString().slice(0, 10);
            dateInput.min = today;

            // Close plan with others section if open
            const planSection = document.querySelector('.collapsible-section #plan-with-others')?.closest('.collapsible-section');
            if (planSection) {
                const planHeader = planSection.querySelector('.collapsible-header');
                if (planHeader?.classList.contains('active')) {
                    toggleCollapsible(planHeader);
                }
            }

            // Close poll section if open
            const pollSection = document.querySelector('.collapsible-section #create-poll-on-start').closest('.collapsible-section');
            const pollHeader = pollSection.querySelector('.collapsible-header');
            if (pollHeader.classList.contains('active')) {
                toggleCollapsible(pollHeader);
            }
        } else { // Closing lock details section
            submitBtn.textContent = 'Start Planning';
            locationInput.required = false;
            dateInput.required = false;
            timeframeInput.required = true;
        }
    }

    // Handle special logic when toggling plan with others
    if (section.querySelector('#plan-with-others')) {
        const submitBtn = document.getElementById('planning-submit-btn');
        const timeframeInput = document.getElementById('planning-timeframe');

        if (!isActive) { // Opening plan with others section
            submitBtn.textContent = 'Start Planning';
            timeframeInput.required = true;

            // Close lock details section if open
            const lockSection = document.querySelector('.collapsible-section #lock-details-now')?.closest('.collapsible-section');
            if (lockSection) {
                const lockHeader = lockSection.querySelector('.collapsible-header');
                if (lockHeader?.classList.contains('active')) {
                    toggleCollapsible(lockHeader);
                }
            }

            // Close poll section if open
            const pollSection = document.querySelector('.collapsible-section #create-poll-on-start')?.closest('.collapsible-section');
            if (pollSection) {
                const pollHeader = pollSection.querySelector('.collapsible-header');
                if (pollHeader?.classList.contains('active')) {
                    toggleCollapsible(pollHeader);
                }
            }
        } else { // Closing plan with others section
            timeframeInput.required = false;
        }
    }

    // Handle special logic when toggling poll creation
    if (section.querySelector('#create-poll-on-start')) {
        if (!isActive) { // Opening poll section
            // Close lock details section if open
            const lockSection = document.querySelector('.collapsible-section #lock-details-now').closest('.collapsible-section');
            const lockHeader = lockSection.querySelector('.collapsible-header');
            if (lockHeader.classList.contains('active')) {
                toggleCollapsible(lockHeader);
            }

            // Close plan with others section if open
            const planSection = document.querySelector('.collapsible-section #plan-with-others')?.closest('.collapsible-section');
            if (planSection) {
                const planHeader = planSection.querySelector('.collapsible-header');
                if (planHeader?.classList.contains('active')) {
                    toggleCollapsible(planHeader);
                }
            }
        }
    }
}

function toggleLockDetailsFields() {
    // This function is kept for backward compatibility but now handled by toggleCollapsible
    const checkbox = document.getElementById('lock-details-now');
    if (!checkbox) return;

    // Find the collapsible section and toggle it
    const section = checkbox.closest('.collapsible-section');
    if (section) {
        const header = section.querySelector('.collapsible-header');
        if (header && checkbox.value === 'true' && !header.classList.contains('active')) {
            toggleCollapsible(header);
        } else if (header && checkbox.value === 'false' && header.classList.contains('active')) {
            toggleCollapsible(header);
        }
    }
}

function toggleCreatePollFields() {
    // This function is kept for backward compatibility but now handled by toggleCollapsible
    const checkbox = document.getElementById('create-poll-on-start');
    if (!checkbox) return;

    // Find the collapsible section and toggle it
    const section = checkbox.closest('.collapsible-section');
    if (section) {
        const header = section.querySelector('.collapsible-header');
        if (header && checkbox.value === 'true' && !header.classList.contains('active')) {
            toggleCollapsible(header);
        } else if (header && checkbox.value === 'false' && header.classList.contains('active')) {
            toggleCollapsible(header);
        }
    }
}

function toggleAutoLockFields() {
    const checkbox = document.getElementById('enable-auto-lock');
    const fieldsDiv = document.getElementById('auto-lock-fields');

    if (checkbox && checkbox.checked) {
        fieldsDiv.style.display = 'block';
    } else {
        fieldsDiv.style.display = 'none';
    }
}

function addPlanningPollOption() {
    const container = document.getElementById('planning-poll-options-container');
    const optionCount = container.querySelectorAll('.poll-option-input').length + 1;

    if (optionCount > 10) {
        showNotification('Maximum 10 options allowed', 'error');
        return;
    }

    const optionDiv = document.createElement('div');
    optionDiv.className = 'poll-option-input';
    optionDiv.style.cssText = 'display: flex; gap: 10px; margin-bottom: 10px;';
    optionDiv.innerHTML = `
        <input type="text" class="planning-poll-option" placeholder="Option ${optionCount}" style="flex: 1;">
        <button type="button" onclick="this.parentElement.remove()" class="btn btn-secondary" style="padding: 8px 12px; width: auto; min-width: 40px; flex-shrink: 0;"></button>
    `;

    container.appendChild(optionDiv);
}

function handlePlanningPollTemplateChange() {
    const template = document.getElementById('planning-poll-question-template').value;
    const questionInput = document.getElementById('planning-poll-question');
    const container = document.getElementById('planning-poll-options-container');

    if (!template) {
        // User selected "Select a template..." - clear everything
        questionInput.value = '';
        container.innerHTML = `
            <div class="poll-option-input" style="display: flex; gap: 10px; margin-bottom: 10px;">
                <input type="text" class="planning-poll-option" placeholder="Option 1" style="flex: 1;">
            </div>
            <div class="poll-option-input" style="display: flex; gap: 10px; margin-bottom: 10px;">
                <input type="text" class="planning-poll-option" placeholder="Option 2" style="flex: 1;">
            </div>
        `;
        return;
    }

    const templateData = getPollTemplateData(template);
    if (templateData) {
        // Populate question
        questionInput.value = templateData.question;

        // Clear and populate options
        container.innerHTML = '';
        templateData.options.forEach((option, index) => {
            const optionDiv = document.createElement('div');
            optionDiv.className = 'poll-option-input';
            optionDiv.style.cssText = 'display: flex; gap: 10px; margin-bottom: 10px;';
            optionDiv.innerHTML = `
                <input type="text" class="planning-poll-option" placeholder="Option ${index + 1}" value="${option}" style="flex: 1;">
                <button type="button" onclick="this.parentElement.remove()" class="btn btn-secondary" style="padding: 8px 12px; width: auto; min-width: 40px; flex-shrink: 0;"></button>
            `;
            container.appendChild(optionDiv);
        });
    }
}

function openGoogleMapsSearch() {
    const locationInput = document.getElementById('planning-location');
    const activityNameInput = document.getElementById('planning-event-activity-name');
    const searchQuery = locationInput.value.trim();
    const activityName = activityNameInput ? activityNameInput.value.trim() : '';

    // If there's a location entered, search for it. Otherwise, search for the activity name
    const query = searchQuery || activityName || '';
    const mapsUrl = query
        ? `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(query)}`
        : 'https://www.google.com/maps';

    // Open in a new tab
    window.open(mapsUrl, '_blank');
}

function openGoogleMapsSearchPlan() {
    const locationInput = document.getElementById('planning-plan-location');
    const activityNameInput = document.getElementById('planning-event-activity-name');
    const searchQuery = locationInput.value.trim();
    const activityName = activityNameInput ? activityNameInput.value.trim() : '';

    // If there's a location entered, search for it. Otherwise, search for the activity name
    const query = searchQuery || activityName || '';
    const mapsUrl = query
        ? `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(query)}`
        : 'https://www.google.com/maps';

    // Open in a new tab
    window.open(mapsUrl, '_blank');
}

// Lock in Details Modal
function openLockDetailsModal() {
    if (!currentEvent) {
        console.error('No current event context');
        return;
    }

    // Pre-fill with existing data if available
    document.getElementById('lock-date').value = currentEvent.scheduled_date || '';
    document.getElementById('lock-time').value = currentEvent.scheduled_time || '';
    document.getElementById('lock-location').value = currentEvent.location || '';
    document.getElementById('lock-notes').value = currentEvent.notes || '';
    document.getElementById('lock-max-participants').value = currentEvent.max_participants || '';

    document.getElementById('lock-details-modal').style.display = 'flex';
}

function closeLockDetailsModal() {
    document.getElementById('lock-details-modal').style.display = 'none';
}

// Create Poll Modal
function openCreatePollModal() {
    console.log(' openCreatePollModal called!');
    if (!currentEvent) {
        console.error(' No current event context for poll');
        return;
    }
    console.log(' Opening poll modal for event:', currentEvent.id);

    // Reset form
    document.getElementById('create-poll-form').reset();

    // Reset to 2 default options
    const container = document.getElementById('poll-options-container');
    container.innerHTML = `
        <div class="poll-option-input" style="display: flex; gap: 10px; margin-bottom: 10px;">
            <input type="text" class="poll-option" placeholder="Option 1" required style="flex: 1;">
        </div>
        <div class="poll-option-input" style="display: flex; gap: 10px; margin-bottom: 10px;">
            <input type="text" class="poll-option" placeholder="Option 2" required style="flex: 1;">
        </div>
    `;

    document.getElementById('create-poll-modal').style.display = 'flex';
}

function closeCreatePollModal() {
    document.getElementById('create-poll-modal').style.display = 'none';

    // Reset agreement notification checkbox and threshold
    const autoLockCheckbox = document.getElementById('chat-poll-enable-auto-lock');
    const autoLockThreshold = document.getElementById('chat-poll-auto-lock-threshold');
    const thresholdInput = document.getElementById('chat-poll-threshold-input');

    if (autoLockCheckbox) autoLockCheckbox.checked = false;
    if (autoLockThreshold) autoLockThreshold.style.display = 'none';
    if (thresholdInput) thresholdInput.value = '2';
}

function addPollOption() {
    const container = document.getElementById('poll-options-container');
    const optionCount = container.querySelectorAll('.poll-option-input').length + 1;

    if (optionCount > 10) {
        showNotification('Maximum 10 options allowed', 'error');
        return;
    }

    const optionDiv = document.createElement('div');
    optionDiv.className = 'poll-option-input';
    optionDiv.style.cssText = 'display: flex; gap: 10px; margin-bottom: 10px;';
    optionDiv.innerHTML = `
        <input type="text" class="poll-option" placeholder="Option ${optionCount}" required style="flex: 1;">
        <button type="button" onclick="this.parentElement.remove()" class="btn btn-secondary" style="padding: 8px 12px; width: auto; min-width: 40px; flex-shrink: 0;"></button>
    `;

    container.appendChild(optionDiv);
}

function getPollTemplateData(templateType) {
    const templates = {
        when: {
            question: "When should we meet?",
            options: ["Today", "Tomorrow", "This Weekend", "Next Week", "Next Month"]
        },
        where: {
            question: "Where should we meet?",
            options: ["My Place", "Restaurant", "Park", "Coffee Shop", "Online/Virtual", "Other"]
        },
        who: {
            question: "Who should come?",
            options: ["Small Group (3-5)", "Medium Group (6-10)", "Large Group (10+)", "Open to All"]
        }
    };

    return templates[templateType] || null;
}

function handlePollTemplateChange() {
    const template = document.getElementById('poll-question-template').value;
    const questionInput = document.getElementById('poll-question');
    const container = document.getElementById('poll-options-container');

    if (!template) {
        // User selected "Select a template..." - clear everything
        questionInput.value = '';
        container.innerHTML = `
            <div class="poll-option-input" style="display: flex; gap: 10px; margin-bottom: 10px;">
                <input type="text" class="poll-option" placeholder="Option 1" required style="flex: 1;">
            </div>
            <div class="poll-option-input" style="display: flex; gap: 10px; margin-bottom: 10px;">
                <input type="text" class="poll-option" placeholder="Option 2" required style="flex: 1;">
            </div>
        `;
        return;
    }

    const templateData = getPollTemplateData(template);
    if (templateData) {
        // Populate question
        questionInput.value = templateData.question;

        // Clear and populate options
        container.innerHTML = '';
        templateData.options.forEach((option, index) => {
            const optionDiv = document.createElement('div');
            optionDiv.className = 'poll-option-input';
            optionDiv.style.cssText = 'display: flex; gap: 10px; margin-bottom: 10px;';
            optionDiv.innerHTML = `
                <input type="text" class="poll-option" placeholder="Option ${index + 1}" value="${option}" required style="flex: 1;">
                <button type="button" onclick="this.parentElement.remove()" class="btn btn-secondary" style="padding: 8px 12px; width: auto; min-width: 40px; flex-shrink: 0;"></button>
            `;
            container.appendChild(optionDiv);
        });
    }
}

function toggleChatPollAutoLock() {
    const checkbox = document.getElementById('chat-poll-enable-auto-lock');
    const thresholdDiv = document.getElementById('chat-poll-auto-lock-threshold');

    if (checkbox.checked) {
        thresholdDiv.style.display = 'block';
    } else {
        thresholdDiv.style.display = 'none';
    }
}

// ========== END NEW MODALS ==========

// ========== PLANNING EVENT FUNCTIONS ==========

// Create event in planning mode (or scheduled if details locked in)
async function createPlanningEvent(e) {
    e.preventDefault();

    const lockDetailsNow = document.getElementById('lock-details-now').value === 'true';
    console.log(` CREATE EVENT: Starting... (${lockDetailsNow ? 'SCHEDULED' : 'PLANNING'} mode)`);

    const submitBtn = e.target.querySelector('button[type="submit"]');
    const originalBtnText = submitBtn.innerHTML;

    submitBtn.disabled = true;
    submitBtn.innerHTML = `<span class="btn-spinner"></span>${lockDetailsNow ? 'Creating...' : 'Starting...'}`;

    const matchId = document.getElementById('planning-event-match-id').value;
    const match = matches.find(m => m.id === matchId);

    try {
        // Get location from the appropriate field based on mode
        const location = lockDetailsNow
            ? document.getElementById('planning-location').value || null
            : document.getElementById('planning-plan-location').value || null;

        // Prepare event data based on mode
        const eventData = {
            match_id: matchId,
            activity_id: match.activity_id,
            circle_id: match.circle_id,
            location: location,
            notes: document.getElementById('planning-notes').value || null,
            proposed_timeframe: document.getElementById('planning-timeframe').value,
            created_by: currentUser.id
        };

        if (lockDetailsNow) {
            // Scheduled mode - lock in details immediately
            eventData.status = 'scheduled';
            eventData.scheduled_date = document.getElementById('planning-lock-date').value;
            eventData.scheduled_time = document.getElementById('planning-lock-time').value || null;
            const maxParticipantsInput = document.getElementById('planning-lock-max-participants').value;
            eventData.max_participants = maxParticipantsInput ? parseInt(maxParticipantsInput, 10) : null;
        } else {
            // Planning mode
            eventData.status = 'planning';
            eventData.scheduled_date = null;
            eventData.scheduled_time = null;
        }

        const { data: newEvent, error: eventError } = await supabase
            .from('events')
            .insert(eventData)
            .select()
            .single();

        if (eventError) throw eventError;

        console.log(` Event created (${newEvent.status}):`, newEvent);

        // Add creator as first participant
        const { error: participantError } = await supabase
            .from('event_participants')
            .insert({
                event_id: newEvent.id,
                profile_id: currentUser.id,
                status: 'accepted'
            });

        if (participantError) throw participantError;

        // Update creator's last interaction timestamp in match_participants
        await supabase
            .from('match_participants')
            .update({ last_interaction_at: new Date().toISOString() })
            .eq('match_id', matchId)
            .eq('profile_id', currentUser.id);

        // Send notifications to other match participants
        sendEventCreatedNotification(matchId, newEvent).catch(err => {
            console.error('Error sending notification:', err);
        });

        // IMPORTANT: Capture poll form values BEFORE closing modal (which resets the form)
        const createPollChecked = document.getElementById('create-poll-on-start')?.value === 'true';
        const pollQuestion = createPollChecked ? document.getElementById('planning-poll-question')?.value.trim() : null;
        const pollOptionInputs = createPollChecked ? document.querySelectorAll('.planning-poll-option') : [];
        const pollOptions = Array.from(pollOptionInputs)
            .map(input => input.value.trim())
            .filter(val => val.length > 0);
        const enableAutoLock = createPollChecked ? document.getElementById('enable-auto-lock')?.checked : false;
        const autoLockThreshold = enableAutoLock ?
            parseInt(document.getElementById('auto-lock-threshold')?.value || '3') : null;

        // Close modal (this resets the form, so we captured poll values above)
        closePlanningEventModal();

        // Create poll if requested (only in planning mode) - BEFORE opening chat
        let createdPoll = null;
        if (!lockDetailsNow && createPollChecked) {
            if (pollQuestion && pollOptions.length >= 2) {
                try {
                    // Check if auto-lock is enabled (already captured above)

                    // Store auto-lock metadata with the poll options
                    const pollData = {
                        options: pollOptions,
                        autoLockEnabled: enableAutoLock || false,
                        autoLockThreshold: autoLockThreshold
                    };

                    // Create poll in database
                    const { data: newPoll, error: pollError } = await supabase
                        .from('polls')
                        .insert({
                            event_id: newEvent.id,
                            question: pollQuestion,
                            options: JSON.stringify(pollData),
                            created_by: currentUser.id
                        })
                        .select()
                        .single();

                    if (pollError) throw pollError;

                    console.log(' Poll created with event:', newPoll);

                    // Create a message of type 'poll' in event_messages
                    const { data: pollMessage, error: messageError } = await supabase
                        .from('event_messages')
                        .insert({
                            event_id: newEvent.id,
                            sender_id: currentUser.id,
                            content: pollQuestion,
                            message_type: 'poll',
                            poll_id: newPoll.id
                        })
                        .select()
                        .single();

                    if (messageError) throw messageError;

                    createdPoll = { poll: newPoll, message: pollMessage };

                    console.log(' Poll message created, ready to be displayed when chat opens');

                } catch (pollCreationError) {
                    console.error('Error creating poll with event:', pollCreationError);
                    showNotification('Event created, but poll creation failed', 'warning');
                }
            }
        }

        // Post appropriate system message
        const activity = activities.find(a => a.id === match.activity_id);
        const activityName = activity ? `${activity.emoji} ${activity.name}` : 'Activity';
        const locationText = newEvent.location ? `\n ${lockDetailsNow ? 'Location' : 'Suggested'}: ${newEvent.location}` : '';

        let systemMessage;
        if (lockDetailsNow) {
            // Event is scheduled - format date and time
            let dateTimeStr = '';
            if (newEvent.scheduled_date) {
                const eventDate = new Date(newEvent.scheduled_date);
                dateTimeStr = eventDate.toLocaleDateString('en-US', {
                    weekday: 'short',
                    month: 'short',
                    day: 'numeric'
                });

                if (newEvent.scheduled_time) {
                    const [hours, minutes] = newEvent.scheduled_time.split(':');
                    const hour = parseInt(hours);
                    const ampm = hour >= 12 ? 'PM' : 'AM';
                    const displayHour = hour === 0 ? 12 : (hour > 12 ? hour - 12 : hour);
                    dateTimeStr += `, ${displayHour}:${minutes} ${ampm}`;
                }
            }
            systemMessage = ` ${currentUser.name} created ${activityName}\n ${dateTimeStr}${locationText}\n\nEvent is locked in!`;
        } else {
            // Event is in planning mode
            const pollNote = createdPoll ? '\n\n Vote on the poll above to help decide!' : '';
            systemMessage = ` ${currentUser.name} started planning ${activityName}\n Thinking: ${newEvent.proposed_timeframe}${locationText}\n\nChat below to finalize details!${pollNote}`;
        }

        await sendSystemMessage(newEvent.id, systemMessage);

        // Open event chat AFTER poll and system message are created
        await openEventChat(newEvent.id);

    } catch (error) {
        console.error('Error creating event:', error);
        showNotification('Error creating event', 'error');
        submitBtn.disabled = false;
        submitBtn.innerHTML = originalBtnText;
    }
}

// Lock in event details (transition from planning to scheduled)
async function lockEventDetails(e) {
    e.preventDefault();
    console.log(' LOCK DETAILS: Starting...');

    if (!currentEvent) {
        showNotification('No event context', 'error');
        return;
    }

    const submitBtn = e.target.querySelector('button[type="submit"]');
    const originalBtnText = submitBtn.innerHTML;

    submitBtn.disabled = true;
    submitBtn.innerHTML = '<span class="btn-spinner"></span>Locking...';

    try {
        const maxParticipantsInput = document.getElementById('lock-max-participants').value;
        const maxParticipants = maxParticipantsInput ? parseInt(maxParticipantsInput, 10) : null;

        // Update event to scheduled status
        const { data, error: updateError } = await supabase
            .from('events')
            .update({
                status: 'scheduled',
                scheduled_date: document.getElementById('lock-date').value,
                scheduled_time: document.getElementById('lock-time').value || null,
                location: document.getElementById('lock-location').value,
                notes: document.getElementById('lock-notes').value || null,
                max_participants: maxParticipants,
                proposed_timeframe: null // Clear planning timeframe
            })
            .eq('id', currentEvent.id)
            .select();

        if (updateError) throw updateError;

        // Check if the update actually succeeded (RLS may block non-creators)
        if (!data || data.length === 0) {
            throw new Error('Only the event creator can lock in event details');
        }

        console.log(' Event locked to scheduled');

        // Close modal
        closeLockDetailsModal();

        // Reload event chat to show updated UI
        await openEventChat(currentEvent.id);

        // Post system message
        const dateValue = document.getElementById('lock-date').value;
        const dateStr = formatEventDate(new Date(dateValue));
        const locationStr = document.getElementById('lock-location').value;

        const systemMessage = ` Event scheduled:\n ${dateStr}\n ${locationStr}`;
        await sendSystemMessage(currentEvent.id, systemMessage);

        showNotification('Event details locked in!');

    } catch (error) {
        console.error('Error locking details:', error);
        showNotification('Error updating event', 'error');
        submitBtn.disabled = false;
        submitBtn.innerHTML = originalBtnText;
    }
}

// ========== END PLANNING EVENT FUNCTIONS ==========

// ========== POLLING FUNCTIONS ==========

// Submit a new poll
async function submitPoll(e) {
    console.log(' submitPoll called!');
    e.preventDefault();

    if (!currentEvent) {
        console.error(' No event context!');
        showNotification('No event context', 'error');
        return;
    }
    console.log(' Event context exists:', currentEvent.id);

    const submitBtn = e.target.querySelector('button[type="submit"]');
    const originalBtnText = submitBtn.innerHTML;

    submitBtn.disabled = true;
    submitBtn.innerHTML = '<span class="btn-spinner"></span>Sending...';

    try {
        const question = document.getElementById('poll-question').value;
        const optionInputs = document.querySelectorAll('.poll-option');
        const options = Array.from(optionInputs)
            .map(input => input.value.trim())
            .filter(val => val.length > 0);

        // Get agreement notification settings
        const enableAutoLock = document.getElementById('chat-poll-enable-auto-lock')?.checked || false;
        const autoLockThreshold = enableAutoLock ? parseInt(document.getElementById('chat-poll-threshold-input')?.value || '2', 10) : null;

        console.log(' Poll data:', { question, optionsCount: options.length, options, enableAutoLock, autoLockThreshold });

        if (options.length < 2) {
            showNotification('Please add at least 2 options', 'error');
            submitBtn.disabled = false;
            submitBtn.innerHTML = originalBtnText;
            return;
        }

        // Store poll data with metadata (same format as planning modal polls)
        const pollData = {
            options: options,
            autoLockEnabled: enableAutoLock,
            autoLockThreshold: autoLockThreshold
        };

        // Create poll in database
        const { data: newPoll, error: pollError } = await supabase
            .from('polls')
            .insert({
                event_id: currentEvent.id,
                question: question,
                options: JSON.stringify(pollData),
                created_by: currentUser.id
            })
            .select()
            .single();

        if (pollError) throw pollError;

        console.log(' Poll created:', newPoll);

        // Create a message of type 'poll' in event_messages
        const { data: pollMessage, error: messageError } = await supabase
            .from('event_messages')
            .insert({
                event_id: currentEvent.id,
                sender_id: currentUser.id,
                content: question, // Store question as content
                message_type: 'poll',
                poll_id: newPoll.id
            })
            .select()
            .single();

        if (messageError) throw messageError;

        // Render the poll immediately (before broadcasting to prevent race condition)
        await renderPollMessage(pollMessage, newPoll);

        // Broadcast new poll message
        const channel = supabase.channel(`event_${currentEvent.id}`);
        await channel.send({
            type: 'broadcast',
            event: 'new_message',
            payload: {
                id: pollMessage.id,
                sender_id: currentUser.id,
                sender_name: currentUser.name,
                sender_avatar: currentUser.avatar,
                content: question,
                message_type: 'poll',
                poll_id: newPoll.id,
                created_at: pollMessage.created_at
            }
        });

        // Close modal and reset form
        closeCreatePollModal();
        showNotification('Poll created!');

    } catch (error) {
        console.error('Error creating poll:', error);
        showNotification('Error creating poll', 'error');
        submitBtn.disabled = false;
        submitBtn.innerHTML = originalBtnText;
    }
}

// Render a poll message in the chat
async function renderPollMessage(message, poll) {
    console.log(' renderPollMessage called:', { messageId: message.id, pollId: poll.id, question: poll.question });
    const messagesContainer = document.getElementById('chat-messages');
    if (!messagesContainer) {
        console.error(' No messages container found!');
        return;
    }

    // Check if this message already exists (prevent duplicates) - check by both message ID and poll ID
    const existingMessageById = document.querySelector(`[data-message-id="${message.id}"]`);
    const existingPollById = document.querySelector(`[data-poll-id="${poll.id}"]`);

    if (existingMessageById || existingPollById) {
        console.log(' Poll message already exists, skipping duplicate render:', {
            messageExists: !!existingMessageById,
            pollExists: !!existingPollById
        });
        return;
    }

    // Parse options - handle both old format (array) and new format (object with metadata)
    let pollData = typeof poll.options === 'string' ? JSON.parse(poll.options) : poll.options;
    let options, autoLockEnabled, autoLockThreshold;

    if (Array.isArray(pollData)) {
        // Old format: just an array of option strings
        options = pollData;
        autoLockEnabled = false;
        autoLockThreshold = null;
    } else {
        // New format: object with options and metadata
        options = pollData.options || [];
        autoLockEnabled = pollData.autoLockEnabled || false;
        autoLockThreshold = pollData.autoLockThreshold || null;
    }

    // Get vote counts
    const { data: votes } = await supabase
        .from('poll_votes')
        .select('option_index, voter_id')
        .eq('poll_id', poll.id);

    const voteCounts = {};
    options.forEach((_, index) => { voteCounts[index] = 0; });
    votes?.forEach(vote => {
        voteCounts[vote.option_index] = (voteCounts[vote.option_index] || 0) + 1;
    });

    const userVote = votes?.find(v => v.voter_id === currentUser.id);
    const totalVotes = votes?.length || 0;

    // Create poll message element
    const pollDiv = document.createElement('div');
    pollDiv.className = 'message';
    pollDiv.setAttribute('data-message-id', message.id);
    pollDiv.setAttribute('data-poll-id', poll.id);
    // Make poll full width
    pollDiv.style.cssText = 'width: 100%; margin-bottom: 15px;';

    const sender = message.sender_id === currentUser.id ? currentUser : (message.sender || { name: 'User', avatar: '' });

    pollDiv.innerHTML = `
        <div class="poll-container" style="padding: 15px; border-radius: 10px; border-left: 4px solid #007bff; width: 100%;">
            <div style="display: flex; align-items: center; margin-bottom: 10px;">
                ${renderAvatar(sender.avatar, 32)}
                <div style="margin-left: 10px;">
                    <div class="poll-sender-name" style="font-weight: 600;">${escapeHtml(sender.name)}</div>
                    <div class="poll-sender-label" style="font-size: 12px;"> asked:</div>
                </div>
            </div>
            <div class="poll-question" style="font-weight: 500; margin-bottom: 15px;">
                ${escapeHtml(poll.question)}
            </div>
            <div class="poll-options" style="display: flex; flex-direction: column; gap: 8px;">
                ${options.map((option, index) => {
                    const voteCount = voteCounts[index] || 0;
                    const isSelected = userVote?.option_index === index;
                    return `
                        <button
                            class="poll-option-btn ${isSelected ? 'selected' : ''}"
                            onclick="voteOnPoll('${poll.id}', ${index})"
                            style="
                                padding: 10px 15px;
                                border-radius: 8px;
                                text-align: left;
                                cursor: pointer;
                                font-size: 14px;
                                transition: all 0.2s;
                                display: flex;
                                justify-content: space-between;
                                align-items: center;
                            "
                        >
                            <span>${isSelected ? ' ' : ''}${escapeHtml(option)}</span>
                            <span style="font-weight: 600;">${voteCount} vote${voteCount !== 1 ? 's' : ''}</span>
                        </button>
                    `;
                }).join('')}
            </div>
            <div class="poll-vote-count" style="margin-top: 10px; font-size: 12px;">
                ${totalVotes} ${totalVotes === 1 ? 'person' : 'people'} voted
            </div>
            ${autoLockEnabled ? `
                <div class="consensus-notification-badge" style="margin-top: 8px; padding: 8px; border-radius: 5px; font-size: 12px;">
                     Notifications enabled: Everyone will be notified when ${autoLockThreshold} ${autoLockThreshold === 1 ? 'person agrees' : 'people agree'} on the same option
                </div>
            ` : ''}
            <div class="poll-timestamp" style="margin-top: 8px; font-size: 11px;">
                ${formatTime(message.created_at)}
            </div>
        </div>
    `;

    messagesContainer.appendChild(pollDiv);
    forceScrollToBottom();
}

// Vote on a poll
window.voteOnPoll = async function(pollId, optionIndex) {
    try {
        // Upsert vote (update if exists, insert if new)
        const { error } = await supabase
            .from('poll_votes')
            .upsert({
                poll_id: pollId,
                voter_id: currentUser.id,
                option_index: optionIndex
            }, {
                onConflict: 'poll_id,voter_id'
            });

        if (error) throw error;

        // Check for auto-lock threshold
        await checkAutoLockThreshold(pollId);

        // Refresh poll display
        await refreshPollDisplay(pollId);

        // Broadcast vote change
        if (currentEvent) {
            const channel = supabase.channel(`event_${currentEvent.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'poll_updated',
                payload: { pollId }
            });
        }

    } catch (error) {
        console.error('Error voting on poll:', error);
        showNotification('Error submitting vote', 'error');
    }
}

// Check if consensus notification threshold has been reached for a poll
async function checkAutoLockThreshold(pollId) {
    try {
        // Get poll data
        const { data: poll, error: pollError } = await supabase
            .from('polls')
            .select('*')
            .eq('id', pollId)
            .single();

        if (pollError || !poll) return;

        // Parse poll options to check for notification metadata
        let pollData;
        try {
            pollData = typeof poll.options === 'string' ? JSON.parse(poll.options) : poll.options;
        } catch (e) {
            // Old format poll without metadata
            return;
        }

        // Check if consensus notifications are enabled
        if (!pollData.autoLockEnabled || !pollData.autoLockThreshold) {
            return;
        }

        const threshold = pollData.autoLockThreshold;
        const options = pollData.options;

        // Get all votes for this poll
        const { data: votes, error: votesError } = await supabase
            .from('poll_votes')
            .select('option_index, voter_id')
            .eq('poll_id', pollId);

        if (votesError || !votes) return;

        // Count votes for each option
        const voteCounts = {};
        votes.forEach(vote => {
            voteCounts[vote.option_index] = (voteCounts[vote.option_index] || 0) + 1;
        });

        // Check if any option has reached the threshold
        let winningOptionIndex = null;
        let maxVotes = 0;
        for (const [index, count] of Object.entries(voteCounts)) {
            if (count >= threshold && count > maxVotes) {
                winningOptionIndex = parseInt(index);
                maxVotes = count;
            }
        }

        // If threshold reached, send notifications to all participants
        if (winningOptionIndex !== null) {
            const winningOption = options[winningOptionIndex];
            const eventId = poll.event_id;

            // Check if we've already sent the notification for this poll
            if (pollData.thresholdNotificationSent) {
                console.log('Threshold notification already sent for this poll, skipping duplicate');
                return;
            }

            // Get current event
            const { data: event } = await supabase
                .from('events')
                .select('*')
                .eq('id', eventId)
                .single();

            // Only notify if event is still in planning mode
            if (event && event.status === 'planning') {
                console.log(` Consensus notification triggered! Popular option: "${winningOption}" with ${maxVotes} votes`);

                // Post system message about consensus - but don't modify the event itself
                const systemMessage = ` ${maxVotes} ${maxVotes === 1 ? 'person' : 'people'} agreed on: "${winningOption}"\n\nConsider using "Lock in Details" to finalize the event with this option!`;
                await sendSystemMessage(eventId, systemMessage);

                // Show notification to current user
                showNotification(` ${maxVotes} people agreed on "${winningOption}"!`, 'success');

                // Get all event participants to send push notifications
                const { data: participants } = await supabase
                    .from('event_participants')
                    .select('profile_id')
                    .eq('event_id', eventId);

                // Filter out current user (they already got the in-app notification)
                const recipientIds = (participants || [])
                    .map(p => p.profile_id)
                    .filter(id => id !== currentUser.id);

                // Send push notifications via edge function
                if (recipientIds.length > 0) {
                    try {
                        const { data, error } = await supabase.functions.invoke('send-notification', {
                            body: {
                                senderId: currentUser.id,
                                recipientIds: recipientIds,
                                message: ` ${maxVotes} ${maxVotes === 1 ? 'person' : 'people'} agreed on: "${winningOption}"`,
                                activityName: event.activity_name || 'Event',
                                chatType: 'event',
                                chatId: eventId,
                                notificationType: 'poll_agreement'
                            }
                        });

                        if (error) {
                            console.error('Error sending poll agreement notifications:', error);
                        } else {
                            console.log('Poll agreement notifications sent:', data);
                        }
                    } catch (notifError) {
                        console.error('Failed to send poll agreement notifications:', notifError);
                    }
                }

                // Mark that we've sent the threshold notification
                pollData.thresholdNotificationSent = true;
                const { error: updateError } = await supabase
                    .from('polls')
                    .update({ options: pollData })
                    .eq('id', pollId);

                if (updateError) {
                    console.error('Error updating poll notification flag:', updateError);
                }

                // Broadcast notification to all participants
                const channel = supabase.channel(`event_${eventId}`);
                await channel.send({
                    type: 'broadcast',
                    event: 'consensus_reached',
                    payload: {
                        eventId,
                        winningOption,
                        voteCount: maxVotes
                    }
                });
            }
        }

    } catch (error) {
        console.error('Error checking consensus threshold:', error);
        // Don't show error to user - consensus notification is a background feature
    }
}

// Refresh a single poll's display
async function refreshPollDisplay(pollId) {
    // Find ALL poll elements with this poll_id (in case of duplicates)
    const pollElements = document.querySelectorAll(`[data-poll-id="${pollId}"]`);
    if (pollElements.length === 0) return;

    // Fetch updated poll data
    const { data: poll } = await supabase
        .from('polls')
        .select('*')
        .eq('id', pollId)
        .single();

    const { data: pollMessage } = await supabase
        .from('event_messages')
        .select('*, sender:profiles(id, name, avatar)')
        .eq('poll_id', pollId)
        .single();

    if (!poll || !pollMessage) return;

    // Remove ALL old elements (fixes duplication issue)
    pollElements.forEach(element => element.remove());

    // Re-render with updated data (only once)
    await renderPollMessage(pollMessage, poll);
}

// Send system message (for planning started, event locked, etc.)
async function sendSystemMessage(eventId, content) {
    try {
        const { data: systemMessage, error } = await supabase
            .from('event_messages')
            .insert({
                event_id: eventId,
                sender_id: currentUser.id,
                content: content,
                message_type: 'system'
            })
            .select()
            .single();

        if (error) throw error;

        // Broadcast system message
        const channel = supabase.channel(`event_${eventId}`);
        await channel.send({
            type: 'broadcast',
            event: 'new_message',
            payload: {
                id: systemMessage.id,
                sender_id: currentUser.id,
                content: content,
                message_type: 'system',
                created_at: systemMessage.created_at
            }
        });

    } catch (error) {
        console.error('Error sending system message:', error);
    }
}

// ========== END POLLING FUNCTIONS ==========


// Create new event
async function createEvent(e) {
    e.preventDefault();
    console.log(' CREATE EVENT: Starting...');

    const submitBtn = e.target.querySelector('button[type="submit"]');
    const originalBtnText = submitBtn.innerHTML;

    // Disable button and show loading spinner
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<span class="btn-spinner"></span>Creating...';

    const matchId = document.getElementById('new-event-match-id').value;
    const match = matches.find(m => m.id === matchId);

    console.log(' CREATE EVENT: Match ID:', matchId);
    console.log(' CREATE EVENT: Match found:', match);

    try {
        // Create the event
        console.log(' CREATE EVENT: Inserting event into database...');
        const maxParticipantsInput = document.getElementById('new-event-max-participants').value;
        const maxParticipants = maxParticipantsInput ? parseInt(maxParticipantsInput, 10) : null;

        const { data: newEvent, error: eventError } = await supabase
            .from('events')
            .insert({
                match_id: matchId,
                activity_id: match.activity_id,
                circle_id: match.circle_id,
                scheduled_date: document.getElementById('new-event-date').value,
                scheduled_time: document.getElementById('new-event-time').value || null,
                location: document.getElementById('new-event-location').value || null,
                notes: document.getElementById('new-event-notes').value || null,
                max_participants: maxParticipants,
                created_by: currentUser.id,
                status: 'scheduled'
            })
            .select('*')
            .single();

        console.log(' CREATE EVENT: Insert result:', { newEvent, eventError });

        if (eventError) throw eventError;

        console.log(' Created event:', newEvent);

        // Only add the event creator
        console.log(' CREATE EVENT: Adding creator as participant...');
        const { error: insertError } = await supabase
            .from('event_participants')
            .insert([{
                event_id: newEvent.id,
                profile_id: currentUser.id,
                status: 'accepted'
            }]);

        console.log(' CREATE EVENT: Participant insert result:', insertError);

        if (insertError) throw insertError;

        // Update last_interaction_at for inactivity tracking
        console.log(' CREATE EVENT: Updating last interaction...');
        await supabase
            .from('match_participants')
            .update({ last_interaction_at: new Date().toISOString() })
            .eq('match_id', matchId)
            .eq('profile_id', currentUser.id);

        // Send notification to other match participants (non-blocking - fire and forget)
        console.log(' CREATE EVENT: Sending notifications (async, non-blocking)...');
        sendEventCreatedNotification(matchId, newEvent).catch(err => {
            console.error('Error sending event notifications:', err);
        });

        closeCreateEventModal();

        // Refresh matches to show new event
        console.log(' CREATE EVENT: Loading matches...');
        const matchesStart = Date.now();
        await loadMatches();
        console.log(` CREATE EVENT: Matches loaded in ${Date.now() - matchesStart}ms`);

        // Refresh events page if currently viewing it
        const currentPage = document.querySelector('.page.active')?.id;
        if (currentPage === 'events') {
            console.log(' CREATE EVENT: Loading events page...');
            const eventsStart = Date.now();
            await loadEvents();
            console.log(` CREATE EVENT: Events page loaded in ${Date.now() - eventsStart}ms`);
        }

        // Open the new event chat
        console.log(' CREATE EVENT: Opening event chat...');
        const chatStart = Date.now();
        openEventChat(newEvent.id);
        console.log(` CREATE EVENT: Event chat opened in ${Date.now() - chatStart}ms`);

        console.log(' CREATE EVENT: Complete!');

    } catch (error) {
        console.error(' CREATE EVENT: Error:', error);
        alert(`Failed to create event: ${error.message || JSON.stringify(error)}`);
    } finally {
        // Re-enable button and restore original text
        submitBtn.disabled = false;
        submitBtn.innerHTML = originalBtnText;
    }
}

// Auto-add new users to upcoming events when they join a match
async function autoAddToUpcomingEvents(matchId, newUserId) {
    try {
        // Check auth status
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        console.log('=== AUTH CHECK ===');
        console.log('Auth error:', authError);
        console.log('Authenticated user ID:', user?.id);
        console.log('Target user ID:', newUserId);
        console.log('Match?', user?.id === newUserId);
        
        if (!user) {
            console.error('No authenticated user - RLS will block all queries');
            return;
        }
        
        console.log('=== AUTO-ADD TO UPCOMING EVENTS ===');
        console.log('Match ID:', matchId);
        console.log('New User ID:', newUserId);
        
        // Find all upcoming events for this match
// Use current date in UTC for comparison
const now = new Date();
const todayUTC = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));

console.log('Querying with match_id:', matchId);
console.log('Querying with date >=', todayUTC.toISOString());

// Try the simplest possible query first
const { data: testQuery, error: testError } = await supabase
    .from('events')
    .select('*')
    .eq('match_id', matchId);

console.log('TEST - Simple query for all events in match:');
console.log('Error:', testError);
console.log('Result:', testQuery);

// Now try with filters
const { data: upcomingEvents, error: eventsError } = await supabase
    .from('events')
    .select('id, scheduled_date, scheduled_time, location, status')
    .eq('match_id', matchId)
    .eq('status', 'scheduled')
    .gte('scheduled_date', todayUTC.toISOString());

console.log('Query error:', eventsError);
console.log('Query result:', upcomingEvents);

if (eventsError) throw eventsError;

console.log('Comparison date (today UTC):', todayUTC.toISOString());
console.log('Found upcoming events:', upcomingEvents?.length || 0);

// Also check ALL events for this match to see what exists
const { data: allEvents } = await supabase
    .from('events')
    .select('id, scheduled_date, status')
    .eq('match_id', matchId);

console.log('All events for this match:', allEvents);        
        if (upcomingEvents && upcomingEvents.length > 0) {
            // Add user to all upcoming events
            const participantRecords = upcomingEvents.map(event => ({
                event_id: event.id,
                profile_id: newUserId,
                status: 'accepted'
            }));
            
            const { error: insertError } = await supabase
                .from('event_participants')
                .insert(participantRecords);
            
            if (insertError && insertError.code !== '23505') { // Ignore duplicate key errors
                throw insertError;
            }
            
            console.log(` Added user to ${upcomingEvents.length} upcoming event(s)`);
            
            // Notify user they were added to events
            if (upcomingEvents.length === 1) {
                showNotification(`You've been added to an upcoming event!`);
            } else {
                showNotification(`You've been added to ${upcomingEvents.length} upcoming events!`);
            }
        }
    } catch (error) {
        console.error('Error auto-adding to upcoming events:', error);
    }
}

// Open event chat
async function openEventChat(eventId) {
    try {
        console.log(' Opening event chat:', eventId);
        
        // Clean up ALL previous subscriptions
        if (eventMessageSubscription) {
            await supabase.removeChannel(eventMessageSubscription);
            const index = allActiveSubscriptions.indexOf(eventMessageSubscription);
            if (index > -1) allActiveSubscriptions.splice(index, 1);
            eventMessageSubscription = null;
        }

        // Load event details
        const { data: event, error: eventError } = await supabase
            .from('events')
            .select(`
                *,
                event_participants(
                    profile_id,
                    status,
                    profiles(id, name, avatar)
                )
            `)
            .eq('id', eventId)
            .single();
        
        if (eventError) throw eventError;

        // Check if user has joined this event
        const isUserInEvent = event.event_participants?.some(p => p.profile_id === currentUser.id);
        if (!isUserInEvent) {
            // User hasn't joined the event. Check if they're watching the match
            const { data: matchParticipant } = await supabase
                .from('match_participants')
                .select('id')
                .eq('match_id', event.match_id)
                .eq('profile_id', currentUser.id)
                .maybeSingle();

            if (matchParticipant) {
                // User is watching the match but hasn't joined this event
                // Store event ID to highlight it on the matches page
                highlightedEventId = eventId;
                showNotification('Join the event from the Matches page to view the chat', 'info');
                showPage('matches');
                return;
            } else {
                // User is not part of this match at all
                showNotification('Please join the event first', 'error');
                return;
            }
        }

        // Set context using helper
        setEventContext(event);
        
        // Show/hide buttons based on event status (planning vs scheduled)
        const calendarBtn = document.getElementById('add-to-calendar-btn');
        const eventOptionsBtn = document.getElementById('event-options-btn');
        const leaveEventBtn = document.getElementById('leave-event-btn');
        const lockDetailsBtn = document.getElementById('lock-details-btn');

        if (leaveEventBtn) leaveEventBtn.style.display = 'inline-block';

        // Show different buttons based on event status
        if (event.status === 'planning') {
            // Planning mode: Show "Lock in Details" button and options
            if (lockDetailsBtn) lockDetailsBtn.style.display = 'inline-block';
            if (calendarBtn) calendarBtn.style.display = 'none';
            if (eventOptionsBtn) eventOptionsBtn.style.display = 'inline-block';
        } else {
            // Scheduled mode: Show calendar and options buttons
            if (lockDetailsBtn) lockDetailsBtn.style.display = 'none';
            if (calendarBtn) calendarBtn.style.display = 'inline-block';
            if (eventOptionsBtn) eventOptionsBtn.style.display = 'inline-block';
        }

        // Hide create event button in event chats
        const createEventBtn = document.getElementById('create-event-header-btn');
        if (createEventBtn) createEventBtn.style.display = 'none';

// Show mute button for event chats
        const muteChatBtn = document.getElementById('mute-chat-btn');
        if (muteChatBtn) {
            muteChatBtn.style.display = 'inline-block';
            updateMuteButton(null, eventId, null);
        }

// Get activity details - load from database if not in current activities array
let activity = activities.find(a => a.id === event.activity_id);

// If not found in current activities, load it from database
if (!activity) {
    const { data: activityData, error: activityError } = await supabase
        .from('activities')
        .select('*')
        .eq('id', event.activity_id)
        .single();
    
    if (!activityError && activityData) {
        activity = activityData;
    }
}

// Update header with activity name only (date is shown in banner below)
document.getElementById('event-activity-name').textContent =
    `${activity ? activity.emoji : ''} ${activity ? activity.name : 'Unknown Activity'}`;

const participants = event.event_participants.map(p => p.profiles.name);
const participantCount = participants.length;

if (participantCount <= 3) {
    // Show all names
    document.getElementById('event-participants').textContent = participants.join(', ');
} else {
    // Show first 2 and "X others" (clickable)
    const shown = participants.slice(0, 2).join(', ');
    const remaining = participantCount - 2;
    const allNames = participants.join('\\n');
    
    document.getElementById('event-participants').innerHTML = 
        `${shown}, and <a href="#" onclick="event.preventDefault(); alert('Participants:\\n\\n${allNames}');" style="color: white; text-decoration: underline; cursor: pointer;">${remaining} other${remaining > 1 ? 's' : ''}</a>`;
}
        
        // Format and display event details based on status
        const eventDetailsDiv = document.getElementById('event-details');
        eventDetailsDiv.style.display = 'block'; // Show event details banner for event chats

        if (event.status === 'planning') {
            // Planning mode: Show proposed timeframe and suggested location
            eventDetailsDiv.style.background = '#fff3cd'; // Yellow background for planning
            eventDetailsDiv.style.borderColor = '#ffc107';

            const timeframeText = event.proposed_timeframe ? ` Proposed: ${event.proposed_timeframe}` : ' Planning...';
            const locationText = event.location ? `\n Suggested: ${event.location}` : '';

            document.getElementById('event-date').textContent = ` Planning Mode\n${timeframeText}${locationText}`;
            document.getElementById('event-location').textContent = '';
            document.getElementById('event-notes').textContent = event.notes ? ` ${event.notes}` : '';
        } else {
            // Scheduled mode: Show actual date, time, location
            eventDetailsDiv.style.background = '#e6f7ff'; // Blue background for scheduled
            eventDetailsDiv.style.borderColor = '#91d5ff';

            if (event.scheduled_date) {
                const eventDate = new Date(event.scheduled_date);
                const dateStr = eventDate.toLocaleDateString('en-US', {
                    weekday: 'long',
                    month: 'long',
                    day: 'numeric',
                    year: 'numeric'
                });

                // Format time if available
                let timeStr = '';
                if (event.scheduled_time) {
                    const [hours, minutes] = event.scheduled_time.split(':');
                    const hour = parseInt(hours);
                    const ampm = hour >= 12 ? 'PM' : 'AM';
                    const displayHour = hour === 0 ? 12 : (hour > 12 ? hour - 12 : hour);
                    timeStr = ` at ${displayHour}:${minutes} ${ampm}`;
                }

                document.getElementById('event-date').textContent = ` ${dateStr}${timeStr}`;
                document.getElementById('event-location').textContent =
                    event.location ? ` ${event.location}` : '';
                document.getElementById('event-notes').textContent =
                    event.notes ? ` ${event.notes}` : '';
            }
        }
        
        // Load messages (with archive support)
await loadEventMessages(eventId, event.created_at);

        // Mark event as read
        await markEventAsRead(eventId);

        // Set up broadcast subscription for new messages
eventMessageSubscription = supabase
    .channel(`event_${eventId}`)
    .on('broadcast', { event: 'new_message' }, (payload) => {
        console.log(' Broadcast message received:', payload);
        
        // Don't duplicate messages we sent ourselves
        if (payload.payload.sender_id === currentUser.id) {
            console.log(' Skipping own message');
            return;
        }
        
        console.log(' Processing message from another user');
        
        // Create message object with sender info from broadcast
        const message = {
            id: payload.payload.id,
            sender_id: payload.payload.sender_id,
            content: payload.payload.content,
            created_at: payload.payload.created_at,
            message_type: payload.payload.message_type,
            poll_id: payload.payload.poll_id,
            sender: {
                id: payload.payload.sender_id,
                name: payload.payload.sender_name,
                avatar: payload.payload.sender_avatar
            }
        };
        
        console.log('Appending message to chat:', message);
        appendMessage(message);
    })
    .on('broadcast', { event: 'message_edited' }, (payload) => {
        console.log(' Message edited:', payload);
        loadEventMessages(currentEvent.id, currentEvent.created_at);
    })
    .on('broadcast', { event: 'message_deleted' }, (payload) => {
        console.log(' Message deleted:', payload);
        loadEventMessages(currentEvent.id, currentEvent.created_at);
    })
    .on('broadcast', { event: 'reaction_changed' }, async (payload) => {
        console.log(' Event message reaction changed:', payload);
        const messageId = payload.payload.messageId;
        await fetchMessageReactions(messageId, 'event');
        updateReactionDisplay(messageId, 'event');
    })
    .on('broadcast', { event: 'message_read' }, async (payload) => {
        console.log(' Event message read:', payload);
        const messageId = payload.payload.messageId;
        // Find the message and update its read count if it's the current user's message
        const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
        if (messageElement) {
            // Get the sender_id from the message element or refetch
            const { data: message } = await supabase
                .from('event_messages')
                .select('sender_id')
                .eq('id', messageId)
                .single();
            if (message) {
                updateReadCountDisplay(messageId, 'event', message.sender_id);
            }
        }
    })
    .on('broadcast', { event: 'messages_read' }, async (payload) => {
        console.log(' Event messages read by user:', payload.payload.userId);
        // Refresh read counts for all user's own messages
        const messageElements = document.querySelectorAll('[data-message-id]');
        for (const messageElement of messageElements) {
            const messageId = messageElement.getAttribute('data-message-id');
            const { data: message } = await supabase
                .from('event_messages')
                .select('sender_id')
                .eq('id', messageId)
                .single();
            if (message && message.sender_id === currentUser.id) {
                updateReadCountDisplay(messageId, 'event', message.sender_id);
            }
        }
    })
    .on('broadcast', { event: 'poll_updated' }, (payload) => {
        console.log(' Poll updated:', payload.payload.pollId);
        refreshPollDisplay(payload.payload.pollId);
    })
    .subscribe((status) => {
        console.log('Event chat subscription status:', status);
    });

allActiveSubscriptions.push(eventMessageSubscription);

        showPage('chat');

        // Save event chat context for refresh persistence
        localStorage.setItem('friendle_current_chat_context', JSON.stringify({
            type: 'event',
            id: eventId
        }));

        // Force scroll to bottom after page is shown (especially for notifications)
        setTimeout(() => forceScrollToBottom(), 300);

    } catch (error) {
        console.error('Error loading event chat:', error);
        alert('Failed to load event chat');
    }
}

// Load messages for current event
async function loadEventMessages(eventId, eventCreatedAt, preserveScroll = false, savedScrollPosition = null) {
    try {
        const messagesContainer = document.getElementById('chat-messages');

        // Save scroll position if preserving
        const scrollPos = preserveScroll && !savedScrollPosition ? messagesContainer.scrollTop : savedScrollPosition;

        // Reset pagination state for initial load
        if (!preserveScroll) {
            messagePagination.event = { loadedCount: 0, hasMore: true, loading: false };
        }

        // Load most recent messages (descending order, then reverse)
        const { data: messages, error } = await supabase
    .from('event_messages')
    .select(`
        *,
        sender:profiles(id, name, avatar)
    `)
    .eq('event_id', eventId)
    .order('created_at', { ascending: false })
    .limit(MESSAGE_PAGE_SIZE);

        if (error) throw error;

        // Reverse to show oldest-to-newest
        if (messages) {
            messages.reverse();
        }

        messagesContainer.innerHTML = '';

        // Split messages into archived (before event) and current (after event)
        const eventCreatedDate = new Date(eventCreatedAt);
        const archivedMessages = messages.filter(m => new Date(m.created_at) < eventCreatedDate);
        const currentMessages = messages.filter(m => new Date(m.created_at) >= eventCreatedDate);

        // Update pagination state based on current messages
        messagePagination.event.loadedCount = currentMessages?.length || 0;
        messagePagination.event.hasMore = messages?.length === MESSAGE_PAGE_SIZE;

        // Show archived messages toggle if any exist
        if (archivedMessages.length > 0) {
            const archiveToggle = document.createElement('div');
            archiveToggle.style.cssText = `
                padding: 10px;
                background: #f0f0f0;
                border-radius: 8px;
                text-align: center;
                margin-bottom: 15px;
                cursor: pointer;
                color: #666;
                font-size: 14px;
                user-select: none;
            `;
            archiveToggle.innerHTML = `
                <span id="archive-toggle-text"> Show ${archivedMessages.length} older message${archivedMessages.length > 1 ? 's' : ''} (before event was created)</span>
            `;
            archiveToggle.onclick = () => toggleArchivedMessages(eventId, eventCreatedAt);
            messagesContainer.appendChild(archiveToggle);

            // Container for archived messages (hidden by default)
            const archivedContainer = document.createElement('div');
            archivedContainer.id = 'archived-messages';
            archivedContainer.style.display = 'none';
            archivedContainer.style.cssText = `
                border-left: 3px solid #ddd;
                padding-left: 10px;
                margin-bottom: 20px;
                opacity: 0.7;
            `;
            messagesContainer.appendChild(archivedContainer);

            // Add archived messages to container
            archivedMessages.forEach(message => {
                appendMessageToContainer(message, archivedContainer);
            });

            // Divider
            const divider = document.createElement('div');
            divider.style.cssText = `
                border-top: 2px solid #ddd;
                margin: 20px 0;
                padding-top: 10px;
                text-align: center;
                color: #999;
                font-size: 13px;
            `;
            divider.innerHTML = ' Event Created';
            archivedContainer.appendChild(divider);
        }

        // Show current messages
        if (currentMessages.length === 0 && archivedMessages.length === 0) {
            messagesContainer.innerHTML += '<p style="text-align: center; color: #999; padding: 20px;">No messages yet. Start the conversation!</p>';
            messagePagination.event.hasMore = false;
        } else if (currentMessages.length === 0) {
            const placeholder = document.createElement('p');
            placeholder.style.cssText = 'text-align: center; color: #999; padding: 20px;';
            placeholder.textContent = 'No messages since event was created. Say something!';
            messagesContainer.appendChild(placeholder);
            messagePagination.event.hasMore = false;
        } else {
            currentMessages.forEach(message => appendMessage(message));
        }

        // Add "Load older messages" button if there are more messages
        if (messagePagination.event.hasMore) {
            createLoadOlderButton('event');
        }

        // Scroll handling - preserve position or scroll to bottom
        setTimeout(() => {
            if (preserveScroll && scrollPos !== null) {
                messagesContainer.scrollTop = scrollPos;
                console.log(' Restored scroll position to:', scrollPos);
            } else {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                console.log(' Scrolled to bottom');
            }
        }, 500);

        // Mark all visible messages as read
        setTimeout(() => {
            markAllVisibleMessagesAsRead('event');
        }, 1000);

    } catch (error) {
        console.error('Error loading messages:', error);
    }
}

function toggleArchivedMessages(eventId, eventCreatedAt) {
    const archivedContainer = document.getElementById('archived-messages');
    const toggleText = document.getElementById('archive-toggle-text');
    
    showingArchivedMessages = !showingArchivedMessages;
    
    if (showingArchivedMessages) {
        archivedContainer.style.display = 'block';
        toggleText.textContent = ' Hide older messages';
    } else {
        archivedContainer.style.display = 'none';
        const archivedCount = archivedContainer.querySelectorAll('.message').length - 1; // -1 for divider
        toggleText.textContent = ` Show ${archivedCount} older message${archivedCount > 1 ? 's' : ''} (before event was created)`;
    }
}

// SECURITY: Sanitize HTML to prevent XSS attacks while allowing legitimate content
// This function escapes dangerous HTML but allows:
// - Images from Supabase storage
// - Links to Google Maps/Search (app-generated)
function sanitizeHTML(str) {
    if (!str) return '';

    // Pattern 1: Images from Supabase storage
    const supabaseImagePattern = /^<img src="https:\/\/kxsewkjbhxtfqbytftbu\.supabase\.co\/storage\/v1\/object\/public\/chat-photos\/[^"]*"[^>]*>$/;

    // Pattern 2: Links with emojis ( for maps,  for search) - app-generated
    const trustedLinkPattern = /^(|)\s*<a href="https:\/\/(www\.google\.com\/maps|www\.google\.com\/search)[^"]*" target="_blank" rel="noopener noreferrer"[^>]*>[^<]*<\/a>$/;

    const trimmed = str.trim();

    if (supabaseImagePattern.test(trimmed) || trustedLinkPattern.test(trimmed)) {
        // This is trusted content from our app - allow it
        return str;
    }

    // For everything else, escape all HTML to prevent XSS
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
}

// Helper function to render avatar HTML (supports both image URLs and emojis)
function renderAvatar(avatar, size = 32) {
    if (!avatar) {
        avatar = ''; // Default avatar
    }

    // Check if avatar is an image URL
    if (avatar.startsWith('http')) {
        return `<img src="${avatar}" alt="Avatar" style="width: ${size}px; height: ${size}px; border-radius: 50%; object-fit: cover;">`;
    } else {
        // It's an emoji
        return `<div style="width: ${size}px; height: ${size}px; border-radius: 50%; background: #e0e0e0; display: flex; align-items: center; justify-content: center; font-size: ${size * 0.56}px;">${avatar}</div>`;
    }
}

// Helper function to force scroll to bottom of chat - tries multiple times for reliability
function forceScrollToBottom(attempts = 0) {
    const messagesContainer = document.getElementById('chat-messages');
    if (!messagesContainer) {
        console.warn('No messages container found for scrolling');
        return;
    }

    // Method 1: Scroll using scrollTop
    messagesContainer.scrollTop = messagesContainer.scrollHeight;

    // Method 2: Find last message and scroll it into view
    const messages = messagesContainer.querySelectorAll('.message, div[style*="margin-bottom: 15px"]');
    if (messages.length > 0) {
        const lastMessage = messages[messages.length - 1];
        lastMessage.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }

    console.log(` Force scroll to bottom (attempt ${attempts + 1}), scrollTop: ${messagesContainer.scrollTop}, scrollHeight: ${messagesContainer.scrollHeight}`);

    // Retry up to 3 times with increasing delays to handle async content loading
    if (attempts < 3) {
        setTimeout(() => forceScrollToBottom(attempts + 1), 200 + (attempts * 200));
    }
}

// Helper to append message to specific container
function appendMessageToContainer(message, container) {
    const isOwnMessage = message.sender_id === currentUser.id;
    const messageTime = formatMessageTimestamp(message.created_at);

    // Determine message type from current context
    const context = getCurrentChatContext();
    const messageType = context.type;

    const messageDiv = document.createElement('div');
    messageDiv.className = 'message';
    messageDiv.setAttribute('data-message-id', message.id);
    messageDiv.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: ${isOwnMessage ? 'flex-end' : 'flex-start'};
        margin-bottom: 15px;
    `;

    let onClick = '';
    // SECURITY: Check if message is soft-deleted
    let content = message.is_deleted
        ? '<span style="font-style: italic;">[Deleted]</span>'
        : sanitizeHTML(message.content); // SECURITY: Sanitize to prevent XSS
    let senderName = sanitizeHTML(message.sender.name); // SECURITY: Sanitize sender name

    messageDiv.innerHTML = `
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; ${isOwnMessage ? 'flex-direction: row-reverse;' : ''}">
            ${renderAvatar(message.sender.avatar, 32)}
            <span style="font-size: 13px; color: #666; font-weight: 500;">
                ${isOwnMessage ? 'You' : senderName}
            </span>
            <span style="font-size: 11px; color: #999;">
                ${messageTime}
            </span>
        </div>
        <div style="display: flex; gap: 8px; align-items: flex-start; ${isOwnMessage ? 'flex-direction: row-reverse;' : ''}">
            <div ${onClick} style="
    background: ${message.is_deleted ? 'var(--bg-secondary)' : (isOwnMessage ? '#4CAF50' : '#f0f0f0')};
    color: ${message.is_deleted ? 'var(--text-secondary)' : (isOwnMessage ? 'white' : 'black')};
    padding: 10px 14px;
    border-radius: 12px;
    max-width: 70%;
    word-wrap: break-word;
    overflow-wrap: break-word;
    word-break: normal;
    min-width: fit-content;
">
                ${content}
            </div>
        </div>
        <div class="message-reactions-wrapper" style="margin-top: 4px; display: flex; gap: 6px; align-items: center; flex-wrap: wrap;">
            <button
                onclick="showReactionPicker('${message.id}', '${messageType}', event)"
                style="
                    background: none;
                    border: 1px solid var(--border-color);
                    border-radius: 12px;
                    padding: 4px 8px;
                    font-size: 16px;
                    cursor: pointer;
                    color: var(--text-secondary);
                    transition: all 0.2s;
                "
                onmouseover="this.style.background='var(--bg-secondary)'"
                onmouseout="this.style.background='none'"
                title="Add reaction"
            >
                +
            </button>
        </div>
    `;

    // Add edit/delete for own messages (archived messages are read-only for simplicity)

    container.appendChild(messageDiv);

    // Fetch and display reactions for this message
    if (messageType !== 'none') {
        fetchMessageReactions(message.id, messageType).then(() => {
            updateReactionDisplay(message.id, messageType);
        });
        // Fetch and display read count (only for user's own messages)
        updateReadCountDisplay(message.id, messageType, message.sender_id);
    }
}

function appendMessage(message) {
    const messagesContainer = document.getElementById('chat-messages');

    // Remove placeholder text if it exists
    const placeholder = messagesContainer.querySelector('p');
    if (placeholder && placeholder.textContent.includes('No messages yet')) {
        messagesContainer.innerHTML = '';
    }

    // Check if message already exists (prevent duplicates)
    const existingMessage = document.querySelector(`[data-message-id="${message.id}"]`);
    if (existingMessage) {
        console.log(' Message already exists, skipping duplicate:', message.id);
        return;
    }

    // Handle different message types
    if (message.message_type === 'poll') {
        console.log(' Rendering poll message:', { messageId: message.id, pollId: message.poll_id });
        // Render poll message - fetch poll data and call renderPollMessage
        supabase
            .from('polls')
            .select('*')
            .eq('id', message.poll_id)
            .single()
            .then(({ data: poll, error }) => {
                if (error) {
                    console.error(' Error fetching poll:', error);
                    return;
                }
                if (poll) {
                    console.log(' Poll data fetched, rendering:', poll);
                    renderPollMessage(message, poll);
                } else {
                    console.warn(' No poll data returned for poll_id:', message.poll_id);
                }
            })
            .catch(err => {
                console.error(' Exception fetching poll:', err);
            });
        return;
    }

    if (message.message_type === 'system') {
        // Render system message
        const systemDiv = document.createElement('div');
        systemDiv.style.cssText = `
            text-align: center;
            margin: 20px 0;
            padding: 12px;
            background: #f0f9ff;
            border-radius: 8px;
            font-size: 14px;
            color: #0369a1;
            white-space: pre-line;
        `;
        systemDiv.textContent = message.content;
        messagesContainer.appendChild(systemDiv);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        return;
    }

    const isOwnMessage = message.sender_id === currentUser.id;
    const messageTime = formatMessageTimestamp(message.created_at);

    // Determine message type from current context
    const context = getCurrentChatContext();
    const messageType = context.type;

    // SECURITY: Sanitize user input to prevent XSS and handle soft-deleted messages
    const sanitizedContent = message.is_deleted
        ? '<span style="font-style: italic;">[Deleted]</span>'
        : sanitizeHTML(message.content);
    const sanitizedSenderName = sanitizeHTML(message.sender.name);
    const escapedContentForEdit = message.content.replace(/`/g, '\\`').replace(/\$/g, '\\$').replace(/'/g, "\\'");

    const messageDiv = document.createElement('div');
    messageDiv.setAttribute('data-message-id', message.id);
    messageDiv.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: ${isOwnMessage ? 'flex-end' : 'flex-start'};
        margin-bottom: 15px;
        width: 100%;
    `;

    messageDiv.innerHTML = `
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; ${isOwnMessage ? 'flex-direction: row-reverse;' : ''}">
            ${renderAvatar(message.sender.avatar, 32)}
            <span style="font-size: 13px; color: #666; font-weight: 500;">
                ${isOwnMessage ? 'You' : sanitizedSenderName}
            </span>
            <span style="font-size: 11px; color: #999;">
                ${messageTime}
            </span>
        </div>
        <div style="display: flex; gap: 8px; align-items: flex-start; ${isOwnMessage ? 'flex-direction: row-reverse;' : ''}; max-width: 100%;">
            <div style="background: ${message.is_deleted ? 'var(--bg-secondary)' : (isOwnMessage ? '#4CAF50' : '#f0f0f0')}; color: ${message.is_deleted ? 'var(--text-secondary)' : (isOwnMessage ? 'white' : 'black')}; padding: 10px 14px; border-radius: 12px; max-width: 280px; word-wrap: break-word; overflow-wrap: break-word;">
    ${sanitizedContent}
</div>
            ${!message.is_deleted ? `
    <div class="message-actions" style="position: relative;">
        <button onclick="toggleEventMessageActions('${message.id}')" style="background: none; border: none; color: #aaa; cursor: pointer; font-size: 1.2em; padding: 5px;"></button>
        <div id="event-menu-${message.id}" class="message-actions-menu">
            ${isOwnMessage ? `
                ${!message.content.includes('<img') && !message.content.includes('<a') ? `<button onclick="editEventMessage('${message.id}', \`${escapedContentForEdit}\`)"> Edit</button>` : ''}
                <button onclick="deleteEventMessage('${message.id}')" class="delete-btn"> Delete</button>
            ` : `
                <button onclick="openReportModal('message', '${message.id}', '${sanitizedSenderName}', '${message.sender_id}')"> Report</button>
                <button onclick="openBlockUserModal('${message.sender_id}', '${sanitizedSenderName}')"> Block User</button>
            `}
        </div>
    </div>
` : ''}
        </div>
        <div class="message-reactions-wrapper" style="margin-top: 4px; display: flex; gap: 6px; align-items: center; flex-wrap: wrap;">
            <button
                onclick="showReactionPicker('${message.id}', '${messageType}', event)"
                style="
                    background: none;
                    border: 1px solid var(--border-color);
                    border-radius: 12px;
                    padding: 4px 8px;
                    font-size: 16px;
                    cursor: pointer;
                    color: var(--text-secondary);
                    transition: all 0.2s;
                "
                onmouseover="this.style.background='var(--bg-secondary)'"
                onmouseout="this.style.background='none'"
                title="Add reaction"
            >
                +
            </button>
        </div>
    `;

    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;

    // Fetch and display reactions for this message
    if (messageType !== 'none') {
        fetchMessageReactions(message.id, messageType).then(() => {
            updateReactionDisplay(message.id, messageType);
        });
        // Fetch and display read count (only for user's own messages)
        updateReadCountDisplay(message.id, messageType, message.sender_id);
    }
}

// Send message
async function sendEventMessage(e) {
    e.preventDefault();

    const input = document.getElementById('message-input');
    const content = input.value.trim();

    if (!content) return;

    // SECURITY: Rate limiting - max 20 messages per minute
    if (!RateLimiter.checkLimit('send_message', 20, 60000)) {
        return showNotification('Slow down! You\'re sending messages too quickly.', 'error');
    }

    try {
        if (currentEvent) {
            // Event chat
            const { data, error } = await supabase
                .from('event_messages')
                .insert({
                    event_id: currentEvent.id,
                    sender_id: currentUser.id,
                    content: content
                })
                .select(`
                    *,
                    sender:profiles(id, name, avatar)
                `)
                .single();
            
            if (error) throw error;
            
            appendMessage(data);
            
            const channel = supabase.channel(`event_${currentEvent.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'new_message',
                payload: {
                    id: data.id,
                    sender_id: currentUser.id,
                    sender_name: currentUser.name,
                    sender_avatar: currentUser.avatar,
                    content: data.content,
                    created_at: data.created_at
                }
            });
        }
        
        input.value = '';
        
    } catch (error) {
        console.error('Error sending message:', error);
        showNotification('Failed to send message', 'error');
    }
}

// Event options functions
function openEventOptionsModal() {
    const modal = document.getElementById('event-options-modal');
    const editBtn = document.getElementById('event-edit-btn');
    const cancelBtn = document.getElementById('event-cancel-btn');

    // Hide edit and cancel buttons in planning mode
    // Planning events should only be deleted (removed) or locked (finalized)
    if (currentEvent) {
        if (currentEvent.status === 'planning') {
            if (editBtn) editBtn.style.display = 'none';
            if (cancelBtn) cancelBtn.style.display = 'none';
        } else {
            if (editBtn) editBtn.style.display = 'block';
            if (cancelBtn) cancelBtn.style.display = 'block';
        }
    }

    if (modal) {
        modal.style.display = 'flex';
    } else {
        console.error('Event options modal not found');
    }
}

function closeEventOptionsModal() {
    document.getElementById('event-options-modal').style.display = 'none';
}

function editCurrentEvent() {
    // Only event creator can edit
    if (currentEvent.created_by !== currentUser.id) {
        alert('Only the event creator can edit this event');
        return;
    }

    closeEventOptionsModal();

    // Populate edit form
    const date = new Date(currentEvent.scheduled_date);
    document.getElementById('edit-event-date').value = date.toISOString().slice(0, 10);
    document.getElementById('edit-event-time').value = currentEvent.scheduled_time || '';
    document.getElementById('edit-event-location').value = currentEvent.location || '';
    document.getElementById('edit-event-notes').value = currentEvent.notes || '';
    document.getElementById('edit-event-max-participants').value = currentEvent.max_participants || '';

    document.getElementById('edit-event-modal').style.display = 'flex';
}

function closeEditEventModal() {
    document.getElementById('edit-event-modal').style.display = 'none';
}

async function saveEventEdits(e) {
    e.preventDefault();

    try {
        console.log(' Debug - Event update attempt:', {
            eventId: currentEvent.id,
            eventCreator: currentEvent.created_by,
            currentUserId: currentUser.id,
            isCreator: currentEvent.created_by === currentUser.id
        });

        const maxParticipantsInput = document.getElementById('edit-event-max-participants').value;
        const maxParticipants = maxParticipantsInput ? parseInt(maxParticipantsInput, 10) : null;

        const updateData = {
            scheduled_date: document.getElementById('edit-event-date').value,
            scheduled_time: document.getElementById('edit-event-time').value || null,
            location: document.getElementById('edit-event-location').value || null,
            notes: document.getElementById('edit-event-notes').value || null,
            max_participants: maxParticipants
        };

        console.log(' Update data:', updateData);

        const { data, error } = await supabase
            .from('events')
            .update(updateData)
            .eq('id', currentEvent.id)
            .select();

        console.log(' Update result:', { data, error });

        if (error) throw error;

        // Check if the update actually succeeded (RLS may block non-creators)
        if (!data || data.length === 0) {
            throw new Error('Only the event creator can edit event details');
        }

        closeEditEventModal();

        // Reload the event
        openEventChat(currentEvent.id);

    } catch (error) {
        console.error('Error updating event:', error);
        alert(`Failed to update event: ${error.message || JSON.stringify(error)}`);
    }
}

async function cancelEvent() {
    if (!confirm('Cancel this event? This will notify all participants.')) return;

    // Only event creator can cancel
    if (currentEvent.created_by !== currentUser.id) {
        alert('Only the event creator can cancel this event');
        return;
    }

    try {
        const { data, error } = await supabase
            .from('events')
            .update({ status: 'cancelled' })
            .eq('id', currentEvent.id)
            .select();

        if (error) throw error;

        // Check if the update actually succeeded (RLS may block non-creators)
        if (!data || data.length === 0) {
            throw new Error('Only the event creator can cancel this event');
        }
        
        // Send a system message
        await supabase
            .from('event_messages')
            .insert({
                event_id: currentEvent.id,
                sender_id: currentUser.id,
                content: ' This event has been cancelled'
            });
        
        closeEventOptionsModal();
        showPage('matches');
        await loadMatches();
        
    } catch (error) {
        console.error('Error cancelling event:', error);
        alert('Failed to cancel event');
    }
}

async function leaveEvent() {
    if (!confirm('Leave this event? You won\'t receive any more messages.')) return;
    
    try {
        const { error } = await supabase
            .from('event_participants')
            .delete()
            .eq('event_id', currentEvent.id)
            .eq('profile_id', currentUser.id);
        
        if (error) throw error;

        closeEventOptionsModal();
        await goToPreviousPage();
        
    } catch (error) {
        console.error('Error leaving event:', error);
        alert('Failed to leave event');
    }
}

async function deleteEvent() {
    if (!confirm('Delete this event permanently? This will remove it for all participants and cannot be undone.')) return;

    try {
        console.log(' Debug - Delete event attempt:', {
            eventId: currentEvent.id,
            eventCreator: currentEvent.created_by,
            currentUserId: currentUser.id,
            circleId: currentEvent.circle_id
        });

        // Check if user is event creator
        const isEventCreator = currentEvent.created_by === currentUser.id;
        console.log(' Is event creator:', isEventCreator);

        // Check if user is circle creator
        let isCircleCreator = false;
        if (currentEvent.circle_id) {
            const { data: circle, error: circleError } = await supabase
                .from('circles')
                .select('created_by')
                .eq('id', currentEvent.circle_id)
                .single();

            if (circleError) {
                console.error('Error fetching circle:', circleError);
            } else {
                console.log(' Circle data:', circle);
                isCircleCreator = circle?.created_by === currentUser.id;
                console.log(' Is circle creator:', isCircleCreator);
            }
        }

        // Allow deletion if user is either event creator or circle creator
        if (!isEventCreator && !isCircleCreator) {
            console.log(' User not authorized to delete');
            alert('Only the event creator or circle admin can delete this event');
            return;
        }

        console.log(' User authorized, attempting delete...');
        const { error } = await supabase
            .from('events')
            .delete()
            .eq('id', currentEvent.id);

        if (error) {
            console.error(' Database delete error:', error);
            throw error;
        }

        console.log(' Event deleted successfully');
        closeEventOptionsModal();
        showNotification('Event deleted');
        await loadMatches();
        await goToPreviousPage();

    } catch (error) {
        console.error('Error deleting event:', error);
        alert('Failed to delete event: ' + (error.message || 'Unknown error'));
    }
}

async function deleteEmptyEvent(eventId) {
    if (!confirm('Delete this empty event?')) return;
    
    try {
        showLoader('Deleting event...');
        
        const { error } = await supabase
            .from('events')
            .delete()
            .eq('id', eventId);
        
        if (error) throw error;
        
        hideLoader();
        showNotification('Event deleted');
        await loadMatches();
        
    } catch (error) {
        hideLoader();
        console.error('Error deleting empty event:', error);
        showNotification('Failed to delete event', 'error');
    }
}

// Removed: loadMatchMessages() - deprecated with match chat system
 

       
        // Image compression helper
function compressImage(file, maxWidth = 1200, quality = 0.8) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = () => reject(new Error('Failed to read file'));
        
        reader.onload = (e) => {
            const img = new Image();
            img.onerror = () => reject(new Error('Failed to load image'));
            
            img.onload = () => {
                const canvas = document.createElement('canvas');
                let width = img.width;
                let height = img.height;
                
                // Calculate new dimensions
                if (width > maxWidth) {
                    height = (height * maxWidth) / width;
                    width = maxWidth;
                }
                
                canvas.width = width;
                canvas.height = height;
                
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
                
                // Convert to blob
                canvas.toBlob((blob) => {
                    if (!blob) {
                        reject(new Error('Failed to compress image'));
                        return;
                    }
                    
                    // Create new file from blob
                    const compressedFile = new File([blob], file.name, {
                        type: 'image/jpeg',
                        lastModified: Date.now()
                    });
                    
                    resolve(compressedFile);
                }, 'image/jpeg', quality);
            };
            
            img.src = e.target.result;
        };
        
        reader.readAsDataURL(file);
    });
}

// Attachments & Modals
window.sharePhoto = function() {
    // Get the photo button to position the menu near it
    const photoBtn = document.getElementById('photo-btn');
    const rect = photoBtn.getBoundingClientRect();

    // Position menu above the button
    showChatPhotoMenu(rect.left, rect.top - 10);
}

// Chat photo upload function (shared by camera and library)
async function uploadChatPhoto(file) {
    if (!file) return;

    const context = getCurrentChatContext();

    if (context.type === 'none') {
        return showNotification('No active chat to send photo to', 'error');
    }

    console.log(' Sharing photo in context:', context.type);

    showLoader('Compressing image...');

    try {
        const compressedFile = await compressImage(file);

        if (compressedFile.size > 5 * 1024 * 1024) {
            hideLoader();
            return showNotification('Photo too large even after compression. Please try a smaller image.', 'error');
        }

        showLoader('Uploading photo...');
        const fileExt = file.name.split('.').pop();
        const fileName = `${currentUser.id}/${Date.now()}.${fileExt}`;

        const { data, error } = await supabase.storage
            .from('chat-photos')
            .upload(fileName, compressedFile, {
                cacheControl: '3600',
                upsert: false
            });

        if (error) throw error;

        const { data: urlData } = supabase.storage
            .from('chat-photos')
            .getPublicUrl(fileName);

        const photoUrl = urlData.publicUrl;

        if (context.type === 'event') {
            // EVENT CHAT (check this first!)
            const { data: messageData, error: messageError } = await supabase
                .from('event_messages')
                .insert({
                    event_id: context.id,
                    sender_id: currentUser.id,
                    content: `<img src="${photoUrl}" style="max-width: 200px; border-radius: 10px; cursor: pointer;" onclick="openImageModal('${photoUrl}')">`
                })
                .select(`*, sender:profiles(id, name, avatar)`)
                .single();

            if (messageError) throw messageError;

            appendMessage(messageData);

            const channel = supabase.channel(`event_${context.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'new_message',
                payload: {
                    id: messageData.id,
                    sender_id: currentUser.id,
                    sender_name: currentUser.name,
                    sender_avatar: currentUser.avatar,
                    content: messageData.content,
                    created_at: messageData.created_at
                }
            });

        } else if (context.type === 'circle') {
            // CIRCLE CHAT
            const { data: messageData, error: messageError } = await supabase
                .from('circle_messages')
                .insert({
                    circle_id: context.id,
                    sender_id: currentUser.id,
                    content: `<img src="${photoUrl}" style="max-width: 100%; max-height: 300px; width: auto; height: auto; display: block; border-radius: 10px; cursor: pointer;" onclick="openImageModal('${photoUrl}')">`
                })
                .select(`*, sender:profiles(id, name, avatar)`)
                .single();

            if (messageError) throw messageError;

            appendMessage(messageData);

            const channel = supabase.channel(`circle_chat_${context.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'new_circle_message',
                payload: {
                    id: messageData.id,
                    sender_id: currentUser.id,
                    sender_name: currentUser.name,
                    sender_avatar: currentUser.avatar,
                    content: messageData.content,
                    created_at: messageData.created_at
                }
            });
        }

        hideLoader();
        showNotification('Photo shared!');

    } catch (error) {
        hideLoader();
        console.error('Error uploading photo:', error);
        showNotification('Failed to upload photo. Please try again.', 'error');
    }
}

// Match notification functions - redirects to new swipe action modal
function showMatchNotification(activity, matchId, otherUsers) {
    // Use new swipe action modal instead of old match notification modal
    const activityName = `${activity.emoji} ${activity.name}`;
    openSwipeActionModal(matchId, activityName, activity);
}

function showFirstToChoosePopup(activity, matchId) {
    // Use new swipe action modal instead of old first-to-choose modal
    const activityName = `${activity.emoji} ${activity.name}`;
    openSwipeActionModal(matchId, activityName, activity);
}

// Removed: Old match notification modal functions (closeMatchNotification, joinMatchFromNotification)
// Removed: Old first-to-choose modal functions (closeFirstToChooseModal, joinMatchFromFirstToChoose)

function openLocationPermissionModal() {
    document.getElementById('location-permission-modal').style.display = 'flex';
}

function closeLocationPermissionModal() {
    document.getElementById('location-permission-modal').style.display = 'none';
}

async function requestLocationPermission() {
    closeLocationPermissionModal();
    
    // Request permission by attempting to get location
    navigator.geolocation.getCurrentPosition(
        (position) => {
            showNotification('Location access enabled!');
            // Store that we have permission
            localStorage.setItem('location_permission_granted', 'true');
        },
        (error) => {
            if (error.code === error.PERMISSION_DENIED) {
                alert('Location access was denied. Please enable it in your browser settings:\n\n1. Click the lock/info icon in the address bar\n2. Find "Location" permissions\n3. Change to "Allow"');
            } else {
                showNotification('Could not access location. Please try again.', 'error');
            }
        }
    );
}

async function checkLocationPermission() {
    // Check if browser supports permissions API
    if (!navigator.permissions) {
        // Fallback: just check if geolocation exists
        return navigator.geolocation ? 'prompt' : 'unsupported';
    }
    
    try {
        const result = await navigator.permissions.query({ name: 'geolocation' });
        return result.state; // 'granted', 'denied', or 'prompt'
    } catch (error) {
        // Safari doesn't support permissions.query for geolocation
        return 'prompt';
    }
}

        window.shareLocation = async function() {
    if (!navigator.geolocation) {
        return showNotification('Geolocation not supported on this device', 'error');
    }

    const context = getCurrentChatContext();

    if (context.type === 'none') {
        return showNotification('No active chat to share location', 'error');
    }

    const permission = await checkLocationPermission();

    if (permission === 'denied') {
        alert('Location access is blocked. Please enable it in your browser settings:\n\n1. Click the lock/info icon in the address bar\n2. Find "Location" permissions\n3. Change to "Allow"\n4. Reload the page');
        return;
    }

    if (permission === 'prompt') {
        openLocationPermissionModal();
        return;
    }

    console.log(' Sharing location in context:', context.type);

    // Show loading state
    const locationBtn = document.getElementById('location-btn');
    if (locationBtn) locationBtn.classList.add('loading');

    navigator.geolocation.getCurrentPosition(
        async (pos) => {
            const lat = pos.coords.latitude;
            const lng = pos.coords.longitude;
            const mapsUrl = `https://www.google.com/maps?q=${lat},${lng}`;
            
            try {
                if (context.type === 'event') {
                    // EVENT CHAT
                    const { data, error } = await supabase
                        .from('event_messages')
                        .insert({
                            event_id: context.id,
                            sender_id: currentUser.id,
                            content: ` <a href="${mapsUrl}" target="_blank" rel="noopener noreferrer" style="color: #1e90ff; text-decoration: underline; font-weight: 500;">View Location on Map</a>`
                        })
                        .select(`*, sender:profiles(id, name, avatar)`)
                        .single();
                    
                    if (error) throw error;
                    
                    appendMessage(data);
                    
                    const channel = supabase.channel(`event_${context.id}`);
                    await channel.send({
                        type: 'broadcast',
                        event: 'new_message',
                        payload: {
                            id: data.id,
                            sender_id: currentUser.id,
                            sender_name: currentUser.name,
                            sender_avatar: currentUser.avatar,
                            content: data.content,
                            created_at: data.created_at
                        }
                    });

                } else if (context.type === 'circle') {
                    // CIRCLE CHAT
                    const { data, error } = await supabase
                        .from('circle_messages')
                        .insert({
                            circle_id: context.id,
                            sender_id: currentUser.id,
                            content: ` <a href="${mapsUrl}" target="_blank" rel="noopener noreferrer" style="color: #1e90ff; text-decoration: underline; font-weight: 500;">View Location on Map</a>`
                        })
                        .select(`*, sender:profiles(id, name, avatar)`)
                        .single();

                    if (error) throw error;

                    appendMessage(data);

                    const channel = supabase.channel(`circle_chat_${context.id}`);
                    await channel.send({
                        type: 'broadcast',
                        event: 'new_circle_message',
                        payload: {
                            id: data.id,
                            sender_id: currentUser.id,
                            sender_name: currentUser.name,
                            sender_avatar: currentUser.avatar,
                            content: data.content,
                            created_at: data.created_at
                        }
                    });
                }

                showNotification('Location shared!');

            } catch (error) {
                console.error('Error sharing location:', error);
                showNotification('Failed to share location. Please try again.', 'error');
            } finally {
                // Remove loading state
                if (locationBtn) locationBtn.classList.remove('loading');
            }
        },
        (error) => {
            // Remove loading state
            if (locationBtn) locationBtn.classList.remove('loading');
            showNotification('Could not get location', 'error');
        },
        { enableHighAccuracy: true, timeout: 5000, maximumAge: 30000 }
    );
}
        window.openImageModal = src => { document.getElementById('modal-image').src = src; document.getElementById('image-modal-overlay').style.display = 'flex'; };
        window.closeImageModal = () => document.getElementById('image-modal-overlay').style.display = 'none';

        window.downloadImage = async function() {
            try {
                const imgSrc = document.getElementById('modal-image').src;
                if (!imgSrc) return;

                // Fetch the image as a blob
                const response = await fetch(imgSrc);
                const blob = await response.blob();

                // Create a download link
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;

                // Generate filename from URL or use timestamp
                const filename = imgSrc.split('/').pop() || `friendle-photo-${Date.now()}.jpg`;
                a.download = filename;

                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);

                showNotification('Photo downloaded successfully', 'success');
            } catch (error) {
                console.error('Error downloading image:', error);
                showNotification('Failed to download photo', 'error');
            }
        };

        window.shareImage = async function() {
            try {
                const imgSrc = document.getElementById('modal-image').src;
                if (!imgSrc) return;

                // Check if Web Share API is available
                if (navigator.share) {
                    // Fetch the image as a blob for native sharing
                    const response = await fetch(imgSrc);
                    const blob = await response.blob();
                    const filename = imgSrc.split('/').pop() || `friendle-photo-${Date.now()}.jpg`;
                    const file = new File([blob], filename, { type: blob.type });

                    await navigator.share({
                        files: [file],
                        title: 'Friendle Photo',
                        text: 'Check out this photo from Friendle!'
                    });

                    showNotification('Photo shared successfully', 'success');
                } else {
                    // Fallback for desktop browsers - show share options modal
                    showShareOptionsModal(imgSrc);
                }
            } catch (error) {
                // User cancelled or error occurred
                if (error.name !== 'AbortError') {
                    console.error('Error sharing image:', error);
                    showNotification('Failed to share photo', 'error');
                }
            }
        };

        window.showShareOptionsModal = function(imageUrl) {
            const encodedUrl = encodeURIComponent(imageUrl);
            const shareText = encodeURIComponent('Check out this photo from Friendle!');

            const shareOptions = `
                <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 15px;">
                    <button class="btn" onclick="window.open('https://www.facebook.com/sharer/sharer.php?u=${encodedUrl}', '_blank'); closeShareModal();">
                        Share on Facebook
                    </button>
                    <button class="btn" onclick="window.open('https://twitter.com/intent/tweet?url=${encodedUrl}&text=${shareText}', '_blank'); closeShareModal();">
                        Share on Twitter
                    </button>
                    <button class="btn" onclick="window.open('https://wa.me/?text=${shareText}%20${encodedUrl}', '_blank'); closeShareModal();">
                        Share on WhatsApp
                    </button>
                    <button class="btn btn-secondary" onclick="copyImageLinkToClipboard('${imageUrl}'); closeShareModal();">
                         Copy Link
                    </button>
                </div>
            `;

            showModal('Share Photo', shareOptions);
        };

        window.copyImageLinkToClipboard = async function(url) {
            try {
                await navigator.clipboard.writeText(url);
                showNotification('Link copied to clipboard', 'success');
            } catch (error) {
                console.error('Error copying to clipboard:', error);
                showNotification('Failed to copy link', 'error');
            }
        };

        window.closeShareModal = function() {
            const overlay = document.querySelector('.modal-overlay[style*="display: flex"]');
            if (overlay && !overlay.id.includes('image-modal')) {
                overlay.style.display = 'none';
            }
        };
        window.openMap = (lat, lng) => window.open(`https://www.google.com/maps?q=${lat},${lng}`, '_blank');
window.findNearbyPlaces = async function() {
            if (!navigator.geolocation) {
                return showNotification('Geolocation not supported on this device', 'error');
            }

            const context = getCurrentChatContext();

            if (context.type === 'none') {
                return showNotification('This feature is only available in chats', 'error');
            }

            const permission = await checkLocationPermission();

            if (permission === 'denied') {
                alert('Location access is blocked. Please enable it in your browser settings:\n\n1. Click the lock/info icon in the address bar\n2. Find "Location" permissions\n3. Change to "Allow"\n4. Reload the page');
                return;
            }

            if (permission === 'prompt') {
                openLocationPermissionModal();
                return;
            }

            console.log(' Finding nearby places in context:', context.type);

            // Show loading state
            const searchBtn = document.getElementById('search-btn');
            if (searchBtn) searchBtn.classList.add('loading');

            showNotification('Finding nearby places...');

            navigator.geolocation.getCurrentPosition(
                async (pos) => {
                    const lat = pos.coords.latitude;
                    const lng = pos.coords.longitude;
                    
                    const activity = activities.find(a => a.id === context.data.activity_id);
                    const activityName = activity ? activity.name : 'restaurants';
                    
                    const searchUrl = `https://www.google.com/maps/search/${encodeURIComponent(activityName)}/@${lat},${lng},15z`;
                    
                    try {
    if (context.type === 'event') {
        // EVENT CHAT
        const { data, error } = await supabase
            .from('event_messages')
            .insert({
                event_id: context.id,
                sender_id: currentUser.id,
                content: ` <a href="${searchUrl}" target="_blank" rel="noopener noreferrer" style="color: #667eea; text-decoration: underline; font-weight: 500;">Find nearby ${activityName} spots</a>`
            })
            .select(`*, sender:profiles(id, name, avatar)`)
            .single();
        
        if (error) throw error;
        
        appendMessage(data);
        
        const channel = supabase.channel(`event_${context.id}`);
        await channel.send({
            type: 'broadcast',
            event: 'new_message',
            payload: {
                id: data.id,
                sender_id: currentUser.id,
                sender_name: currentUser.name,
                sender_avatar: currentUser.avatar,
                content: data.content,
                created_at: data.created_at
            }
        });

    } else if (context.type === 'circle') {
        // CIRCLE CHAT
        const { data, error } = await supabase
            .from('circle_messages')
            .insert({
                circle_id: context.id,
                sender_id: currentUser.id,
                content: ` <a href="${searchUrl}" target="_blank" rel="noopener noreferrer" style="color: #667eea; text-decoration: underline; font-weight: 500;">Find nearby ${activityName} spots</a>`
            })
            .select(`*, sender:profiles(id, name, avatar)`)
            .single();

        if (error) throw error;

        appendMessage(data);

        const channel = supabase.channel(`circle_chat_${context.id}`);
        await channel.send({
            type: 'broadcast',
            event: 'new_circle_message',
            payload: {
                id: data.id,
                sender_id: currentUser.id,
                sender_name: currentUser.name,
                sender_avatar: currentUser.avatar,
                content: data.content,
                created_at: data.created_at
            }
        });
    }

    showNotification('Search link shared!');
} catch (error) {
                        console.error('Error sharing nearby places:', error);
                        showNotification('Failed to share search. Please try again.', 'error');
                    } finally {
                        // Remove loading state
                        if (searchBtn) searchBtn.classList.remove('loading');
                    }
                },
                (error) => {
                    // Remove loading state
                    if (searchBtn) searchBtn.classList.remove('loading');

                    let errorMessage = 'Could not get location';
                    if (error.code === error.PERMISSION_DENIED) {
                        errorMessage = 'Location permission denied. Please enable location access in your browser settings.';
                    } else if (error.code === error.POSITION_UNAVAILABLE) {
                        errorMessage = 'Location information unavailable. Please try again.';
                    } else if (error.code === error.TIMEOUT) {
                        errorMessage = 'Location request timed out. Please try again.';
                    }
                    showNotification(errorMessage, 'error');
                },
                { enableHighAccuracy: true, timeout: 5000, maximumAge: 30000 }
            );
        }
        
// Legacy function - badges are now shown on individual match cards
async function updateNotificationBadge() {
    // No-op: Badges are now displayed on individual match cards instead of nav tab
    console.log('Badge updates now handled per-card in displayMatches');
}

// Removed: markMatchAsRead() - deprecated with match chat system

async function markEventAsRead(eventId) {
    try {
        // Update last_read_at to now (backwards compatible if column doesn't exist)
        const { error } = await supabase
            .from('event_participants')
            .update({ last_read_at: new Date().toISOString() })
            .eq('event_id', eventId)
            .eq('profile_id', currentUser.id);

        if (error) {
            // Silently fail if column doesn't exist yet
            if (error.code === '42703') {
                console.log('Event read tracking not available yet - run migration to enable');
                return;
            }
            throw error;
        }

        console.log(' Marked event as read:', eventId);

        // Refresh match list to update badges
        if (window.location.hash === '#matches') {
            await loadMatches();
        }

    } catch (error) {
        console.error('Error marking event as read:', error);
    }
}

// Calculate unread badge for a specific match
async function getMatchUnreadCount(matchId, lastReadAt) {
    try {
        if (!lastReadAt) return 0;

        // Get latest message in this match
        const { data: latestMessage, error } = await supabase
            .from('match_messages')
            .select('created_at, sender_id')
            .eq('match_id', matchId)
            .order('created_at', { ascending: false })
            .limit(1)
            .maybeSingle();

        if (error) {
            console.error('Error checking match messages:', error);
            return 0;
        }

        // If there's a message newer than last_read_at and it's not from current user
        if (latestMessage &&
            new Date(latestMessage.created_at) > new Date(lastReadAt) &&
            latestMessage.sender_id !== currentUser.id) {
            return 1;
        }

        return 0;
    } catch (error) {
        console.error('Error getting match unread count:', error);
        return 0;
    }
}

// Calculate unread badge for a specific event
async function getEventUnreadCount(eventId, lastReadAt) {
    try {
        if (!lastReadAt) return 0;

        // Get latest message in this event
        const { data: latestMessage, error } = await supabase
            .from('event_messages')
            .select('created_at, sender_id')
            .eq('event_id', eventId)
            .order('created_at', { ascending: false })
            .limit(1)
            .maybeSingle();

        if (error) {
            console.error('Error checking event messages:', error);
            return 0;
        }

        // If there's a message newer than last_read_at and it's not from current user
        if (latestMessage &&
            new Date(latestMessage.created_at) > new Date(lastReadAt) &&
            latestMessage.sender_id !== currentUser.id) {
            return 1;
        }

        return 0;
    } catch (error) {
        console.error('Error getting event unread count:', error);
        return 0;
    }
}

// Calculate unread badge for a specific circle
async function getCircleUnreadCount(circleId, lastReadAt) {
    try {
        if (!lastReadAt) return 0;

        // Get latest message in this circle
        const { data: latestMessage, error } = await supabase
            .from('circle_messages')
            .select('created_at, sender_id')
            .eq('circle_id', circleId)
            .order('created_at', { ascending: false })
            .limit(1)
            .maybeSingle();

        if (error) {
            console.error('Error checking circle messages:', error);
            return 0;
        }

        // If there's a message newer than last_read_at and it's not from current user
        if (latestMessage &&
            new Date(latestMessage.created_at) > new Date(lastReadAt) &&
            latestMessage.sender_id !== currentUser.id) {
            return 1;
        }

        return 0;
    } catch (error) {
        console.error('Error getting circle unread count:', error);
        return 0;
    }
}

        // Track navigation history for proper back button behavior
        let previousPage = localStorage.getItem('friendle_previous_page') || 'matches'; // Restore or default to matches

        window.showPage = async function(pageId) {
    // Track current page before navigating
    const currentPage = document.querySelector('.page.active')?.id;
    // Only update previousPage if coming from a valid app page (not onboarding/welcome)
    if (currentPage && currentPage !== pageId && currentPage !== 'onboarding' && currentPage !== 'welcome') {
        previousPage = currentPage;
        // Persist previousPage for refresh scenarios
        localStorage.setItem('friendle_previous_page', previousPage);
    }

    // Clean up subscriptions when leaving chat
if (pageId !== 'chat') {
    if (eventMessageSubscription) {
        supabase.removeChannel(eventMessageSubscription);
        const index1 = allActiveSubscriptions.indexOf(eventMessageSubscription);
        if (index1 > -1) allActiveSubscriptions.splice(index1, 1);
        eventMessageSubscription = null;
        currentEvent = null;
    }
    currentMatchId = null; // Clear match ID when leaving chat
    localStorage.removeItem('friendle_current_chat_context'); // Clear saved chat context
    document.getElementById('event-details').style.display = 'block';
}
    
    localStorage.setItem('friendle_current_page', pageId);
    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
    document.getElementById(pageId).classList.add('active');
    document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
    document.querySelector(`.nav-item[onclick="showPage('${pageId}')"]`)?.classList.add('active');
    
    if (pageId === 'circles') renderCircles();
if (pageId === 'activities') {
    // Scroll to top to ensure page is fully visible
    document.getElementById('activities').scrollTop = 0;
    await populateCircleSelector();
}
if (pageId === 'matches') {
    await loadMatches();
}
if (pageId === 'events') {
    await loadEvents();
}
if (pageId === 'settings') {
    initNotificationSettings();
    initHelpTutorials();
    initActivityInterests();
    initAdvancedSettings();
    initBlockedUsers();
}

    // Check and show tutorial for first-time users
    await checkAndShowTutorial(pageId);
}

        // Navigate back to the previous page (used from chat back button and event completion)
        window.goToPreviousPage = async function() {
            await showPage(previousPage);
        }

        // Export user data for GDPR compliance
        window.exportData = async function() {
            try {
                const user = supabase.auth.getUser ? await supabase.auth.getUser() : null;
                const userId = user?.data?.user?.id;

                // Gather all user data
                const exportData = {
                    exportDate: new Date().toISOString(),
                    user: JSON.parse(localStorage.getItem('friendle_user') || 'null'),
                    preferences: {
                        lastCircle: localStorage.getItem('friendle_last_circle'),
                        activityCounts: JSON.parse(localStorage.getItem('friendle_activity_counts') || '{}'),
                        matches: JSON.parse(localStorage.getItem('friendle_matches') || '[]')
                    }
                };

                // Fetch user's circles and activities from Supabase if logged in
                if (userId) {
                    const { data: circles } = await supabase
                        .from('circles')
                        .select('*')
                        .eq('user_id', userId);

                    const { data: activities } = await supabase
                        .from('activities')
                        .select('*')
                        .eq('user_id', userId);

                    exportData.circles = circles || [];
                    exportData.activities = activities || [];
                }

                // Create and download JSON file
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `friendle-data-export-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                alert('Your data has been exported successfully!');
            } catch (error) {
                console.error('Export error:', error);
                alert('Failed to export data. Please try again.');
            }
        };

        // Delete all local data
        window.resetApp = async () => {
            const confirmed = confirm(
                'DELETE ALL YOUR DATA?\n\n' +
                'This will permanently delete:\n' +
                ' All your circles and groups\n' +
                ' All your activities and matches\n' +
                ' All your preferences and settings\n' +
                ' Your profile information\n\n' +
                'This action CANNOT be undone!\n\n' +
                'Are you absolutely sure you want to continue?'
            );

            if (confirmed) {
                const doubleCheck = confirm(
                    'FINAL WARNING!\n\n' +
                    'You are about to delete everything. This is your last chance to cancel.\n\n' +
                    'Click OK to delete all data, or Cancel to keep your data.'
                );

                if (doubleCheck) {
                    try {
                        // Get current user before deleting
                        const currentUser = await getCurrentUser();
                        if (!currentUser) {
                            throw new Error('No user logged in');
                        }

                        // Call database function to delete all user data
                        const { error } = await supabase.rpc('delete_user_account', {
                            user_id: currentUser.id
                        });

                        if (error) {
                            console.error('Error deleting account:', error);
                            throw error;
                        }

                        // Sign out the user
                        await supabase.auth.signOut();

                        // Clear local storage
                        localStorage.clear();

                        alert('All data has been deleted. The app will now reload.');
                        location.reload();
                    } catch (error) {
                        console.error('Failed to delete account:', error);
                        alert('Failed to delete account: ' + error.message + '\n\nPlease try again or contact support.');
                    }
                }
            }
        };

        // Toggle Notification Settings section
        window.toggleNotificationSettings = function() {
            const content = document.getElementById('notification-settings-content');
            const arrow = document.getElementById('notification-settings-arrow');
            const isExpanded = content.style.maxHeight && content.style.maxHeight !== '0px';

            if (isExpanded) {
                // Collapse
                content.style.maxHeight = '0';
                arrow.style.transform = 'rotate(0deg)';
                localStorage.setItem('notification_settings_expanded', 'false');
            } else {
                // Expand - set to scrollHeight to animate smoothly
                content.style.maxHeight = content.scrollHeight + 'px';
                arrow.style.transform = 'rotate(180deg)';
                localStorage.setItem('notification_settings_expanded', 'true');
            }
        };

        // Initialize Notification Settings state on page load
        window.initNotificationSettings = function() {
            const isExpanded = localStorage.getItem('notification_settings_expanded') === 'true';
            if (isExpanded) {
                const content = document.getElementById('notification-settings-content');
                const arrow = document.getElementById('notification-settings-arrow');
                if (content && arrow) {
                    content.style.maxHeight = content.scrollHeight + 'px';
                    arrow.style.transform = 'rotate(180deg)';
                }
            }
        };

        // Toggle Help & Tutorials section
        window.toggleHelpTutorials = function() {
            const content = document.getElementById('help-tutorials-content');
            const arrow = document.getElementById('help-tutorials-arrow');
            const isExpanded = content.style.maxHeight && content.style.maxHeight !== '0px';

            if (isExpanded) {
                // Collapse
                content.style.maxHeight = '0';
                arrow.style.transform = 'rotate(0deg)';
                localStorage.setItem('help_tutorials_expanded', 'false');
            } else {
                // Expand - set to scrollHeight to animate smoothly
                content.style.maxHeight = content.scrollHeight + 'px';
                arrow.style.transform = 'rotate(180deg)';
                localStorage.setItem('help_tutorials_expanded', 'true');
            }
        };

        // Initialize Help & Tutorials state on page load
        window.initHelpTutorials = function() {
            const isExpanded = localStorage.getItem('help_tutorials_expanded') === 'true';
            if (isExpanded) {
                const content = document.getElementById('help-tutorials-content');
                const arrow = document.getElementById('help-tutorials-arrow');
                if (content && arrow) {
                    content.style.maxHeight = content.scrollHeight + 'px';
                    arrow.style.transform = 'rotate(180deg)';
                }
            }
        };

        // Toggle Advanced Settings section
        window.toggleAdvancedSettings = function() {
            const content = document.getElementById('advanced-settings-content');
            const arrow = document.getElementById('advanced-settings-arrow');
            const isExpanded = content.style.maxHeight && content.style.maxHeight !== '0px';

            if (isExpanded) {
                // Collapse
                content.style.maxHeight = '0';
                arrow.style.transform = 'rotate(0deg)';
                localStorage.setItem('advanced_settings_expanded', 'false');
            } else {
                // Expand - set to scrollHeight to animate smoothly
                content.style.maxHeight = content.scrollHeight + 'px';
                arrow.style.transform = 'rotate(180deg)';
                localStorage.setItem('advanced_settings_expanded', 'true');
            }
        };

        // Activity Interests Toggle and Functions
        window.toggleActivityInterests = function() {
            const content = document.getElementById('activity-interests-content');
            const arrow = document.getElementById('activity-interests-arrow');
            const isExpanded = content.style.maxHeight && content.style.maxHeight !== '0px';

            if (isExpanded) {
                content.style.maxHeight = '0';
                arrow.style.transform = 'rotate(0deg)';
                localStorage.setItem('activity_interests_expanded', 'false');
            } else {
                content.style.maxHeight = content.scrollHeight + 'px';
                arrow.style.transform = 'rotate(180deg)';
                localStorage.setItem('activity_interests_expanded', 'true');
            }
        };

        let interestsCircleId = null;
        let interestsActivities = [];
        let interestsSelected = new Set();

        window.loadActivityInterests = async function() {
            const selector = document.getElementById('interests-circle-selector');
            interestsCircleId = selector.value;

            const gridContainer = document.getElementById('activity-interests-grid-container');
            const selectPrompt = document.getElementById('select-circle-prompt');
            const grid = document.getElementById('activity-interests-grid');
            const saveBtn = document.getElementById('save-interests-btn');

            if (!interestsCircleId) {
                gridContainer.style.display = 'none';
                selectPrompt.style.display = 'block';
                return;
            }

            selectPrompt.style.display = 'none';
            gridContainer.style.display = 'block';

            try {
                showLoader('Loading activities...');

                // Load all activities for this circle
                const allActivities = await loadActivities(interestsCircleId);
                interestsActivities = allActivities;

                // Load user's current preferences for this circle
                const { data: prefs, error } = await supabase
                    .from('preferences')
                    .select('activity_id')
                    .eq('profile_id', currentUser.id)
                    .eq('circle_id', interestsCircleId)
                    .eq('selected', true);

                if (error) throw error;

                interestsSelected = new Set((prefs || []).map(p => p.activity_id));

                // Render activities grid with selection
                grid.innerHTML = '';
                for (const activity of allActivities) {
                    const card = document.createElement('div');
                    card.className = 'activity-card';
                    if (interestsSelected.has(activity.id)) {
                        card.classList.add('selected');
                    }
                    card.dataset.activityId = activity.id;

                    card.innerHTML = `
                        <div class="activity-emoji">${activity.emoji}</div>
                        <div class="activity-name">${activity.name}</div>
                    `;

                    card.onclick = (event) => {
                        event.stopPropagation();
                        card.classList.toggle('selected');
                        if (interestsSelected.has(activity.id)) {
                            interestsSelected.delete(activity.id);
                        } else {
                            interestsSelected.add(activity.id);
                        }
                        saveBtn.style.display = 'block';
                    };

                    grid.appendChild(card);
                }

                hideLoader();

            } catch (error) {
                console.error('Error loading activity interests:', error);
                hideLoader();
                showNotification('Error loading activities', 'error');
            }
        };

        window.saveActivityInterests = async function() {
            if (!interestsCircleId) return;

            try {
                showLoader('Saving interests...');

                // Delete all existing preferences for this user and circle
                const { error: deleteError } = await supabase
                    .from('preferences')
                    .delete()
                    .eq('profile_id', currentUser.id)
                    .eq('circle_id', interestsCircleId);

                if (deleteError) throw deleteError;

                // Insert new preferences for selected activities
                if (interestsSelected.size > 0) {
                    const prefsToInsert = Array.from(interestsSelected).map(activityId => ({
                        profile_id: currentUser.id,
                        circle_id: interestsCircleId,
                        activity_id: activityId,
                        selected: true
                    }));

                    const { error: insertError } = await supabase
                        .from('preferences')
                        .insert(prefsToInsert);

                    if (insertError) throw insertError;
                }

                hideLoader();
                showNotification('Interests saved!');
                document.getElementById('save-interests-btn').style.display = 'none';

            } catch (error) {
                console.error('Error saving activity interests:', error);
                hideLoader();
                showNotification('Error saving interests', 'error');
            }
        };

        window.initActivityInterests = function() {
            const isExpanded = localStorage.getItem('activity_interests_expanded') === 'true';
            if (isExpanded) {
                const content = document.getElementById('activity-interests-content');
                const arrow = document.getElementById('activity-interests-arrow');
                if (content && arrow) {
                    content.style.maxHeight = content.scrollHeight + 'px';
                    arrow.style.transform = 'rotate(180deg)';
                }
            }

            // Populate circle selector
            const selector = document.getElementById('interests-circle-selector');
            if (selector && circles) {
                selector.innerHTML = '<option value="">Choose a circle...</option>';
                circles.forEach(circle => {
                    const option = document.createElement('option');
                    option.value = circle.id;
                    option.textContent = circle.name;
                    selector.appendChild(option);
                });
            }
        };

        // Initialize Advanced Settings state on page load
        window.initAdvancedSettings = function() {
            const isExpanded = localStorage.getItem('advanced_settings_expanded') === 'true';
            if (isExpanded) {
                const content = document.getElementById('advanced-settings-content');
                const arrow = document.getElementById('advanced-settings-arrow');
                content.style.maxHeight = content.scrollHeight + 'px';
                arrow.style.transform = 'rotate(180deg)';
            }

            // Show Samsung notification help if on Samsung Internet
            const samsungHelpSection = document.getElementById('samsung-notification-help');
            if (samsungHelpSection && isSamsungInternet()) {
                samsungHelpSection.style.display = 'block';
            }
        };

        // Toggle Blocked Users section
        window.toggleBlockedUsers = function() {
            const content = document.getElementById('blocked-users-content');
            const arrow = document.getElementById('blocked-users-arrow');
            const isExpanded = content.style.maxHeight && content.style.maxHeight !== '0px';

            if (isExpanded) {
                // Collapse
                content.style.maxHeight = '0';
                arrow.style.transform = 'rotate(0deg)';
                localStorage.setItem('blocked_users_expanded', 'false');
            } else {
                // Expand and load blocked users
                loadBlockedUsers();
                content.style.maxHeight = content.scrollHeight + 'px';
                arrow.style.transform = 'rotate(180deg)';
                localStorage.setItem('blocked_users_expanded', 'true');
            }
        };

        // Initialize Blocked Users state on page load
        window.initBlockedUsers = function() {
            const isExpanded = localStorage.getItem('blocked_users_expanded') === 'true';
            if (isExpanded) {
                const content = document.getElementById('blocked-users-content');
                const arrow = document.getElementById('blocked-users-arrow');
                if (content && arrow) {
                    loadBlockedUsers();
                    content.style.maxHeight = content.scrollHeight + 'px';
                    arrow.style.transform = 'rotate(180deg)';
                }
            }
        };

        // Load blocked users list
        window.loadBlockedUsers = async function() {
            try {
                console.log('[loadBlockedUsers] Starting to load blocked users...');

                const { data, error } = await supabase
                    .from('blocked_users')
                    .select(`
                        id,
                        blocked_id,
                        reason,
                        created_at,
                        blocked_profile:profiles!blocked_users_blocked_id_fkey(id, name, avatar)
                    `)
                    .eq('blocker_id', currentUser.id)
                    .order('created_at', { ascending: false });

                if (error) throw error;

                console.log('[loadBlockedUsers] Fetched data:', data);

                const listContainer = document.getElementById('blocked-users-list');

                if (!data || data.length === 0) {
                    console.log('[loadBlockedUsers] No blocked users, showing empty state');
                    listContainer.innerHTML = `
                        <div id="no-blocked-users" style="text-align: center; padding: 20px; font-size: 0.85em; color: var(--text-tertiary);">
                            No blocked users
                        </div>
                    `;
                } else {
                    console.log('[loadBlockedUsers] Found', data.length, 'blocked users');
                    listContainer.innerHTML = data.map(block => {
                        const profile = block.blocked_profile;
                        const avatar = profile.avatar ?
                            (profile.avatar.includes('supabase') ?
                                profile.avatar :
                                `<div class="avatar-emoji">${profile.avatar}</div>`) :
                            '<div class="avatar-emoji"></div>';

                        return `
                            <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: var(--bg-secondary); border-radius: 8px; margin-bottom: 10px;">
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <div class="profile-picture-small">
                                        ${avatar.includes('supabase') ?
                                            `<img src="${avatar}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 50%;">` :
                                            avatar}
                                    </div>
                                    <div>
                                        <div style="font-weight: 600; color: var(--text-primary);">${profile.name}</div>
                                        ${block.reason ? `<div style="font-size: 0.8em; color: var(--text-tertiary); margin-top: 2px;">${block.reason}</div>` : ''}
                                    </div>
                                </div>
                                <button class="btn btn-secondary" style="padding: 6px 12px; font-size: 0.85em;" onclick="unblockUser('${block.blocked_id}', '${profile.name}')">
                                    Unblock
                                </button>
                            </div>
                        `;
                    }).join('');
                }

                // Force a reflow to ensure DOM updates
                void listContainer.offsetHeight;

                // Recalculate container height if expanded
                const content = document.getElementById('blocked-users-content');
                if (content && content.style.maxHeight && content.style.maxHeight !== '0px') {
                    // Section is expanded, update height to fit new content
                    // Use requestAnimationFrame to ensure DOM has updated
                    requestAnimationFrame(() => {
                        const newHeight = content.scrollHeight;
                        console.log('[loadBlockedUsers] Updating height to:', newHeight);
                        content.style.maxHeight = newHeight + 'px';
                    });
                }

                console.log('[loadBlockedUsers] Complete');
            } catch (error) {
                console.error('Error loading blocked users:', error);
                showNotification('Failed to load blocked users');
            }
        };

        // Open block user modal
        window.openBlockUserModal = function(userId, userName) {
            document.getElementById('block-user-id').value = userId;
            document.getElementById('block-user-name').textContent = userName;
            document.getElementById('block-reason').value = '';
            document.getElementById('block-user-modal-overlay').style.display = 'flex';
        };

        // Close block user modal
        window.closeBlockUserModal = function() {
            document.getElementById('block-user-modal-overlay').style.display = 'none';
        };

        // Confirm block user
        window.confirmBlockUser = async function() {
            const userId = document.getElementById('block-user-id').value;
            const userName = document.getElementById('block-user-name').textContent;
            const reason = document.getElementById('block-reason').value.trim();

            try {
                const { error } = await supabase
                    .from('blocked_users')
                    .insert({
                        blocker_id: currentUser.id,
                        blocked_id: userId,
                        reason: reason || null
                    });

                if (error) throw error;

                showNotification(`${userName} has been blocked`);
                closeBlockUserModal();

                // Refresh current page to hide blocked user
                const currentPage = localStorage.getItem('friendle_current_page');
                if (currentPage === 'circles') renderCircles();
                if (currentPage === 'matches') loadMatches();
                if (currentPage === 'settings') loadBlockedUsers();

            } catch (error) {
                console.error('Error blocking user:', error);
                if (error.code === '23505') {
                    showNotification('User is already blocked');
                } else {
                    showNotification('Failed to block user');
                }
            }
        };

        // Unblock user
        window.unblockUser = async function(userId, userName) {
            if (!confirm(`Unblock ${userName}? They will be able to see your profile and interact with you again.`)) {
                return;
            }

            try {
                console.log('[unblockUser] Starting unblock for:', userId, userName);

                const { error } = await supabase
                    .from('blocked_users')
                    .delete()
                    .eq('blocker_id', currentUser.id)
                    .eq('blocked_id', userId);

                if (error) throw error;

                console.log('[unblockUser] Delete successful, showing notification');
                showNotification(`${userName} has been unblocked`);

                console.log('[unblockUser] Calling loadBlockedUsers...');
                // Wait for blocked users list to refresh
                await loadBlockedUsers();
                console.log('[unblockUser] loadBlockedUsers completed');

                // Refresh current page to show unblocked user
                const currentPage = localStorage.getItem('friendle_current_page');
                if (currentPage === 'circles') renderCircles();
                if (currentPage === 'matches') loadMatches();

            } catch (error) {
                console.error('Error unblocking user:', error);
                showNotification('Failed to unblock user');
            }
        };

        // Open report modal
        window.openReportModal = function(contentType, contentId, contentName, senderId = null) {
            document.getElementById('report-content-type').value = contentType;
            document.getElementById('report-content-id').value = contentId;
            document.getElementById('report-content-name').value = contentName;
            document.getElementById('report-sender-id').value = senderId || '';
            document.getElementById('report-type-text').textContent = contentType.charAt(0).toUpperCase() + contentType.slice(1);
            document.getElementById('report-category').value = '';
            document.getElementById('report-details').value = '';
            document.getElementById('report-also-block').checked = false;
            document.getElementById('report-modal-overlay').style.display = 'flex';
        };

        // Close report modal
        window.closeReportModal = function() {
            document.getElementById('report-modal-overlay').style.display = 'none';
        };

        // Submit report
        window.submitReport = async function() {
            const contentType = document.getElementById('report-content-type').value;
            const contentId = document.getElementById('report-content-id').value;
            const contentName = document.getElementById('report-content-name').value;
            const senderId = document.getElementById('report-sender-id').value;
            const category = document.getElementById('report-category').value;
            const details = document.getElementById('report-details').value.trim();
            const alsoBlock = document.getElementById('report-also-block').checked;

            console.log('[submitReport] Submitting report:', {
                contentType,
                contentId,
                contentName,
                senderId,
                category,
                alsoBlock
            });

            if (!category) {
                showNotification('Please select a reason for your report');
                return;
            }

            try {
                // Submit report
                const { error: reportError } = await supabase
                    .from('reports')
                    .insert({
                        reporter_id: currentUser.id,
                        reported_type: contentType,
                        reported_id: contentId,
                        reason_category: category,
                        reason_details: details || null,
                        status: 'pending'
                    });

                if (reportError) throw reportError;

                console.log('[submitReport] Report submitted successfully');

                // If user wants to also block
                if (alsoBlock) {
                    // Determine who to block:
                    // - If reporting a user directly  block that user
                    // - If reporting a message  block the message sender
                    // - If reporting circle/event  skip blocking (no user to block)
                    let userIdToBlock = null;

                    if (contentType === 'user') {
                        userIdToBlock = contentId;
                    } else if (contentType === 'message' && senderId) {
                        userIdToBlock = senderId;
                    }

                    if (userIdToBlock) {
                        console.log('[submitReport] Also blocking user:', userIdToBlock);

                        const { error: blockError } = await supabase
                            .from('blocked_users')
                            .insert({
                                blocker_id: currentUser.id,
                                blocked_id: userIdToBlock,
                                reason: `Reported: ${category}`
                            });

                        if (blockError) {
                            if (blockError.code === '23505') {
                                console.log('[submitReport] User already blocked');
                            } else {
                                console.error('[submitReport] Error blocking user:', blockError);
                            }
                        } else {
                            console.log('[submitReport] User blocked successfully');
                        }
                    } else {
                        console.log('[submitReport] No user to block for contentType:', contentType);
                    }
                }

                showNotification('Thank you for your report. We will review it shortly.');
                closeReportModal();

                // Refresh current page if needed
                if (alsoBlock && (contentType === 'user' || (contentType === 'message' && senderId))) {
                    console.log('[submitReport] Refreshing page after block');
                    const currentPage = localStorage.getItem('friendle_current_page');
                    if (currentPage === 'circles') renderCircles();
                    if (currentPage === 'matches') loadMatches();
                    if (currentPage === 'settings') await loadBlockedUsers();
                }

            } catch (error) {
                console.error('Error submitting report:', error);
                showNotification('Failed to submit report. Please try again.');
            }
        };

        // Invite System
        window.showInviteModal = function(circleId) {
            const baseUrl = window.location.href.split('?')[0];
            const inviteToken = `invite_${circleId}_${Date.now()}`;
            const inviteLink = `${baseUrl}?invite_token=${inviteToken}`;
            document.getElementById('invite-link').value = inviteLink;
            document.getElementById('invite-modal-overlay').style.display = 'flex';
        }
        window.closeInviteModal = () => document.getElementById('invite-modal-overlay').style.display = 'none';
        window.copyInviteLink = function() {
            const linkInput = document.getElementById('invite-link');
            linkInput.select();
            document.execCommand('copy');
            showNotification('Link copied to clipboard!');
        }
        function processInvite() {
            const token = sessionStorage.getItem('pending_invite');
            if (token && currentUser) {
                const allCircles = JSON.parse(localStorage.getItem('friendle_circles') || '[]');
                const circleId = parseInt(token.split('_')[1]);
                const circle = allCircles.find(c => c.id === circleId);
                if (circle && !circle.members.some(m => m.id === currentUser.id)) {
                    circle.members.push(currentUser);
                    localStorage.setItem('friendle_circles', JSON.stringify(allCircles));
                    circles = allCircles; // Make sure our in-memory list is updated
                    showNotification(`Invite accepted! You've joined "${circle.name}".`);
                }
                sessionStorage.removeItem('pending_invite');
                renderCircles(); // Re-render to show the new circle membership
            }
}

 async function initApp() {
    // Check if this is a password recovery flow (from email link)
    const hashParams = new URLSearchParams(window.location.hash.substring(1));
    const isPasswordRecovery = hashParams.get('type') === 'recovery';

    if (isPasswordRecovery) {
        // Show loader with recovery message
        showLoader('Processing password reset...');
        // Show auth page immediately so user doesn't see other content
        document.getElementById('auth').classList.add('active');
        // The onAuthStateChange listener will handle showing the password reset form
        // when the PASSWORD_RECOVERY event fires
        return;
    }

    // Show loader immediately while checking auth
    showLoader('Loading...');

    const urlParams = new URLSearchParams(window.location.search);
    const inviteCode = urlParams.get('invite_code');

    // Store invite code for after authentication (in localStorage so it survives PWA installation)
    if (inviteCode) {
        InviteCodeStorage.set(inviteCode);
    }
    // Note: We'll clean up URL later, after checking for chat parameters

    // Check for existing Supabase auth session
    const { data: { session } } = await supabase.auth.getSession();

    if (session) {
        // CRITICAL: First load the user profile - this is auth-critical
        // If the profile doesn't exist or there's an auth error, user should be signed out
        try {
            const { data: profileData, error } = await supabase
                .from('profiles')
                .select('*')
                .eq('id', session.user.id)
                .single();

            if (error) {
                console.error('Profile load error:', error);
                throw error;
            }

            currentUser = profileData;
        } catch (error) {
            // Profile loading failed - this IS an auth-critical error
            // Sign out only for profile-related failures (e.g., profile doesn't exist)
            console.error('Auth-critical error loading profile:', error);
            await supabase.auth.signOut();
            hideLoader();
            showOnboarding();
            return; // Exit initApp entirely
        }

        // NON-CRITICAL: Load app data - errors here should NOT sign out the user
        // Network issues, temporary failures, etc. should be handled gracefully
        try {
            // Load default activities AFTER authentication is confirmed
            // This ensures RLS policies allow the query to succeed
            await loadDefaultActivities();

            if ('Notification' in window && Notification.permission === 'default') {
                // Show friendly custom prompt before browser prompt
                showNotificationPrompt();
            }

            // SECURITY: Store minimal data - only user ID in localStorage, UI data in sessionStorage
            SecureStorage.setUserId(currentUser.id);
            SecureStorage.setSessionData(currentUser);

            await renderCircles();
            window.appState.circlesLoaded = true;
            console.log(' Circles loaded, updating app state');

            await loadMatches();
            window.appState.matchesLoaded = true;
            console.log(' Matches loaded, updating app state');

            await updateNotificationBadge();

            // Mark app as fully initialized and data loaded
            window.appState.initialized = true;
            window.appState.dataLoaded = true;
            console.log(' App fully initialized:', JSON.stringify(window.appState));

            const lastPage = localStorage.getItem('friendle_current_page') || 'activities';

            // Check if we should open a chat from notification click
            const openChatId = urlParams.get('openChat');
            const openChatType = urlParams.get('chatType');

            console.log(' Checking for chat to open:', { openChatId, openChatType, matches: matches?.length });

            if (openChatId && openChatType) {
                console.log(' Found chat to open from notification!');
                console.log('   - Chat Type:', openChatType);
                console.log('   - Chat ID:', openChatId);
                console.log('   - Matches loaded:', matches?.length || 0);

                // Clean up URL (remove all query parameters)
                window.history.replaceState({}, document.title, window.location.pathname);

                // Set previousPage based on chat type so back button leads to the correct page
                if (openChatType === 'match') {
                    previousPage = 'matches';
                } else if (openChatType === 'event') {
                    previousPage = 'events';
                } else if (openChatType === 'circle') {
                    previousPage = 'circles';
                }
                localStorage.setItem('friendle_previous_page', previousPage);
                console.log(' Set previousPage for back button:', previousPage);

                // DON'T show any other page - let the chat function handle the page display
                // This prevents race conditions where we might navigate away

                // Wait for everything to be ready, then open chat (critical for iOS)
                console.log(' Waiting for app to be fully ready before opening chat from URL...');
                try {
                    await window.waitForAppReady(30000); // 30 second timeout for slower devices
                    console.log(' App ready, opening chat from URL');

                    // Add retry logic for robustness
                    const maxRetries = 3;
                    for (let attempt = 1; attempt <= maxRetries; attempt++) {
                        try {
                            console.log(` Attempt ${attempt}/${maxRetries}: Opening chat...`, openChatType, openChatId);

                            if (openChatType === 'match') {
                                // Match chat deprecated - redirect to matches page
                                await loadMatches();
                                showPage('matches');
                            } else if (openChatType === 'event') {
                                await openEventChat(openChatId);
                            } else if (openChatType === 'circle') {
                                await openCircleChat(openChatId);
                            }

                            console.log(' Chat opened successfully on attempt', attempt);
                            break; // Success, exit retry loop

                        } catch (error) {
                            console.error(` Attempt ${attempt} failed:`, error);
                            if (attempt < maxRetries) {
                                const delayMs = 500 * Math.pow(2, attempt - 1);
                                console.log(` Waiting ${delayMs}ms before retry...`);
                                await new Promise(resolve => setTimeout(resolve, delayMs));
                            } else {
                                throw error; // Final attempt failed
                            }
                        }
                    }
                } catch (error) {
                    console.error(' Error opening chat from notification:', error);
                    console.error(' Error stack:', error.stack);
                    console.error(' App state at error:', window.appState);
                    // On error, show matches page as fallback
                    showPage('matches');
                    showNotification('Could not open chat. Please try again from the Matches tab.', 'error');
                }
            } else {
                // Restore chat page on refresh if we have saved context
                const savedChatContext = localStorage.getItem('friendle_current_chat_context');

                if (savedChatContext && lastPage === 'chat') {
                    try {
                        const chatContext = JSON.parse(savedChatContext);
                        if (chatContext.type === 'circle') {
                            await openCircleChat(chatContext.id);
                        } else if (chatContext.type === 'match') {
                            // Match chat deprecated - redirect to matches page
                            await loadMatches();
                            showPage('matches');
                        } else if (chatContext.type === 'event') {
                            await openEventChat(chatContext.id);
                        } else {
                            // Invalid context type, fallback to matches
                            showPage('matches');
                        }
                    } catch (error) {
                        console.error('Error restoring chat context:', error);
                        // On error, show matches page as fallback
                        showPage('matches');
                    }
                } else {
                    showPage(lastPage);
                }
            }

            updateProfile();
            await processInviteCode();

            hideLoader(); // Hide loader after everything loads

            // Track visit for PWA install prompt
            trackPWAVisit();

            // PWA prompt now shown on sign-in page (before login) to reduce friction
            // Users install app first, then sign in once instead of twice

        } catch (error) {
            // Non-critical initialization error - DO NOT sign out the user
            // This handles network issues, temporary database failures, etc.
            console.error('Non-critical initialization error:', error);
            hideLoader();

            // Show the app with whatever data we have - user stays logged in
            const lastPage = localStorage.getItem('friendle_current_page') || 'activities';
            showPage(lastPage);

            // Mark app as initialized even with partial data
            window.appState.initialized = true;

            // Show a user-friendly error message
            showNotification('Some features may be unavailable. Pull down to refresh.', 'error');
        }
    } else {
        // No authenticated session
        currentUser = null;
        // SECURITY: Clear all stored user data
        SecureStorage.clearAll();

        // Check if there are chat parameters from notification click
        const openChatId = urlParams.get('openChat');
        const openChatType = urlParams.get('chatType');

        if (openChatId && openChatType) {
            // Store them for after login
            sessionStorage.setItem('pending_chat_id', openChatId);
            sessionStorage.setItem('pending_chat_type', openChatType);
            console.log(' Stored pending chat for after login:', { openChatId, openChatType });

            // Clean up URL parameters
            window.history.replaceState({}, document.title, window.location.pathname);
        }

        hideLoader();
        showOnboarding();
    }
}

async function showOnboarding() {
    // Check if there's a pending invite (now uses localStorage with expiry)
    const inviteCode = InviteCodeStorage.get();

    if (inviteCode) {
        // Show invite context
        document.getElementById('invite-context').style.display = 'block';
        document.getElementById('generic-pitch').style.display = 'none';
        document.getElementById('onboarding-cta').textContent = 'Join Circle';

        // Try to load circle name
        try {
            const { data: circle, error } = await supabase
                .from('circles')
                .select('name')
                .eq('code', inviteCode)
                .single();

            if (circle) {
                document.getElementById('invite-circle-name').textContent = `"${circle.name}"`;
            } else {
                document.getElementById('invite-circle-name').textContent = 'this circle';
            }
        } catch (error) {
            console.error('Error loading circle name:', error);
            document.getElementById('invite-circle-name').textContent = 'this circle';
        }
    } else {
        // Show generic pitch
        document.getElementById('invite-context').style.display = 'none';
        document.getElementById('generic-pitch').style.display = 'block';
        document.getElementById('onboarding-cta').textContent = 'Get Started';
    }

    showPage('onboarding');

    // Show PWA install prompt on sign-in page to reduce friction
    // UNLESS there's a pending invite code - in that case, wait until after they join
    // This prevents localStorage issues on iOS where PWA has separate storage from Safari
    const hasPendingInvite = InviteCodeStorage.get();
    if (!hasPendingInvite) {
        setTimeout(() => {
            showPWAPrompt(true);
        }, 1000);
    } else {
        console.log(' Skipping PWA prompt due to pending invite - will show after circle join');
    }
}

// Global error handlers - catch unexpected errors
window.addEventListener('error', (event) => {
    console.error('Global error caught:', event.error);
    
    // Don't show notification for script loading errors (external resources)
    if (event.message && event.message.includes('Script error')) {
        return;
    }
    
    // Show user-friendly error message
    showNotification('Something went wrong. Please refresh the page if issues persist.', 'error');
    
    // Hide any active loaders
    hideLoader();
});

window.addEventListener('unhandledrejection', (event) => {
    console.error('Unhandled promise rejection:', event.reason);
    
    // Show user-friendly error message
    showNotification('An error occurred. Please try again.', 'error');
    
    // Hide any active loaders
    hideLoader();
    
    // Prevent default browser console error
    event.preventDefault();
});

// Detect network connectivity issues
window.addEventListener('online', () => {
    showNotification('Connection restored!');
});

window.addEventListener('offline', () => {
    showNotification('No internet connection. Some features may not work.', 'error');
    hideLoader(); // Hide any pending loaders
});

//  Run after DOM is ready
document.addEventListener("DOMContentLoaded", () => {
  console.log("DOM ready, attaching avatar clicks...");

  // Handle Stripe payment redirect returns
  const urlParams = new URLSearchParams(window.location.search);
  const purchaseStatus = urlParams.get('purchase');

  if (purchaseStatus === 'success') {
    // Remove query params from URL without refreshing
    window.history.replaceState({}, document.title, window.location.pathname);

    // Check for pending circle creation or join
    setTimeout(async () => {
      const pendingCreation = localStorage.getItem('pendingCircleCreation');
      const pendingJoin = localStorage.getItem('pendingCircleJoin');

      if (pendingCreation) {
        // Auto-complete circle creation
        try {
          const creationData = JSON.parse(pendingCreation);
          localStorage.removeItem('pendingCircleCreation');

          showLoader('Creating your circle...');

          const code = generateCode();

          // Insert into circles
          const { data: circle, error } = await supabase
            .from('circles')
            .insert([{ name: creationData.name, code, created_by: currentUser.id }])
            .select()
            .single();

          if (error) throw error;

          // Add creator as a member
          await supabase.from('circle_members').insert([{
            circle_id: circle.id,
            profile_id: currentUser.id
          }]);

          // Handle custom activities
          const customActivities = defaultActivities.filter(a =>
            typeof a.id === 'string' && a.id.startsWith('temp_')
          );

          const activityIdMapping = {};

          for (const customActivity of customActivities) {
            const { data: newActivity, error: actError } = await supabase
              .from('activities')
              .insert([{
                name: customActivity.name,
                emoji: customActivity.emoji,
                category: 'custom',
                circle_id: circle.id
              }])
              .select()
              .single();

            if (!actError && newActivity) {
              activityIdMapping[customActivity.id] = newActivity.id;
            }
          }

          // Update selected IDs
          const finalSelectedIds = creationData.selectedActivityIds.map(id =>
            activityIdMapping[id] || id
          );

          // Set activity visibility
          if (finalSelectedIds.length > 0) {
            const allDefaultIds = defaultActivities
              .filter(a => !(typeof a.id === 'string' && a.id.startsWith('temp_')))
              .map(a => a.id);

            const visibilityRecords = allDefaultIds.map(activityId => ({
              circle_id: circle.id,
              activity_id: activityId,
              is_visible: finalSelectedIds.includes(activityId)
            }));

            await supabase.from('circle_activities').insert(visibilityRecords);
          }

          // Clean up temp activities
          defaultActivities = defaultActivities.filter(a =>
            !(typeof a.id === 'string' && a.id.startsWith('temp_'))
          );

          circles.push(circle);
          await renderCircles();

          hideLoader();
          showNotification(`Circle "${circle.name}" created! Share code: ${circle.code}`, 'success');

        } catch (error) {
          hideLoader();
          console.error('Error auto-creating circle:', error);
          showNotification('Payment successful, but please create your circle again.', 'error');
        }

      } else if (pendingJoin) {
        // Auto-complete circle join
        try {
          const joinData = JSON.parse(pendingJoin);
          console.log(' Payment successful - processing pending circle join:', joinData);

          // Validate timestamp is recent (within 30 minutes)
          const ageMinutes = (Date.now() - joinData.timestamp) / (1000 * 60);
          if (ageMinutes > 30) {
            console.warn(' Pending circle join is too old (', ageMinutes.toFixed(1), 'minutes). Rejecting.');
            localStorage.removeItem('pendingCircleJoin');
            throw new Error('Circle join request expired. Please try joining again.');
          }

          console.log(' Pending join timestamp valid (', ageMinutes.toFixed(1), 'minutes old)');

          showLoader('Joining circle...');

          // Find the circle by code
          const { data: circle, error } = await supabase
            .from('circles')
            .select('*')
            .eq('code', joinData.code)
            .single();

          if (error || !circle) {
            console.error(' Circle not found for code:', joinData.code);
            localStorage.removeItem('pendingCircleJoin');
            throw new Error('Circle not found');
          }

          console.log(' Found circle:', circle.name, '(ID:', circle.id, ')');

          // Check if user is already a member
          const { data: existingMember } = await supabase
            .from('circle_members')
            .select('*')
            .eq('circle_id', circle.id)
            .eq('profile_id', currentUser.id)
            .single();

          if (existingMember) {
            console.log(' User is already a member of this circle');
            localStorage.removeItem('pendingCircleJoin');
            hideLoader();
            showNotification(`You are already a member of "${circle.name}"`, 'info');
            return;
          }

          // Remove from localStorage AFTER we know circle exists
          localStorage.removeItem('pendingCircleJoin');

          // Add user to circle_members
          await supabase.from('circle_members').insert([{
            circle_id: circle.id,
            profile_id: currentUser.id
          }]);

          circles.push(circle);
          await renderCircles();

          hideLoader();
          showNotification(`Joined "${circle.name}" successfully!`, 'success');

          // Mark that user joined their first circle for PWA prompt
          markCircleJoined();

          // Clear invite code
          InviteCodeStorage.clear();

          // Show PWA install prompt after successful payment and join
          setTimeout(() => {
            showPWAPrompt();
          }, 500);

        } catch (error) {
          hideLoader();
          console.error('Error auto-joining circle:', error);
          showNotification('Payment successful, but please join the circle again.', 'error');
          // Clear invite code even on error
          InviteCodeStorage.clear();
        }

      } else {
        // No pending action, just show success
        showNotification('Payment successful! You can now create or join another circle.', 'success');
      }
    }, 1000);
  } else if (purchaseStatus === 'cancelled') {
    // Remove query params from URL without refreshing
    window.history.replaceState({}, document.title, window.location.pathname);

    console.log(' Payment cancelled - clearing all pending actions');

    // Clear any pending actions since payment was cancelled
    localStorage.removeItem('pendingCircleCreation');
    localStorage.removeItem('pendingCircleJoin');
    InviteCodeStorage.clear();

    // Show cancelled notification
    setTimeout(() => {
      showNotification('Payment cancelled. You can try again anytime.', 'info');
    }, 1000);
  }

  // Initialize auto-expanding chat input
  initMessageInput();

  const avatars = document.querySelectorAll(".avatar-option");
  console.log("Found avatars:", avatars.length);

    avatars.forEach(option => {
    option.addEventListener("click", () => {
      console.log("Avatar clicked:", option.dataset.avatar);
      avatars.forEach(o => o.classList.remove("selected"));
      option.classList.add("selected");

      // If this is in the registration form, clear any uploaded photo and reset preview
      if (option.closest('#register-form')) {
        window.registerPhotoFile = null;
        const preview = document.getElementById('register-profile-preview');
        const display = document.getElementById('register-avatar-display');
        if (preview && display) {
          preview.style.backgroundImage = '';
          display.innerHTML = option.dataset.avatar;
          display.style.fontSize = '50px';
        }
      }
    });
  });

// Create event form submission
document.getElementById('create-event-form').addEventListener('submit', createEvent);

// Edit event form submission
document.getElementById('edit-event-form').addEventListener('submit', saveEventEdits);

// Planning event form submission
document.getElementById('planning-event-form').addEventListener('submit', createPlanningEvent);

// Auto-expand collapsible sections when validation fails
document.querySelectorAll('#planning-event-form input, #planning-event-form select, #planning-event-form textarea').forEach(field => {
    field.addEventListener('invalid', function(e) {
        // Find the parent collapsible section
        const collapsibleSection = this.closest('.collapsible-section');
        if (collapsibleSection) {
            const header = collapsibleSection.querySelector('.collapsible-header');
            const content = collapsibleSection.querySelector('.collapsible-content');

            // If the section is not expanded, expand it
            if (header && content && !header.classList.contains('active')) {
                toggleCollapsible(header);
            }
        }
    });
});

// Lock details form submission
document.getElementById('lock-details-form').addEventListener('submit', lockEventDetails);

// Create poll form submission
document.getElementById('create-poll-form').addEventListener('submit', submitPoll);

window.openManageActivitiesModal = async function() {
    if (!selectedCircle) return;
    
    try {
        // Get circle-level visibility settings
const { data: circleActivities, error: visibilityError } = await supabase
    .from('circle_activities')
    .select('activity_id, is_visible')
    .eq('circle_id', selectedCircle.id);

if (visibilityError) throw visibilityError;

// Build visibility map - activities not in map use defaults (core=visible, extended=hidden)
const visibilityMap = {};
circleActivities?.forEach(ca => {
    visibilityMap[ca.activity_id] = ca.is_visible;
});
        
        const grid = document.getElementById('manage-activities-grid');
        
        // Create sections for core, extended, and custom activities
        grid.innerHTML = `
    <div style="margin-bottom: 30px;">
        <h3 style="margin-bottom: 15px; color: #555; font-size: 1.1em; font-weight: 600; border-bottom: 1px solid #f0f0f0; padding-bottom: 5px;">Core Activities</h3>
        <div class="activities-grid" id="core-activities-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;"></div>
    </div>
    <div style="margin-bottom: 30px;">
        <h3 style="margin-bottom: 15px; color: #555; font-size: 1.1em; font-weight: 600; border-bottom: 1px solid #f0f0f0; padding-bottom: 5px;">Additional Activities</h3>
        <div class="activities-grid" id="extended-activities-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;"></div>
    </div>
    <div>
        <h3 style="margin-bottom: 15px; color: #555; font-size: 1.1em; font-weight: 600; border-bottom: 1px solid #f0f0f0; padding-bottom: 5px;">Custom Activities</h3>
        <div id="custom-activities-list" style="display: flex; flex-direction: column; gap: 10px;"></div>
    </div>
`;
        
        const coreGrid = document.getElementById('core-activities-grid');
const extendedGrid = document.getElementById('extended-activities-grid');

// Get core activities from defaultActivities array
const coreActivitiesArray = defaultActivities.filter(a => coreActivityIds.includes(a.id));

// Populate core activities
if (coreActivitiesArray.length === 0) {
    coreGrid.innerHTML = '<p style="color: #999; font-size: 14px; padding: 20px; text-align: center; grid-column: 1/-1;">No default core activities available. The database needs to be seeded.</p>';
} else {
    coreActivitiesArray.forEach(activity => {
        const card = document.createElement('div');
        // Core activities visible by default unless explicitly set otherwise
        const isVisible = visibilityMap.hasOwnProperty(activity.id)
            ? visibilityMap[activity.id]
            : true;
        card.className = `activity-card ${isVisible ? 'selected' : ''}`;
        card.onclick = () => toggleActivityVisibility(card, activity.id);
        card.dataset.activityId = activity.id;
        card.innerHTML = `
            <div class="activity-emoji">${activity.emoji || ''}</div>
            <div class="activity-name">${activity.name}</div>
        `;
        coreGrid.appendChild(card);
    });
}

// Get extended activities from defaultActivities array
const extendedActivitiesArray = defaultActivities.filter(a => extendedActivityIds.includes(a.id));

// Populate extended activities
if (extendedActivitiesArray.length === 0) {
    extendedGrid.innerHTML = '<p style="color: #999; font-size: 14px; padding: 20px; text-align: center; grid-column: 1/-1;">No additional activities available.</p>';
} else {
    extendedActivitiesArray.forEach(activity => {
        const card = document.createElement('div');
        // Extended activities hidden by default unless explicitly set otherwise
        const isVisible = visibilityMap.hasOwnProperty(activity.id)
            ? visibilityMap[activity.id]
            : false;
        card.className = `activity-card ${isVisible ? 'selected' : ''}`;
        card.onclick = () => toggleActivityVisibility(card, activity.id);
        card.dataset.activityId = activity.id;
        card.innerHTML = `
            <div class="activity-emoji">${activity.emoji || ''}</div>
            <div class="activity-name">${activity.name}</div>
        `;
        extendedGrid.appendChild(card);
    });
}

        // Load and display custom activities
        const { data: customActivities, error: customError } = await supabase
            .from('activities')
            .select('*')
            .eq('circle_id', selectedCircle.id)
            .order('name');
        
        if (customError) {
            console.error('Error loading custom activities:', customError);
        }
        
        const customList = document.getElementById('custom-activities-list');
        
        if (!customActivities || customActivities.length === 0) {
            customList.innerHTML = '<p style="color: #999; font-size: 14px; padding: 10px; text-align: center;">No custom activities yet. Use "Suggest a New Activity" to add one.</p>';
        } else {
            customActivities.forEach(activity => {
                const item = document.createElement('div');
                item.className = 'custom-activity-item';
               item.innerHTML = `
    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
        <span style="font-size: 1.5em;">${activity.emoji}</span>
        <span style="flex: 1; font-weight: 500;">${activity.name}</span>
    </div>
    <div style="display: flex; gap: 6px;">
        <button data-activity-id="${activity.id}" data-activity-name="${activity.name}" data-activity-emoji="${activity.emoji}" onclick="event.stopPropagation(); editCustomActivity(this.dataset.activityId, this.dataset.activityName, this.dataset.activityEmoji)" class="btn btn-secondary btn-small" style="margin: 0; padding: 6px 10px; font-size: 0.8em; flex: 1;"> Edit</button>
        <button data-activity-id="${activity.id}" data-activity-name="${activity.name}" onclick="event.stopPropagation(); deleteCustomActivity(this.dataset.activityId, this.dataset.activityName);" class="btn btn-secondary btn-small" style="margin: 0; padding: 6px 10px; font-size: 0.8em; background: #dc3545; color: white; flex: 1;"> Delete</button>
    </div>
`;
                customList.appendChild(item);
            });
        }
        
        document.getElementById('manage-activities-modal-overlay').style.display = 'flex';
        
    } catch (error) {
        console.error('Error loading manage activities modal:', error);
    }
}

window.closeManageActivitiesModal = () => {
    document.getElementById('manage-activities-modal-overlay').style.display = 'none';
}

window.editCustomActivity = async function(activityId, currentName, currentEmoji) {
    const newName = prompt('Edit activity name:', currentName);
    
    if (!newName || newName.trim() === currentName) {
        return; // User cancelled or no change
    }
    
    try {
        showLoader('Updating activity...');
        
        const { error } = await supabase
            .from('activities')
            .update({ name: newName.trim() })
            .eq('id', activityId)
            .eq('circle_id', selectedCircle.id); // Safety check - only edit activities in this circle
        
        if (error) throw error;
        
        hideLoader();
        showNotification('Activity updated!');
        
        // Refresh the modal
        openManageActivitiesModal();
        
        // Refresh activities if on activities page
        if (document.getElementById('activities').classList.contains('active')) {
            renderActivities();
        }
        
    } catch (error) {
        hideLoader();
        console.error('Error editing activity:', error);
        showNotification('Error updating activity', 'error');
    }
}

window.deleteCustomActivity = async function(activityId, activityName) {
    if (!confirm(`Delete "${activityName}"?\n\nThis will remove it for all circle members and delete any associated preferences.`)) {
        return;
    }
    
    try {
        showLoader('Deleting activity...');
        
        // First delete any preferences for this activity
        const { error: prefError } = await supabase
            .from('preferences')
            .delete()
            .eq('activity_id', activityId)
            .eq('circle_id', selectedCircle.id);
        
        if (prefError) throw prefError;
        
        // Then delete the activity itself
        const { error: activityError } = await supabase
            .from('activities')
            .delete()
            .eq('id', activityId)
            .eq('circle_id', selectedCircle.id); // Safety check
        
        if (activityError) throw activityError;
        
        // Remove from local activities array if present
        const index = activities.findIndex(a => a.id === activityId);
        if (index > -1) {
            activities.splice(index, 1);
        }
        
        hideLoader();
        showNotification('Activity deleted!');
        
        // Refresh the modal
        openManageActivitiesModal();
        
        // Refresh activities if on activities page
        if (document.getElementById('activities').classList.contains('active')) {
            renderActivities();
        }
        
    } catch (error) {
        hideLoader();
        console.error('Error deleting activity:', error);
        showNotification('Error deleting activity', 'error');
    }
}

window.toggleActivityVisibility = function(card, activityId) {
    card.classList.toggle('selected');
}

window.saveActivityVisibility = async function() {
    try {
        // Get selected activities from modal
        const selectedCards = document.querySelectorAll('#manage-activities-grid .activity-card.selected');
        const selectedIds = Array.from(selectedCards).map(card => card.dataset.activityId);
        
        // Get all activity IDs
        const allActivityIds = [...coreActivityIds, ...extendedActivityIds];
        
        // Prepare upsert data for all activities
        const visibilityData = allActivityIds.map(activityId => ({
            circle_id: selectedCircle.id,
            activity_id: activityId,
            is_visible: selectedIds.includes(activityId)
        }));
        
        // Upsert to circle_activities table
        const { error } = await supabase
            .from('circle_activities')
            .upsert(visibilityData, { 
                onConflict: 'circle_id,activity_id'
            });
        
        if (error) throw error;
        
        showNotification('Activity preferences updated for all circle members!');
        closeManageActivitiesModal();
        renderActivities();
    } catch (error) {
        console.error('Error saving activity visibility:', error);
        showNotification('Error saving changes', 'error');
    }
};

// Edge-based swipe navigation between pages
(function initEdgeSwipeNavigation() {
    const pageOrder = ['circles', 'activities', 'matches', 'events', 'settings'];
    const EDGE_THRESHOLD = 50; // pixels from edge to initiate swipe
    const SWIPE_THRESHOLD = 80; // minimum swipe distance to trigger navigation

    let touchStartX = 0;
    let touchStartY = 0;
    let touchCurrentX = 0;
    let touchCurrentY = 0;
    let isEdgeSwipe = false;
    let isSwiping = false;

    const appContainer = document.querySelector('.app-container');

    if (!appContainer) {
        console.error(' Edge swipe: app-container not found');
        return;
    }

    console.log(' Edge swipe navigation initialized');
    console.log('   Edge threshold:', EDGE_THRESHOLD + 'px');
    console.log('   Swipe threshold:', SWIPE_THRESHOLD + 'px');

    // Touch events
    appContainer.addEventListener('touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
        touchCurrentX = touchStartX;
        touchCurrentY = touchStartY;

        // Simple edge detection - check if touch is within threshold of viewport edges
        const viewportWidth = window.innerWidth;

        if (touchStartX <= EDGE_THRESHOLD || touchStartX >= viewportWidth - EDGE_THRESHOLD) {
            isEdgeSwipe = true;
            isSwiping = false;
            console.log(' Edge touch at x=' + touchStartX + ', viewport=' + viewportWidth);
        } else {
            isEdgeSwipe = false;
        }
    }, { passive: true });

    appContainer.addEventListener('touchmove', (e) => {
        if (!isEdgeSwipe) return;

        touchCurrentX = e.touches[0].clientX;
        touchCurrentY = e.touches[0].clientY;
        const deltaX = touchCurrentX - touchStartX;
        const deltaY = touchCurrentY - touchStartY;

        // Only process if swipe is mostly horizontal
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
            if (!isSwiping) {
                isSwiping = true;
            }

            // Prevent scrolling during horizontal swipe
            e.preventDefault();

            // Apply visual feedback
            const activePage = document.querySelector('.page.active');
            if (activePage) {
                const visualFeedback = Math.min(Math.abs(deltaX) / 3, 60);
                const direction = deltaX > 0 ? 1 : -1;
                activePage.style.transform = `translateX(${direction * visualFeedback}px)`;
                activePage.style.transition = 'none';
                activePage.style.opacity = Math.max(0.7, 1 - (visualFeedback / 200));
            }
        }
    }, { passive: false });

    appContainer.addEventListener('touchend', (e) => {
        if (!isEdgeSwipe) return;

        const deltaX = touchCurrentX - touchStartX;
        const deltaY = touchCurrentY - touchStartY;
        const activePage = document.querySelector('.page.active');

        console.log(' Touch end - deltaX=' + deltaX + ', deltaY=' + deltaY + ', isSwiping=' + isSwiping);

        // Reset visual feedback
        if (activePage) {
            activePage.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out';
            activePage.style.transform = '';
            activePage.style.opacity = '';
        }

        // Navigate if swipe was horizontal enough and exceeded threshold
        if (isSwiping && Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > SWIPE_THRESHOLD) {
            const currentPageId = localStorage.getItem('friendle_current_page') || 'circles';
            const currentIndex = pageOrder.indexOf(currentPageId);

            console.log(' Navigating from page ' + currentPageId + ' (index ' + currentIndex + ')');

            let targetIndex;
            if (deltaX > 0) {
                // Swiped right - go to previous page
                targetIndex = currentIndex - 1;
            } else {
                // Swiped left - go to next page
                targetIndex = currentIndex + 1;
            }

            // Navigate if target page exists
            if (targetIndex >= 0 && targetIndex < pageOrder.length) {
                const targetPage = pageOrder[targetIndex];
                console.log(' Navigating to: ' + targetPage);
                showPage(targetPage);
            } else {
                console.log(' No page at index ' + targetIndex);
            }
        } else {
            console.log(' Swipe not triggered - deltaX=' + Math.abs(deltaX) + ', threshold=' + SWIPE_THRESHOLD);
        }

        isEdgeSwipe = false;
        isSwiping = false;
    }, { passive: true });

    // Mouse events for desktop testing
    let isMouseDragging = false;
    let mouseStartX = 0;
    let mouseStartY = 0;
    let mouseCurrentX = 0;

    appContainer.addEventListener('mousedown', (e) => {
        mouseStartX = e.clientX;
        mouseStartY = e.clientY;
        mouseCurrentX = mouseStartX;

        const viewportWidth = window.innerWidth;

        if (mouseStartX <= EDGE_THRESHOLD || mouseStartX >= viewportWidth - EDGE_THRESHOLD) {
            isMouseDragging = true;
            isEdgeSwipe = true;
            console.log(' Edge mouse down at x=' + mouseStartX + ', viewport=' + viewportWidth);
        }
    });

    document.addEventListener('mousemove', (e) => {
        if (!isMouseDragging) return;

        mouseCurrentX = e.clientX;
        const deltaX = mouseCurrentX - mouseStartX;

        if (Math.abs(deltaX) > 10) {
            const activePage = document.querySelector('.page.active');
            if (activePage) {
                const visualFeedback = Math.min(Math.abs(deltaX) / 3, 60);
                const direction = deltaX > 0 ? 1 : -1;
                activePage.style.transform = `translateX(${direction * visualFeedback}px)`;
                activePage.style.transition = 'none';
                activePage.style.opacity = Math.max(0.7, 1 - (visualFeedback / 200));
            }
        }
    });

    document.addEventListener('mouseup', (e) => {
        if (!isMouseDragging) return;

        const deltaX = mouseCurrentX - mouseStartX;
        const activePage = document.querySelector('.page.active');

        console.log(' Mouse up - deltaX=' + deltaX);

        if (activePage) {
            activePage.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out';
            activePage.style.transform = '';
            activePage.style.opacity = '';
        }

        if (Math.abs(deltaX) > SWIPE_THRESHOLD) {
            const currentPageId = localStorage.getItem('friendle_current_page') || 'circles';
            const currentIndex = pageOrder.indexOf(currentPageId);

            console.log(' Mouse navigating from: ' + currentPageId);

            let targetIndex;
            if (deltaX > 0) {
                targetIndex = currentIndex - 1;
            } else {
                targetIndex = currentIndex + 1;
            }

            if (targetIndex >= 0 && targetIndex < pageOrder.length) {
                const targetPage = pageOrder[targetIndex];
                console.log(' Mouse navigating to: ' + targetPage);
                showPage(targetPage);
            }
        } else {
            console.log(' Mouse swipe too short - deltaX=' + Math.abs(deltaX));
        }

        isMouseDragging = false;
        isEdgeSwipe = false;
    });
})();

  initApp(); // start the app
});   //  closes document.addEventListener("DOMContentLoaded", ...)

    </script>

    <!-- Camera Modal -->
    <div id="camera-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.9); z-index: 10000; justify-content: center; align-items: center;">
        <div style="position: relative; max-width: 90%; max-height: 90%; display: flex; flex-direction: column; align-items: center;">
            <div style="position: relative; background: #000; border-radius: 12px; overflow: hidden;">
                <video id="camera-video" autoplay playsinline style="max-width: 100%; max-height: 70vh; display: block;"></video>
                <canvas id="camera-canvas" style="display: none;"></canvas>
            </div>
            <div style="margin-top: 20px; display: flex; gap: 15px;">
                <button class="btn" onclick="capturePhoto()" style="padding: 12px 24px; font-size: 1em;"> Capture</button>
                <button class="btn btn-secondary" onclick="closeCameraModal()" style="padding: 12px 24px; font-size: 1em;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Photo Menu Popup -->
    <div id="photo-menu" style="display: none; position: fixed; z-index: 9999; background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px; box-shadow: var(--shadow-lg); overflow: hidden; min-width: 180px;">
        <div onclick="handlePhotoMenuAction('camera')" style="padding: 12px 16px; cursor: pointer; border-bottom: 1px solid var(--border-color); transition: background 0.2s;" onmouseover="this.style.background='var(--hover-bg)'" onmouseout="this.style.background='transparent'">
            <div style="display: flex; align-items: center; gap: 10px;">
                <span style="font-size: 1.2em;"></span>
                <span style="color: var(--text-primary);">Take Photo</span>
            </div>
        </div>
        <div onclick="handlePhotoMenuAction('upload')" style="padding: 12px 16px; cursor: pointer; border-bottom: 1px solid var(--border-color); transition: background 0.2s;" onmouseover="this.style.background='var(--hover-bg)'" onmouseout="this.style.background='transparent'">
            <div style="display: flex; align-items: center; gap: 10px;">
                <span style="font-size: 1.2em;"></span>
                <span style="color: var(--text-primary);">Upload Photo</span>
            </div>
        </div>
        <div id="photo-menu-remove" onclick="handlePhotoMenuAction('remove')" style="padding: 12px 16px; cursor: pointer; transition: background 0.2s; display: none;" onmouseover="this.style.background='var(--hover-bg)'" onmouseout="this.style.background='transparent'">
            <div style="display: flex; align-items: center; gap: 10px;">
                <span style="font-size: 1.2em;"></span>
                <span style="color: var(--text-primary);">Remove Photo</span>
            </div>
        </div>
    </div>

    <!-- Chat Photo Menu Popup -->
    <div id="chat-photo-menu" style="display: none; position: fixed; z-index: 9999; background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px; box-shadow: var(--shadow-lg); overflow: hidden; min-width: 180px;">
        <div onclick="handleChatPhotoMenuAction('camera')" style="padding: 12px 16px; cursor: pointer; border-bottom: 1px solid var(--border-color); transition: background 0.2s;" onmouseover="this.style.background='var(--hover-bg)'" onmouseout="this.style.background='transparent'">
            <div style="display: flex; align-items: center; gap: 10px;">
                <span style="font-size: 1.2em;"></span>
                <span style="color: var(--text-primary);">Take Photo</span>
            </div>
        </div>
        <div onclick="handleChatPhotoMenuAction('library')" style="padding: 12px 16px; cursor: pointer; transition: background 0.2s;" onmouseover="this.style.background='var(--hover-bg)'" onmouseout="this.style.background='transparent'">
            <div style="display: flex; align-items: center; gap: 10px;">
                <span style="font-size: 1.2em;"></span>
                <span style="color: var(--text-primary);">Choose from Library</span>
            </div>
        </div>
    </div>

    <!-- Avatar Selection Modal -->
    <div id="avatar-selection-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); z-index: 10000; justify-content: center; align-items: center;" onclick="closeAvatarSelectionModal()">
        <div style="background: var(--card-bg); border-radius: 12px; padding: 30px; max-width: 400px; width: 90%;" onclick="event.stopPropagation()">
            <h3 style="margin: 0 0 20px 0; text-align: center; color: var(--text-primary);">Choose an Avatar</h3>
            <div class="avatar-grid" id="avatar-selection-grid" style="margin-bottom: 20px;">
                <div class="avatar-option" data-avatar=""></div><div class="avatar-option" data-avatar=""></div><div class="avatar-option" data-avatar=""></div><div class="avatar-option" data-avatar=""></div>
                <div class="avatar-option" data-avatar=""></div><div class="avatar-option" data-avatar=""></div><div class="avatar-option" data-avatar=""></div><div class="avatar-option" data-avatar=""></div>
            </div>
            <div style="display: flex; gap: 10px;">
                <button class="btn" onclick="confirmAvatarSelection()" style="flex: 1;">Confirm</button>
                <button class="btn btn-secondary" onclick="closeAvatarSelectionModal()" style="flex: 1;">Cancel</button>
            </div>
        </div>
    </div>

</body>
</html>