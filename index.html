<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Friendle - Match Activities with Friends</title>
    <link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#667eea">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }

        .app-container {
            max-width: 400px;
            margin: 0 auto;
            background: white;
            height: 100%;
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }

        .page {
            display: none;
            padding: 20px;
            flex: 1;
            overflow-y: auto;
        }

        .page.active {
            display: block;
        }

        .page#chat.active {
            display: flex;
            flex-direction: column;
            padding: 0;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .logo {
            font-size: 2.5em;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .tagline {
            color: #666;
            font-size: 0.9em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        #activity-search {
            margin-bottom: 20px;
        }

        .btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin: 10px 0;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #333;
            border: 2px solid #e1e5e9;
        }

        .btn-secondary:hover {
            background: #e9ecef;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }
        
        .btn-small {
            width: auto;
            padding: 10px 20px;
            font-size: 0.9em;
            margin-top: 0;
        }

        .avatar-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .avatar-option {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid #e1e5e9;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            background: #f8f9fa;
        }

        .avatar-option:hover {
            transform: scale(1.1);
        }

        .avatar-option.selected {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .circle-card {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
            border: 2px solid transparent;
            transition: all 0.3s;
        }
        
        .circle-card .main-content {
            cursor: pointer;
        }

        .circle-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .circle-name {
            font-size: 1.2em;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .circle-members {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .circle-code {
            background: white;
            padding: 10px;
            border-radius: 8px;
            font-size: 0.8em;
            color: #555;
            text-align: center;
            margin-top: 10px;
        }
        
        .circle-code strong {
            letter-spacing: 2px;
            font-size: 1.1em;
            color: #667eea;
        }

        .activities-grid, .frequent-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .section-title {
            font-size: 1.1em;
            font-weight: 600;
            color: #555;
            margin: 20px 0 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid #f0f0f0;
        }

        .activity-card {
            background: white;
            border: 2px solid #e1e5e9;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .activity-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
        }

        .activity-card.selected {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-color: #667eea;
        }

        .activity-emoji {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .activity-name {
            font-weight: 600;
            font-size: 0.9em;
        }

        .bulk-controls {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .bulk-controls h4 {
            margin-bottom: 10px;
            color: #555;
        }

        .bulk-btn {
            display: inline-block;
            padding: 8px 12px;
            margin: 5px 5px 5px 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 20px;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .bulk-btn:hover {
            background: #667eea;
            color: white;
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .chat-header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            flex-shrink: 0;
        }

        .chat-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: white;
            color: #667eea;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 10px;
        }
        
        .scheduled-event-banner {
            padding: 10px;
            background-color: #e6f7ff;
            border-bottom: 1px solid #91d5ff;
            text-align: center;
            font-size: 0.9em;
            color: #0050b3;
            flex-shrink: 0;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            background: #f8f9fa;
        }

        .message {
            margin: 15px 0;
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .message-actions {
    position: relative;
}

.message-actions-btn {
    background: none;
    border: none;
    color: #aaa;
    cursor: pointer;
    font-size: 1.2em;
    padding: 5px;
}

.message-actions-menu {
    position: absolute;
    bottom: 25px;
    right: 0;
    background: white;
    border: 1px solid #ddd;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    display: none;
    width: 100px;
    z-index: 10;
}

.message-actions-menu button {
    display: block;
    width: 100%;
    padding: 10px;
    background: none;
    border: none;
    text-align: left;
    cursor: pointer;
}

.message-actions-menu button:hover {
    background: #f8f9fa;
}

        .message.own {
            flex-direction: row-reverse;
        }
        
        .message.system {
            justify-content: center;
            font-size: 0.8em;
            color: #888;
            margin: 20px 0;
        }

        .message-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #667eea;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            font-weight: bold;
            flex-shrink: 0;
        }

        .message-content {
            max-width: 80%;
        }

        .message-sender {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 4px;
            padding: 0 12px;
        }

        .message.own .message-content {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .message-bubble {
            background: white;
            padding: 12px 15px;
            border-radius: 15px;
            position: relative;
        }

        .message.own .message-bubble {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .message-photo {
            max-width: 200px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .message-photo:hover {
            transform: scale(1.05);
        }

        .message-location {
            background: #e8f4fd;
            border: 1px solid #bee5eb;
            padding: 10px;
            border-radius: 10px;
            cursor: pointer;
        }
        
        .message-actions {
            position: relative;
        }

        .message-actions-btn {
            background: none;
            border: none;
            color: #aaa;
            cursor: pointer;
            font-size: 1.2em;
            padding: 5px;
        }
        
        .message-actions-menu {
            position: absolute;
            bottom: 25px;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            display: none;
            width: 100px;
            z-index: 10;
        }

        .message-actions-menu button {
            display: block;
            width: 100%;
            padding: 10px;
            background: none;
            border: none;
            text-align: left;
            cursor: pointer;
        }
        .message-actions-menu button:hover {
            background: #f8f9fa;
        }

        .chat-input {
            background: white;
            padding: 15px;
            border-top: 1px solid #ddd;
            flex-shrink: 0;
        }
        
        .chat-input-top-row {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }

        .chat-input input[type="text"] {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 20px;
            outline: none;
            min-width: 50px;
        }
        
        .attachment-btn {
            background: #f8f9fa;
            border: none;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 1.2em;
        }
        
        .attachment-btn:hover {
            background: #e9ecef;
        }

        .send-btn {
            margin: 0;
        }

        .bottom-nav {
            position: relative;
            width: 100%;
            background: white;
            border-top: 1px solid #ddd;
            display: flex;
            justify-content: space-around;
            padding: 15px 0;
            flex-shrink: 0;
        }

        .nav-item {
            text-align: center;
            cursor: pointer;
            transition: color 0.2s;
            flex: 1;
            position: relative;
        }
        
        .notification-badge {
            position: absolute;
            top: -5px;
            right: calc(50% - 20px);
            width: 10px;
            height: 10px;
            background-color: #ff4d4f;
            border-radius: 50%;
            border: 2px solid white;
            display: none;
        }

        .nav-item.active {
            color: #667eea;
        }

        .nav-item .nav-icon {
            font-size: 1.2em;
            margin-bottom: 5px;
        }

        .nav-item .nav-label {
            font-size: 0.7em;
            font-weight: 600;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-content {
    	background: white;
    	padding: 25px;
    	border-radius: 15px;
    	max-width: 90%;
    	width: 350px;
    	max-height: 90vh;
    	overflow-y: auto;
    	box-shadow: 0 10px 30px rgba(0,0,0,0.2);
	}
        
        .modal-image-content {
            background: transparent;
            padding: 0;
            box-shadow: none;
        }

        .modal-image {
            width: 100%;
            height: auto;
            border-radius: 10px;
        }

        .close-modal {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 2em;
            cursor: pointer;
            z-index: 2001;
        }
        
        .modal-content .close-modal-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 1.5em;
            color: #aaa;
            cursor: pointer;
        }

        .modal-header {
            font-size: 1.4em;
            font-weight: 600;
            margin-bottom: 20px;
            color: #333;
        }
        
        .undo-container {
    position: fixed;
    bottom: 70px;
    left: 50%;
    transform: translateX(-50%);
    width: calc(100% - 40px);
    max-width: 360px;
    background-color: #333;
    color: white;
    padding: 15px;
    border-radius: 10px;
    display: none;
    justify-content: space-between;
    align-items: center;
    z-index: 1001; /* Higher than the save button */
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

        .undo-btn {
            background: none;
            border: none;
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
        }

.sticky-save {
    position: fixed;
    bottom: 80px;
    left: 50%;
    transform: translateX(-50%);
    width: calc(100% - 40px);
    max-width: 360px;
    z-index: 100;
    box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
}

.sticky-save:hover {
    transform: translateX(-50%) translateY(-2px);
    box-shadow: 0 3px 15px rgba(102, 126, 234, 0.4);
}

#manage-activities-grid {
    max-height: 400px;
    overflow-y: auto;
    margin-bottom: 20px;
}

.message-timestamp {
            color: #999;
            font-size: 0.7em;
            margin-left: 8px;
        }

#manage-activities-grid .activities-grid {
    display: grid !important;
    grid-template-columns: repeat(3, 1fr) !important;
    gap: 10px;
    margin-bottom: 20px;
}

#manage-activities-grid h3 {
    font-size: 1em;
    font-weight: 600;
    color: #555;
    margin: 15px 0 10px 0;
    padding-bottom: 5px;
    border-bottom: 1px solid #f0f0f0;
}

#manage-activities-grid h3:first-child {
    margin-top: 0;
}

#manage-activities-modal-overlay .modal-content {
    max-height: 80vh;
    overflow-y: auto;
}

#manage-activities-grid .activity-card {
    padding: 8px !important;
    font-size: 0.75em !important;
    min-height: 60px !important;
    max-height: 60px !important;
    width: 100% !important;
}

#manage-activities-grid .activity-emoji {
    font-size: 1.1em !important;
    margin-bottom: 4px !important;
}

#manage-activities-grid .activity-name {
    font-size: 0.75em !important;
    line-height: 1.1 !important;
    margin: 0 !important;
}

#manage-activities-modal-overlay #manage-activities-grid {
    display: block !important;
    grid-template-columns: unset !important;
}

    </style>
<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
<script>
  const SUPABASE_URL = "https://kxsewkjbhxtfqbytftbu.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt4c2V3a2piaHh0ZnFieXRmdGJ1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg4NTE4ODQsImV4cCI6MjA3NDQyNzg4NH0.-A-7VOQWOaQqYOO6NxiKxGywddfS-pmwvzHISJqz2AQ";

  const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
</script>

</head>
<body>
    <div class="app-container">
        <div id="pages-container" style="flex: 1; overflow-y: auto; position: relative;">
            <div id="welcome" class="page active">
    <div class="header"><div class="logo">⭕ Friendle</div><div class="tagline">What do you feel like doing?</div></div>
    
    <div id="login-form">
        <div class="form-group"><label for="login-email">Email</label><input type="email" id="login-email" placeholder="Enter your email"></div>
        <div class="form-group"><label for="login-password">Password</label><input type="password" id="login-password" placeholder="Enter your password"></div>
        <button class="btn" onclick="signIn()">Sign In</button>
        <button class="btn btn-secondary" onclick="showRegister()">Create Account</button>
    </div>
    
    <div id="register-form" style="display: none;">
        <div class="form-group"><label for="register-email">Email</label><input type="email" id="register-email" placeholder="Enter your email"></div>
        <div class="form-group"><label for="register-password">Password</label><input type="password" id="register-password" placeholder="Create a password (6+ characters)"></div>
        <div class="form-group"><label for="register-name">Your Name</label><input type="text" id="register-name" placeholder="Enter your name"></div>
        <div class="form-group"><label>Choose Your Avatar</label><div class="avatar-grid">
            <div class="avatar-option" data-avatar="😊">😊</div><div class="avatar-option" data-avatar="🌟">🌟</div><div class="avatar-option" data-avatar="🦄">🦄</div><div class="avatar-option" data-avatar="🐨">🐨</div>
            <div class="avatar-option" data-avatar="🎮">🎮</div><div class="avatar-option" data-avatar="🎨">🎨</div><div class="avatar-option" data-avatar="⚡">⚡</div><div class="avatar-option" data-avatar="🌙">🌙</div>
        </div></div>
        <button class="btn" onclick="signUp()">Create Account</button>
        <button class="btn btn-secondary" onclick="showLogin()">Back to Sign In</button>
    </div>
</div>
            <div id="circles" class="page"><div class="header"><div class="logo">⭕ Circles</div><div class="tagline">Who do you want to hang with?</div></div><div id="circles-list"></div><button class="btn" onclick="showCreateCircle()">Create New Circle</button><button class="btn btn-secondary" onclick="showJoinCircle()">Join Circle</button></div>
            <div id="activities" class="page">
    <div class="header">
        <div class="logo" id="activity-circle-name">⭕ Activities</div><div class="tagline">What do you want to do?</div>
    </div>
    <div class="form-group">
        <input type="text" id="activity-search" placeholder="🔍 Search for an activity..." onkeyup="handleSearch(event)">
    </div>
    <div style="display: flex; gap: 10px; margin-bottom: 20px;">
        <button class="btn btn-secondary btn-small" onclick="openSuggestModal()" style="flex: 1;">💡 Suggest a New Activity</button>
        <button class="btn btn-secondary btn-small" onclick="openManageActivitiesModal()" style="flex: 1;">Manage Activities</button>
    </div>
    
                <div id="frequent-section"><div class="section-title">⭐ Frequently Used</div><div class="frequent-grid" id="frequent-grid"></div></div>
                <div class="section-title">All Activities</div>
                <div class="bulk-controls"><h4>Quick Select</h4><div class="bulk-btn" onclick="selectBulk('food')">Food & Drinks</div><div class="bulk-btn" onclick="selectBulk('active')">Active</div><div class="bulk-btn" onclick="selectBulk('entertainment')">Entertainment</div><div class="bulk-btn" onclick="selectBulk('relax')">Relax & Creative</div><div class="bulk-btn" onclick="selectBulk('clear')">Clear All</div></div>
                <div class="activities-grid" id="activities-grid"></div>
                <button class="btn sticky-save" onclick="saveActivities()">Save Preferences</button>
                
            </div>
            <div id="matches" class="page">
    <div class="header">
        <div class="logo">⭕ Matches</div>
        <div class="tagline">Who else wants to do what you want to do?</div>
        <div style="margin-top: 15px;">
            <label style="display: flex; align-items: center; gap: 8px; font-size: 0.9em; color: #666;">
                <input type="checkbox" id="show-past-events" checked onchange="window.renderMatches()">
                Show past events
            </label>
        </div>
    </div>
    <div id="matches-list"></div>
</div>
            <div id="chat" class="page">
    <div class="chat-container">
        <div class="chat-header">
    <button onclick="showPage('matches')" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 0.85em; margin-right: 10px;">← Back</button>
    <div style="flex: 1;">
        <div id="event-activity-name" style="font-weight: 600; font-size: 1.1em;"></div>
        <div id="event-participants" style="font-size: 0.8em; opacity: 0.8;"></div>
    </div>
    <button onclick="leaveEvent()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 0.85em; margin-right: 8px;">Leave event</button>
    <button id="event-options-btn" onclick="openEventOptionsModal()" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 0.85em;">⚙️</button>
</div>
        
        <div id="event-details" style="background: #e6f7ff; padding: 12px 15px; border-bottom: 1px solid #91d5ff; flex-shrink: 0;">
            <div id="event-date" style="font-weight: 500; margin-bottom: 4px; color: #0050b3;"></div>
            <div id="event-location" style="color: #0050b3; font-size: 14px;"></div>
            <div id="event-notes" style="color: #0050b3; font-size: 14px; margin-top: 4px;"></div>
        </div>
        
        <div class="chat-messages" id="chat-messages"></div>
        
        <div class="chat-input">
            <div class="chat-input-top-row">
                <input type="text" id="message-input" placeholder="Type a message..." onkeypress="handleMessageKeyPress(event)">
                <button class="attachment-btn" onclick="sharePhoto()">📷</button>
                <button class="attachment-btn" onclick="shareLocation()">📍</button>
                <button class="attachment-btn" onclick="findNearbyPlaces()">🔍</button>
            </div>
            <button class="btn send-btn" onclick="sendMessage()">Send</button>
        </div>
    </div>
</div>
            <div id="settings" class="page">
            <div class="header"><div class="logo">⭕ Settings</div><div class="tagline">Manage your preferences</div></div>
    <div style="text-align: center; margin: 40px 0;"><div id="profile-avatar" style="font-size: 2em; margin: 0 auto 20px;">😊</div><h2 id="profile-name">Your Name</h2></div>
    
    <div class="form-group">
        <label for="min-group-size">Minimum Group Size</label>
        <select id="min-group-size" onchange="saveMinimumGroupSize()">
            <option value="2">Any size (including 1-on-1)</option>
            <option value="3">At least 3 people</option>
            <option value="4">At least 4 people</option>
            <option value="5">At least 5 people</option>
        </select>
        <div style="font-size: 0.85em; color: #666; margin-top: 5px;">Only show matches with at least this many total participants</div>
    </div>
    
    <div class="form-group">
        <label for="new-username">Change Display Name</label>
        <input type="text" id="new-username" placeholder="Enter new name">
    </div>
    <button class="btn btn-secondary" onclick="changeUsername()">Update Name</button>
    
    <div class="form-group">
        <label for="new-password">Change Password</label>
        <input type="password" id="new-password" placeholder="New password (6+ characters)">
        <input type="password" id="confirm-password" placeholder="Confirm new password" style="margin-top: 10px;">
    </div>
    <button class="btn btn-secondary" onclick="changePassword()">Update Password</button>
    
    <button class="btn btn-secondary" onclick="signOut()">Sign Out</button>
    <button class="btn btn-secondary" onclick="exportData()">Export My Data</button>
    <button class="btn btn-secondary" onclick="resetApp()" style="background: #dc3545; color: white;">Reset App</button>
</div>
        </div>
        
        <div class="bottom-nav">
            <div class="nav-item active" onclick="showPage('circles')"><div class="nav-icon">👥</div><div class="nav-label">Circles</div></div>
            <div class="nav-item" onclick="showPage('activities')"><div class="nav-icon">🎯</div><div class="nav-label">Activities</div></div>
            <div class="nav-item" id="matches-nav-item" onclick="showPage('matches')"><div class="nav-icon">💫</div><div class="nav-label">Matches</div><span class="notification-badge"></span></div>
            <div class="nav-item" onclick="showPage('settings')"><div class="nav-icon">⚙️</div><div class="nav-label">Settings</div></div>
        </div>
        
        <div class="modal-overlay" id="image-modal-overlay"><div class="close-modal" onclick="closeImageModal()">×</div><div class="modal-content modal-image-content"><img class="modal-image" id="modal-image" src="" alt=""></div></div>
        <div class="modal-overlay" id="circle-modal-overlay"><div class="modal-content"><span class="close-modal-btn" onclick="closeCircleModal()">×</span><div id="create-circle" style="display: none;"><div class="modal-header">Create New Circle</div><div class="form-group"><label for="circle-name">Circle Name</label><input type="text" id="circle-name" placeholder="e.g., College Friends"></div><button class="btn" onclick="createCircle()">Create</button></div><div id="join-circle" style="display: none;"><div class="modal-header">Join Circle</div><div class="form-group"><label for="circle-code">Circle Code</label><input type="text" id="circle-code" placeholder="Enter 6-digit code"></div><button class="btn" onclick="joinCircle()">Join</button></div></div></div>
        <div class="modal-overlay" id="suggest-modal-overlay"><div class="modal-content"><span class="close-modal-btn" onclick="closeSuggestModal()">×</span><div class="modal-header">Suggest an Activity</div><div class="form-group"><label for="suggest-name">Activity Name</label><input type="text" id="suggest-name" placeholder="e.g., Go Karting"></div><button class="btn" onclick="suggestActivity()">Suggest</button></div></div>
        <div class="modal-overlay" id="date-modal-overlay"><div class="modal-content"><span class="close-modal-btn" onclick="closeDateModal()">×</span><div class="modal-header">Schedule Activity</div><div class="form-group"><label for="event-date">Date</label><input type="date" id="event-date"></div><button class="btn" onclick="saveEvent()">Save Event</button></div></div>
        <div class="modal-overlay" id="invite-modal-overlay"><div class="modal-content"><span class="close-modal-btn" onclick="closeInviteModal()">×</span><div class="modal-header">Share Invite Link</div><div class="form-group"><label for="invite-link">Copy this link and send it to a friend:</label><input type="text" id="invite-link" readonly></div><button class="btn" onclick="copyInviteLink()">Copy Link</button></div></div>
    
<div class="undo-container" id="undo-container">
                    <span>Selection updated.</span>
                    <button class="undo-btn" onclick="undoLastActivityChange()">Undo</button>
                </div>
<div class="modal-overlay" id="manage-activities-modal-overlay">
    <div class="modal-content">
        <span class="close-modal-btn" onclick="closeManageActivitiesModal()">×</span>
        <div class="modal-header">Manage Activities for This Circle</div>
        <div style="margin-bottom: 15px; font-size: 0.9em; color: #666;">
    Customize which activities appear in your activity selection. Core activities are shown by default - uncheck to hide them. Additional activities are available to add more variety to your options.
</div>
        <div id="manage-activities-grid" class="activities-grid"></div>
        <button class="btn" onclick="saveActivityVisibility()">Save Changes</button>
    </div>
</div>
</div>

<!-- Create Event Modal -->
<div class="modal-overlay" id="create-event-modal">
    <div class="modal-content" style="max-width: 500px;">
        <span class="close-modal-btn" onclick="closeCreateEventModal()">×</span>
        <div class="modal-header">Schedule New Event</div>
        
        <form id="create-event-form">
            <input type="hidden" id="new-event-match-id">
            
            <div class="form-group">
    <label for="new-event-date">Date *</label>
    <input type="date" id="new-event-date" required>
</div>
            
            <div class="form-group">
                <label for="new-event-location">Location</label>
                <input type="text" id="new-event-location" placeholder="Where are you meeting?">
            </div>
            
            <div class="form-group">
                <label for="new-event-notes">Notes</label>
                <textarea id="new-event-notes" rows="3" placeholder="Any additional details..."></textarea>
            </div>
            
            <button type="submit" class="btn">Create Event</button>
        </form>
    </div>
</div>

<!-- Event Options Modal -->
<div class="modal-overlay" id="event-options-modal">
    <div class="modal-content" style="max-width: 400px;">
        <span class="close-modal-btn" onclick="closeEventOptionsModal()">×</span>
        <div class="modal-header">Event Options</div>
        
        <button onclick="editCurrentEvent()" class="btn btn-secondary" style="width: 100%; text-align: left; margin: 5px 0;">
            ✏️ Edit Event Details
        </button>
        <button onclick="markEventCompleted()" class="btn btn-secondary" style="width: 100%; text-align: left; margin: 5px 0;">
            ✅ Mark as Completed
        </button>
        <button onclick="cancelEvent()" class="btn btn-secondary" style="width: 100%; text-align: left; margin: 5px 0;">
            ❌ Cancel Event
        </button>
        <button onclick="deleteEvent()" class="btn btn-secondary" style="width: 100%; text-align: left; margin: 5px 0; background: #dc3545; color: white;">
            🗑️ Delete Event
        </button>
    </div>
</div>

<!-- Edit Event Modal -->
<div class="modal-overlay" id="edit-event-modal">
    <div class="modal-content" style="max-width: 500px;">
        <span class="close-modal-btn" onclick="closeEditEventModal()">×</span>
        <div class="modal-header">Edit Event</div>
        
        <form id="edit-event-form">
            <div class="form-group">
    <label for="edit-event-date">Date *</label>
    <input type="date" id="edit-event-date" required>
</div>
            
            <div class="form-group">
                <label for="edit-event-location">Location</label>
                <input type="text" id="edit-event-location" placeholder="Where are you meeting?">
            </div>
            
            <div class="form-group">
                <label for="edit-event-notes">Notes</label>
                <textarea id="edit-event-notes" rows="3" placeholder="Any additional details..."></textarea>
            </div>
            
            <button type="submit" class="btn">Save Changes</button>
        </form>
    </div>
</div>

    <script>
        // App State
        let currentUser = null, circles = [], selectedCircle = null, activities = [], lastActivitiesState = [], activityCounts = {}, matches = [], messages = {}, currentChatMatch = null, undoTimeout = null, showingArchivedMessages = false, currentMatchChat = null, matchMessageSubscription = null;


// UUID Generator
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

// Authentication functions
function showRegister() {
    document.getElementById('login-form').style.display = 'none';
    document.getElementById('register-form').style.display = 'block';
}

function showLogin() {
    document.getElementById('register-form').style.display = 'none';
    document.getElementById('login-form').style.display = 'block';
}

window.signUp = async function() {
    const email = document.getElementById('register-email').value.trim();
    const password = document.getElementById('register-password').value;
    const name = document.getElementById('register-name').value.trim();
    const selectedAvatar = document.querySelector('#register-form .avatar-option.selected');
    
    if (!email || !password || !name || !selectedAvatar) {
        return showNotification('Please fill in all fields and select an avatar', 'error');
    }
    
    if (password.length < 6) {
        return showNotification('Password must be at least 6 characters', 'error');
    }
    
    try {
        // Sign up with Supabase Auth
        const { data: authData, error: authError } = await supabase.auth.signUp({
            email: email,
            password: password
        });
        
        if (authError) throw authError;
        
        // Create profile with authenticated user ID
        const { data: profileData, error: profileError } = await supabase
            .from('profiles')
            .insert([{
                id: authData.user.id, // Use Supabase Auth user ID
                name: name,
                avatar: selectedAvatar.dataset.avatar
            }])
            .select()
            .single();
        
        if (profileError) throw profileError;
        
        currentUser = profileData;
	// Request notification permission
if ('Notification' in window && Notification.permission === 'default') {
    Notification.requestPermission();
}
        localStorage.setItem('friendle_user', JSON.stringify(currentUser));
        
        showNotification('Account created successfully!');
        showPage('circles');
        updateProfile();
        processInvite();
        
    } catch (error) {
        console.error('Signup error:', error);
        showNotification(error.message || 'Error creating account', 'error');
    }
}

window.signIn = async function() {
    const email = document.getElementById('login-email').value.trim();
    const password = document.getElementById('login-password').value;
    
    if (!email || !password) {
        return showNotification('Please enter email and password', 'error');
    }
    
    try {
        // Sign in with Supabase Auth
        const { data: authData, error: authError } = await supabase.auth.signInWithPassword({
            email: email,
            password: password
        });
        
        if (authError) throw authError;
        
        // Load user profile
        const { data: profileData, error: profileError } = await supabase
            .from('profiles')
            .select('*')
            .eq('id', authData.user.id)
            .single();
        
        if (profileError) throw profileError;
        
        currentUser = profileData;
        localStorage.setItem('friendle_user', JSON.stringify(currentUser));
        
        showNotification('Signed in successfully!');
        showPage('circles');
        updateProfile();
        processInvite();
        
    } catch (error) {
        console.error('Signin error:', error);
        showNotification(error.message || 'Error signing in', 'error');
    }
}

window.signOut = async function() {
    if (!confirm('Are you sure you want to sign out?')) return;
    
    try {
        await supabase.auth.signOut();
        currentUser = null;
        localStorage.removeItem('friendle_user');
        showPage('welcome');
        showNotification('Signed out successfully');
    } catch (error) {
        console.error('Sign out error:', error);
        showNotification('Error signing out', 'error');
    }
}

async function processInviteCode() {
    const inviteCode = sessionStorage.getItem('pending_invite_code');
    if (!inviteCode || !currentUser) return;
    
    try {
        // Find circle by code
        const { data: circle, error: circleError } = await supabase
            .from('circles')
            .select('*')
            .eq('code', inviteCode)
            .single();
        
        if (circleError || !circle) {
            showNotification('Invalid invite code', 'error');
            sessionStorage.removeItem('pending_invite_code');
            return;
        }
        
        // Check if user is already a member
        const { data: existingMember } = await supabase
            .from('circle_members')
            .select('*')
            .eq('circle_id', circle.id)
            .eq('profile_id', currentUser.id)
            .single();
        
        if (existingMember) {
            showNotification('You are already a member of this circle');
            sessionStorage.removeItem('pending_invite_code');
            return;
        }
        
        // Add user to circle
        const { error: joinError } = await supabase
            .from('circle_members')
            .insert([{ circle_id: circle.id, profile_id: currentUser.id }]);
        
        if (joinError) throw joinError;
        
        showNotification('Successfully joined "' + circle.name + '"!');
        renderCircles(); // Refresh circles display
        sessionStorage.removeItem('pending_invite_code');
        
    } catch (error) {
        console.error('Error processing invite:', error);
        showNotification('Error joining circle', 'error');
        sessionStorage.removeItem('pending_invite_code');
    }
}

        // Utility Functions
        function generateCode() { return Math.floor(100000 + Math.random() * 900000).toString(); }
        function showNotification(message, type = 'success') { /* ... */ }

        // Profile Management & Avatar Selection
       window.createProfile = async function() {
  const name = document.getElementById('name').value.trim();
  const selectedAvatar = document.querySelector('.avatar-option.selected');
  if (!name || !selectedAvatar) {
    return showNotification('Please enter a name and select an avatar', 'error');
  }

  // Create profile object with UUID
  const profileData = {
    id: generateUUID(), // Use UUID instead of letting Supabase auto-generate
    name, 
    avatar: selectedAvatar.dataset.avatar
  };

  // Insert into Supabase
  const { data, error } = await supabase
    .from('profiles')
    .insert([profileData])
    .select()
    .single();

  if (error) {
    console.error(error);
    return showNotification('Could not create profile', 'error');
  }

  currentUser = data; // store the profile from DB
  localStorage.setItem('friendle_user', JSON.stringify(currentUser)); // keep local copy for session
  showPage('circles');
  updateProfile();
  processInvite();
}

        function updateProfile() { if (currentUser) { document.getElementById('profile-name').textContent = currentUser.name; document.getElementById('profile-avatar').textContent = currentUser.avatar;
loadMinimumGroupSize(); 
	}
}

async function loadMinimumGroupSize() {
    if (!currentUser) return;
    
    const select = document.getElementById('min-group-size');
    if (select) {
        select.value = currentUser.minimum_group_size || 2;
    }
}

window.saveMinimumGroupSize = async function() {
    const select = document.getElementById('min-group-size');
    const newValue = parseInt(select.value);
    
    try {
        const { error } = await supabase
            .from('profiles')
            .update({ minimum_group_size: newValue })
            .eq('id', currentUser.id);
        
        if (error) throw error;
        
        currentUser.minimum_group_size = newValue;
        localStorage.setItem('friendle_user', JSON.stringify(currentUser));
        
        showNotification('Group size preference updated!');
        
        // Just reload matches (don't call checkForMatches which re-adds you to everything)
        if (selectedCircle) {
            await loadMatches();
        }
    } catch (error) {
        console.error('Error saving minimum group size:', error);
        showNotification('Error saving preference', 'error');
    }
}

window.changeUsername = async function() {
    const newName = document.getElementById('new-username').value.trim();
    
    if (!newName) {
        return showNotification('Please enter a name', 'error');
    }
    
    try {
        const { error } = await supabase
            .from('profiles')
            .update({ name: newName })
            .eq('id', currentUser.id);
        
        if (error) throw error;
        
        currentUser.name = newName;
        localStorage.setItem('friendle_user', JSON.stringify(currentUser));
        
        updateProfile();
        document.getElementById('new-username').value = '';
        
        showNotification('Name updated successfully!');
        
    } catch (error) {
        console.error('Error changing username:', error);
        showNotification('Error updating name', 'error');
    }
}

window.changePassword = async function() {
    const newPassword = document.getElementById('new-password').value;
    const confirmPassword = document.getElementById('confirm-password').value;
    
    if (!newPassword || !confirmPassword) {
        return showNotification('Please fill in both password fields', 'error');
    }
    
    if (newPassword.length < 6) {
        return showNotification('New password must be at least 6 characters', 'error');
    }
    
    if (newPassword !== confirmPassword) {
        return showNotification('Passwords do not match', 'error');
    }
    
    try {
        const { error } = await supabase.auth.updateUser({
            password: newPassword
        });
        
        if (error) throw error;
        
        document.getElementById('new-password').value = '';
        document.getElementById('confirm-password').value = '';
        
        showNotification('Password updated successfully!');
        
    } catch (error) {
        console.error('Error changing password:', error);
        showNotification(error.message || 'Error updating password', 'error');
    }
}

        document.querySelectorAll('.avatar-option').forEach(option => {
            option.addEventListener('click', function() {
                document.querySelectorAll('.avatar-option').forEach(o => o.classList.remove('selected'));
                this.classList.add('selected');
            });
        });

        // Circle Management
        window.showCreateCircle = () => { document.getElementById('create-circle').style.display = 'block'; document.getElementById('circle-modal-overlay').style.display = 'flex'; };
        window.showJoinCircle = () => { document.getElementById('join-circle').style.display = 'block'; document.getElementById('circle-modal-overlay').style.display = 'flex'; };
        window.closeCircleModal = () => { document.getElementById('circle-modal-overlay').style.display = 'none'; document.getElementById('create-circle').style.display = 'none'; document.getElementById('join-circle').style.display = 'none'; };
        window.createCircle = async function() {
  const name = document.getElementById('circle-name').value.trim();
  if (!name) return;

  const code = generateCode();

  // Insert into circles
  const { data: circle, error } = await supabase
    .from('circles')
    .insert([{ name, code, created_by: currentUser.id }])
    .select()
    .single();

  if (error) {
    console.error(error);
    return showNotification('Could not create circle', 'error');
  }

  // Add creator as a member
  await supabase.from('circle_members').insert([{ circle_id: circle.id, profile_id: currentUser.id }]);

  circles.push(circle);
  closeCircleModal();
  renderCircles();
  showNotification(`Circle created! Share code: ${circle.code}`);
}

        
        window.joinCircle = async function() {
  const code = document.getElementById('circle-code').value.trim();
  if (!code) return;

  // Find the circle by code
  const { data: circle, error } = await supabase
    .from('circles')
    .select('*')
    .eq('code', code)
    .single();

  if (error || !circle) {
    return showNotification('Circle not found', 'error');
  }

  // Add user to circle_members
  await supabase.from('circle_members').insert([{ circle_id: circle.id, profile_id: currentUser.id }]);

  circles.push(circle);
  closeCircleModal();
  renderCircles();
  showNotification(`Joined Circle!`);
}

        async function renderCircles() {
  try {
    // Get circles with member counts
    const { data, error } = await supabase
      .from('circle_members')
      .select(`
        circle_id, 
        circles(*),
        profile_id
      `)
      .eq('profile_id', currentUser.id);

    if (error) throw error;

    circles = data.map(d => d.circles);

    // Get member counts for each circle
    const circleIds = circles.map(c => c.id);
    const { data: memberCounts, error: countError } = await supabase
      .from('circle_members')
      .select('circle_id')
      .in('circle_id', circleIds);

    if (countError) throw countError;

    // Count members per circle
    const counts = {};
    memberCounts.forEach(member => {
      counts[member.circle_id] = (counts[member.circle_id] || 0) + 1;
    });

    const list = document.getElementById('circles-list');
    list.innerHTML = circles.map(circle => {
      const memberCount = counts[circle.id] || 0;
      const memberText = memberCount === 1 ? '1 member' : `${memberCount} members`;
      
      return `
        <div class="circle-card">
          <div class="main-content" onclick='selectCircle("${circle.id}")'>
            <div class="circle-name">${circle.name}</div>
            <div class="circle-members">${memberText}</div>
            <div class="circle-code">Invite Code: <strong>${circle.code}</strong></div>
          </div>
          <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 10px;">
    <div style="display: flex; gap: 8px;">
        <button class="btn btn-small btn-secondary" onclick="event.stopPropagation(); copyCircleCode('${circle.code}')" style="flex: 1;">Copy Code</button>
        <button class="btn btn-small btn-secondary" onclick="event.stopPropagation(); inviteByEmail('${circle.name}', '${circle.code}')" style="flex: 1;">Invite</button>
    </div>
    <div style="display: flex; gap: 8px;">
        <button class="btn btn-small btn-secondary" onclick="event.stopPropagation(); renameCircle('${circle.id}')" style="flex: 1;">Rename</button>
        <button class="btn btn-small" onclick="event.stopPropagation(); leaveCircle('${circle.id}')" style="background: #dc3545; flex: 1;">Leave</button>
    </div>
</div>
        </div>`;
    }).join('');
  } catch (error) {
    console.error('Error loading circles:', error);
    circles = [];
  }
}


window.leaveCircle = async function(circleId) {
  if (!confirm("Are you sure you want to leave this circle?")) return;

  // Delete your membership row from circle_members
  const { error } = await supabase
    .from('circle_members')
    .delete()
    .eq('circle_id', circleId)
    .eq('profile_id', currentUser.id);

  if (error) {
    console.error(error);
    return showNotification("Error leaving circle", "error");
  }

  // Refresh circles list
  await renderCircles();
  showNotification("You left the circle.");
};

window.copyCircleCode = function(code) {
    navigator.clipboard.writeText(code).then(() => {
        showNotification('Circle code ' + code + ' copied to clipboard!');
    }).catch(() => {
        const textArea = document.createElement('textarea');
        textArea.value = code;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        showNotification('Circle code ' + code + ' copied to clipboard!');
    });
}

window.inviteByEmail = function(circleName, circleCode) {
    const subject = encodeURIComponent('Join my "' + circleName + '" circle on Friendle');
    const appUrl = 'https://friendle-circles.vercel.app/'; // Update this to your actual URL
    const inviteUrl = appUrl + '?invite_code=' + circleCode;
    
    const body = encodeURIComponent(
    'Hi! I would like to invite you to join my "' + circleName + '" circle on Friendle.\n\n' +
    'Friendle helps friends coordinate activities together.\n\n' +
    'CLICK THIS LINK TO JOIN:\n' +
    inviteUrl + '\n\n' +
    '(Copy and paste the link above into your browser if it does not appear clickable)\n\n' +
    'Or visit ' + appUrl + ' and manually enter code: ' + circleCode + '\n\n' +
    'Looking forward to planning some fun activities together!'
);
    
    const mailtoLink = 'mailto:?subject=' + subject + '&body=' + body;
    window.open(mailtoLink, '_self');
}

window.renameCircle = async function(circleId) {
    const circle = circles.find(c => c.id === circleId);
    const newName = prompt('Enter new circle name:', circle.name);
    
    if (newName && newName.trim() && newName.trim() !== circle.name) {
        try {
            const { error } = await supabase
                .from('circles')
                .update({ name: newName.trim() })
                .eq('id', circleId)
                .eq('created_by', currentUser.id); // Only creator can rename

            if (error) throw error;
            
            showNotification('Circle renamed!');
            renderCircles(); // Refresh the display
        } catch (error) {
            console.error('Error renaming circle:', error);
            showNotification('Error renaming circle', 'error');
        }
    }
}

// Save user preferences to Supabase
async function saveUserPreferences(circleId, selectedActivityIds) {
    try {
        console.log('=== SAVE USER PREFERENCES ===');
        console.log('Circle ID:', circleId);
        console.log('Activity IDs to save:', selectedActivityIds);
        console.log('User ID:', currentUser.id);

        // First, clear existing preferences for this circle
        const { error: deleteError } = await supabase
            .from('preferences')
            .delete()
            .eq('profile_id', currentUser.id)
            .eq('circle_id', circleId);

        if (deleteError) {
            console.error('Delete error:', deleteError);
            throw deleteError;
        }

        console.log('✓ Deleted old preferences');

        // Then insert new preferences (only if there are selections)
        if (selectedActivityIds.length > 0) {
            const preferences = selectedActivityIds.map(activityId => ({
                profile_id: currentUser.id,
                circle_id: circleId,
                activity_id: activityId.toString(),
                selected: true
            }));

            console.log('Inserting preferences:', preferences);

            const { error: insertError } = await supabase
                .from('preferences')
                .insert(preferences);

            if (insertError) {
                console.error('Insert error:', insertError);
                throw insertError;
            }

            console.log('✓ Inserted new preferences');
            
            // Verify what was saved
            const { data: verifyData } = await supabase
                .from('preferences')
                .select('activity_id')
                .eq('profile_id', currentUser.id)
                .eq('circle_id', circleId);
            
            console.log('✓ Verified saved preferences:', verifyData?.map(p => p.activity_id));
        } else {
            console.log('✓ No activities selected, cleared all preferences');
        }
        
        showNotification('Preferences saved!');
    } catch (error) {
        console.error('Error saving preferences:', error);
        showNotification('Error saving preferences', 'error');
    }
}

// Load user preferences from Supabase
async function loadUserPreferences(circleId) {
    try {
        console.log('=== LOAD USER PREFERENCES ===');
        console.log('Circle ID:', circleId);
        console.log('User ID:', currentUser.id);
        
        const { data, error } = await supabase
            .from('preferences')
            .select('activity_id')
            .eq('profile_id', currentUser.id)
            .eq('circle_id', circleId)
            .eq('selected', true);

        if (error) throw error;
        
        const activityIds = data.map(pref => pref.activity_id);
        console.log('Loaded activity IDs:', activityIds);
        
        return activityIds;
    } catch (error) {
        console.error('Error loading preferences:', error);
        return [];
    }
}

        window.selectCircle = async function(circleId) {
    selectedCircle = circles.find(c => c.id === circleId);
    
    // Load preferences from Supabase instead of localStorage
    const savedActivityIds = await loadUserPreferences(selectedCircle.id);
    const allActivities = await loadActivities(selectedCircle.id);
    
    // Rebuild the activities array from saved preferences
    activities = allActivities.filter(activity => savedActivityIds.includes(activity.id));
    
    showPage('activities');
    document.getElementById('activity-circle-name').textContent = selectedCircle.name;
    renderActivities();
}

async function loadActivities(circleId) {
    try {
        const { data: customActivities, error: activitiesError } = await supabase
            .from('activities')
            .select('*')
            .eq('circle_id', circleId);
        
        if (activitiesError) throw activitiesError;
        
        // Get circle-level activity visibility (member-controlled)
        const { data: circleActivities, error: visibilityError } = await supabase
            .from('circle_activities')
            .select('activity_id, is_visible')
            .eq('circle_id', circleId);
        
        if (visibilityError) throw visibilityError;
        
        // Build map of activity visibility
        const visibilityMap = {};
        circleActivities?.forEach(ca => {
            visibilityMap[ca.activity_id] = ca.is_visible;
        });
        
        // Filter default activities based on circle visibility settings
        // If not in map, core activities default to visible, extended default to hidden
        const visibleDefaultActivities = defaultActivities.filter(a => {
            if (visibilityMap.hasOwnProperty(a.id)) {
                return visibilityMap[a.id]; // Use explicit setting
            }
            // Default: core visible, extended hidden
            return coreActivityIds.includes(a.id);
        });
        
        return [...visibleDefaultActivities, ...customActivities];
    } catch (error) {
        console.error('Error loading activities:', error);
        return [];
    }
}

let coreActivityIds = [];
let extendedActivityIds = [];
let defaultActivities = [];

async function loadDefaultActivities() {
    try {
        // Load all default activities from database (where circle_id is null)
        const { data, error } = await supabase
            .from('activities')
            .select('*')
            .is('circle_id', null);
        
        if (error) throw error;
        
        defaultActivities = data;
        
        // Split into core and extended based on a category or naming convention
        // For now, let's say activities with IDs < 200 are core (adjust as needed)
        coreActivityIds = data.filter(a => {
            // Define which activities are "core" - adjust these names as needed
            const coreNames = ['Coffee', 'Dinner', 'Drinks', 'Brunch', 'Pizza Night', 'Ice Cream',
                               'Hiking', 'Beach', 'Bowling', 'Walk in the Park',
                               'Movie', 'Trivia Night', 'Arcade', 'Board Games'];
            return coreNames.includes(a.name);
        }).map(a => a.id);
        
        extendedActivityIds = data.filter(a => !coreActivityIds.includes(a.id)).map(a => a.id);
        
        console.log('Loaded default activities:', defaultActivities);
        console.log('Core activity IDs:', coreActivityIds);
        
    } catch (error) {
        console.error('Error loading default activities:', error);
    }
}
        // Activity Management
        async function renderActivities(searchTerm = '') {
    const frequentGrid = document.getElementById('frequent-grid');
    const activitiesGrid = document.getElementById('activities-grid');
    frequentGrid.innerHTML = ''; 
    activitiesGrid.innerHTML = '';
    
    const sortedCounts = Object.entries(activityCounts).sort(([,a],[,b]) => b-a);
    const frequentIds = sortedCounts.slice(0, 4).map(([id]) => parseInt(id));
    
    // Load activities from both default + Supabase
    const allPossibleActivities = await loadActivities(selectedCircle.id);
    
    const filteredActivities = allPossibleActivities.filter(a => 
        a.name.toLowerCase().includes(searchTerm.toLowerCase())
    );

    const frequentActivities = filteredActivities.filter(a => frequentIds.includes(a.id));
    document.getElementById('frequent-section').style.display = 
        frequentActivities.length > 0 && !searchTerm ? 'block' : 'none';
    frequentActivities.forEach(activity => createActivityCard(activity, frequentGrid));

    const nonFrequentActivities = filteredActivities.filter(a => !frequentIds.includes(a.id));
    nonFrequentActivities.forEach(activity => createActivityCard(activity, activitiesGrid));
}
        function createActivityCard(activity, grid) {
            const card = document.createElement('div');
            card.className = 'activity-card';
            if (activities.some(a => a.id === activity.id)) card.classList.add('selected');
            card.innerHTML = `<div class="activity-emoji">${activity.emoji}</div><div class="activity-name">${activity.name}</div>`;
            card.onclick = (event) => {
                event.stopPropagation();
                toggleActivity(card, activity);
            };
            grid.appendChild(card);
        }
        function toggleActivity(card, activity) {
            lastActivitiesState = [...activities];
            card.classList.toggle('selected');
            const index = activities.findIndex(a => a.id === activity.id);
            if (index > -1) activities.splice(index, 1);
            else activities.push(activity);
        }
        window.handleSearch = (event) => renderActivities(event.target.value);
        window.selectBulk = function(type) {
            lastActivitiesState = [...activities];
            const all = [...defaultActivities, ...(selectedCircle.customActivities || [])];
            activities = type === 'clear' ? [] : all.filter(a => a.category === type);
            renderActivities();
        }
        window.saveActivities = async function() {
    if (!selectedCircle) return showNotification('Please select a circle first', 'error');
    
    console.log('=== SAVING ACTIVITIES ===');
    console.log('Current user:', currentUser.id);
    console.log('Selected circle:', selectedCircle.id);
    console.log('Selected activities:', activities);
    
    const selectedActivityIds = activities.map(activity => activity.id);
    console.log('Activity IDs to save:', selectedActivityIds);
    
    // Get previously selected activities to find what was deselected
    const previousPrefs = await loadUserPreferences(selectedCircle.id);
    const deselectedActivityIds = previousPrefs.filter(id => !selectedActivityIds.includes(id));
    
    console.log('Deselected activities:', deselectedActivityIds);
    
    // For each deselected activity, check if user has any events
    for (const activityId of deselectedActivityIds) {
        // Find the match for this activity
        const { data: match } = await supabase
            .from('matches')
            .select('id')
            .eq('circle_id', selectedCircle.id)
            .eq('activity_id', activityId)
            .single();
        
        if (match) {
            // Check if user has any events for this match
            const { data: userEvents } = await supabase
                .from('event_participants')
                .select('event_id, events!inner(match_id)')
                .eq('profile_id', currentUser.id)
                .eq('events.match_id', match.id);
            
            // If no events, remove user from match participants
            if (!userEvents || userEvents.length === 0) {
                console.log(`Removing user from match ${match.id} (no events joined)`);
                
                await supabase
                    .from('match_participants')
                    .delete()
                    .eq('match_id', match.id)
                    .eq('profile_id', currentUser.id);
            } else {
                console.log(`Keeping user in match ${match.id} (has ${userEvents.length} event(s))`);
            }
        }
    }
    
    // Save new preferences
    await saveUserPreferences(selectedCircle.id, selectedActivityIds);
    
    activities.forEach(act => { 
        activityCounts[act.id] = (activityCounts[act.id] || 0) + 1; 
    });
    localStorage.setItem('friendle_activity_counts', JSON.stringify(activityCounts));
    
    console.log('=== CHECKING FOR MATCHES ===');
    await checkForMatches();
    
    // Reload matches to reflect changes
    await loadMatches();
    
    showPage('matches');
}
        window.openSuggestModal = () => document.getElementById('suggest-modal-overlay').style.display = 'flex';
        window.closeSuggestModal = () => document.getElementById('suggest-modal-overlay').style.display = 'none';
        window.suggestActivity = async function() {
    const name = document.getElementById('suggest-name').value.trim();
    if (!name) { 
        return showNotification('Please provide an activity name', 'error'); 
    }

    try {
        const { data, error } = await supabase
            .from('activities')
            .insert([{
                name: name,
                emoji: '💡', // Always use lightbulb
                category: 'custom',
                circle_id: selectedCircle.id
            }])
            .select()
            .single();

        if (error) throw error;
        
        showNotification(`Activity "${name}" added!`);
        closeSuggestModal();
        
        // Reload user's actual preferences before re-rendering
        const savedActivityIds = await loadUserPreferences(selectedCircle.id);
        const allActivities = await loadActivities(selectedCircle.id);
        activities = allActivities.filter(activity => savedActivityIds.includes(activity.id));
        
        renderActivities();
    } catch (error) {
        console.error('Error adding custom activity:', error);
        showNotification('Error adding activity', 'error');
    }
}
        function showUndo() {
            const undoContainer = document.getElementById('undo-container');
            undoContainer.style.display = 'flex';
            clearTimeout(undoTimeout);
            undoTimeout = setTimeout(() => {
                undoContainer.style.display = 'none';
            }, 8000);
        }
        window.undoLastActivityChange = function() {
            activities = [...lastActivitiesState];
            renderActivities();
            document.getElementById('undo-container').style.display = 'none';
            clearTimeout(undoTimeout);
        }
// Replace your findMatches function with this version:
async function findMatches(circleId) {
    try {
        // Get current user's preferences
        const userPrefs = await loadUserPreferences(circleId);
        if (userPrefs.length === 0) {
            return [];
        }

        const groupMatches = [];

        // For each activity the user likes, find or create a group match
        for (const activityId of userPrefs) {
            // Check if a group match already exists for this activity in this circle
const { data: existingMatch, error: matchError } = await supabase
    .from('matches')
    .select('*, activities(*)')
    .eq('circle_id', circleId)
    .eq('activity_id', activityId)
    .maybeSingle();

if (matchError && matchError.code !== 'PGRST116') {
    console.error('Error checking for existing match:', matchError);
    continue;
}

// If match exists, get participants
if (existingMatch) {
    const { data: participants } = await supabase
        .from('match_participants')
        .select('profile_id, profiles(id, name, avatar)')
        .eq('match_id', existingMatch.id);
    
    existingMatch.match_participants = participants || [];
}

let match;

if (existingMatch) {
    // Group match exists, check if user is already in it
    const isUserInGroup = existingMatch.match_participants.some(p => p.profile_id === currentUser.id);
    
    if (!isUserInGroup) {
        console.log('Adding user to existing match:', existingMatch.id);
        
        // Add user to existing group
        await supabase
            .from('match_participants')
            .insert([{ match_id: existingMatch.id, profile_id: currentUser.id }]);
        
        // Auto-add to any upcoming events for this match
        await autoAddToUpcomingEvents(existingMatch.id, currentUser.id);
    }
    
    match = existingMatch;
} else {
    // Create new group match (NO AUTO-EVENT CREATION)
    const { data: newMatch, error: createError } = await supabase
        .from('matches')
        .insert([{
            circle_id: circleId,
            activity_id: activityId
        }])
        .select('*, activities(*)')
        .single();

    if (createError) {
        console.error('Error creating match:', createError);
        continue;
    }

    // Add current user as first participant
    await supabase
        .from('match_participants')
        .insert([{ match_id: newMatch.id, profile_id: currentUser.id }]);

    match = { ...newMatch, match_participants: [{ profile_id: currentUser.id, profiles: currentUser }] };
}

            // Get all participants for this match
            const { data: participants, error: participantError } = await supabase
                .from('match_participants')
                .select(`
                    profile_id,
                    profiles(id, name, avatar)
                `)
                .eq('match_id', match.id)
                .neq('profile_id', currentUser.id); // Exclude current user

            if (participantError) {
                console.error('Error loading participants:', participantError);
                continue;
            }

            // Only show matches that have other participants
            if (participants.length > 0) {
                groupMatches.push({
                    id: match.id,
                    isGroupChat: participants.length > 1, // True if more than 2 total people
                    circleId: circleId,
                    users: participants.map(p => p.profiles),
                    activity: match.activities,
                    isRead: false,
                    scheduledDate: match.scheduled_date ? new Date(match.scheduled_date) : null
                });
            }
        }

        return groupMatches;
    } catch (error) {
        console.error('Error finding matches:', error);
        return [];
    }
}
// Save matches to Supabase
async function saveMatchesToSupabase(matches, circleId) {
    try {
        // Clear existing matches for this user and circle
        await supabase
            .from('matches')
            .delete()
            .eq('circle_id', circleId);

        // Insert new matches
        if (matches.length > 0) {
            const matchData = matches.map(match => ({
                id: match.id,
                circle_id: circleId,
                activity_id: match.activity.id
                // Note: We'll need to modify your matches table structure to store user pairs
            }));

            const { error } = await supabase
                .from('matches')
                .insert(matchData);

            if (error) throw error;
        }
    } catch (error) {
        console.error('Error saving matches:', error);
    }
}
        // Match System
        async function checkForMatches() {
    if (!selectedCircle) return;
    
    console.log('Finding matches for circle:', selectedCircle.id);
    
    // Find real matches based on preferences
    const foundMatches = await findMatches(selectedCircle.id);
    
    // Update global matches array
    matches = foundMatches;
    
    console.log('Found matches:', matches);
    
    // Save to localStorage for now (we can migrate this later)
    localStorage.setItem('friendle_matches', JSON.stringify(matches));
    
    updateNotificationBadge();

if (matches.length > 0) {
    showNotification(`Found ${matches.length} new matches!`);
    
    // Show browser notification
showNotificationAlert(
    'New Activity Matches!',
    `You have ${matches.length} new friend${matches.length > 1 ? 's' : ''} ready to hang out`,
    null,
    true
);
} else {
    showNotification('No matches found yet. Try selecting more activities or invite more friends!');
}
}

async function loadMatches() {
    if (!currentUser) return;
    
    try {
        // Get matches where user is a participant
        const { data: userMatches, error: matchError } = await supabase
            .from('match_participants')
            .select(`
                match_id,
                matches!inner(
                    id,
                    activity_id,
                    circle_id,
                    created_at
                )
            `)
            .eq('profile_id', currentUser.id);
        
        if (matchError) throw matchError;
        
        // Extract match data
        matches = userMatches.map(um => um.matches);
        
        // Get participant names for each match
        for (let match of matches) {
            const { data: participants, error: participantError } = await supabase
                .from('match_participants')
                .select(`
                    profile_id,
                    profiles(name)
                `)
                .eq('match_id', match.id);
            
            if (!participantError) {
                match.participant_names = participants.map(p => p.profiles.name);
            }
            
            // LOAD ACTIVITIES FOR THIS CIRCLE if not already loaded
            if (activities.length === 0 || (activities.length > 0 && activities[0].circle_id !== match.circle_id)) {
                const allActivities = await loadActivities(match.circle_id);
                activities = allActivities;
            }
        }
        
        // Display matches
        await displayMatches();
        
    } catch (error) {
        console.error('Error loading matches:', error);
    }
}

window.renderMatches = function() {
    const list = document.getElementById('matches-list');
    const showPastEvents = document.getElementById('show-past-events')?.checked ?? true;
    const searchTerm = document.getElementById('matches-search')?.value.toLowerCase() || '';
    
    // Filter matches based on toggle and search
    let filteredMatches = matches;
    
    if (!showPastEvents) {
        filteredMatches = filteredMatches.filter(match => {
            if (!match.scheduledDate) return true;
            const scheduledDate = new Date(match.scheduledDate);
            const today = new Date();
            return scheduledDate >= today;
        });
    }
    
    if (searchTerm) {
        filteredMatches = filteredMatches.filter(match => {
            const userName = match.users.map(u => u.name).join(' ').toLowerCase();
            const activityName = match.activity?.name.toLowerCase() || '';
            return userName.includes(searchTerm) || activityName.includes(searchTerm);
        });
    }
    
    // Filter by minimum group size
    const minGroupSize = currentUser.minimum_group_size || 2;
    filteredMatches = filteredMatches.filter(match => {
        const totalParticipants = match.users.length + 1; // +1 for current user
        return totalParticipants >= minGroupSize;
    });
    
    if (filteredMatches.length === 0) {
        const message = searchTerm ? 
            'No matches found for your search.' :
            (showPastEvents ? 'No matches yet.' : 'No upcoming events. Check "Show past events" to see completed activities.');
        return list.innerHTML = `<div style="text-align: center; margin: 40px 0; color: #666;">${message}</div>`;
    }
    
    list.innerHTML = filteredMatches.map(match => {
        const title = match.isGroupChat ? 
            `${match.activity.name} Group` : 
            `${match.users[0].name} - ${match.activity.name}`;
        
        const members = match.isGroupChat ? 
            `${match.users.length + 1} members` : 
            'Chat ready';

        return `
        <div class="circle-card" onclick='openChat(${JSON.stringify(match)})'>
            <div style="display: flex; align-items: center; gap: 15px;">
                <div style="font-size: 1.5em;">${match.activity.emoji}</div>
                <div style="flex: 1;">
                    <div class="circle-name">${title}</div>
                    <div class="circle-members">${members}</div>
                </div>
                <div style="color: #667eea; font-size: 1.2em;">${!match.isRead ? '🔔' : (match.isGroupChat ? '👥' : '💬')}</div>
            </div>
        </div>`;
    }).join('');
}
        async function displayMatches() {
    const matchesList = document.getElementById('matches-list');
    
    if (!matches || matches.length === 0) {
        matchesList.innerHTML = '<p>No matches yet. Select some activities to get started!</p>';
        return;
    }

    if (activities.length === 0 && matches.length > 0) {
        const firstMatch = matches[0];
        const allActivities = await loadActivities(firstMatch.circle_id);
        activities = allActivities;
    }

    const matchesWithEvents = await Promise.all(
        matches.map(async (match) => {
            const { data: events, error } = await supabase
                .from('events')
                .select(`
                    *,
                    event_participants!inner(profile_id, status),
                    event_messages(id)
                `)
                .eq('match_id', match.id)
                .eq('event_participants.profile_id', currentUser.id)
                .order('scheduled_date', { ascending: true });
            
            return { match, events: events || [] };
        })
    );

    matchesList.innerHTML = matchesWithEvents.map(({ match, events }) => {
        const activity = activities.find(a => a.id === match.activity_id);
        const activityName = activity ? activity.name : 'Unknown Activity';
        const activityEmoji = activity ? activity.emoji : '🎯';
        
        // Compare dates at midnight to include events happening today
const now = new Date();
const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

const upcomingEvents = events.filter(e => 
    new Date(e.scheduled_date) >= today && e.status === 'scheduled'
);
        const pastEvents = events.filter(e => 
            new Date(e.scheduled_date) < today || e.status !== 'scheduled'
        );

        return `
            <div class="match-card" style="margin-bottom: 20px; padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 15px;">
    <div style="flex: 1;">
        <h3 style="margin: 0 0 8px 0;">${activityEmoji} ${activityName}</h3>
        <p style="margin: 0; color: #666; font-size: 14px;">
            ${match.participant_names ? match.participant_names.join(', ') : 'Loading participants...'}
        </p>
    </div>
    <div style="display: flex; gap: 8px;">
        <button onclick="openMatchChat('${match.id}')" class="btn btn-secondary" style="font-size: 14px; padding: 8px 16px; width: auto; margin: 0;">
            💬 Chat
        </button>
        <button onclick="openCreateEventModal('${match.id}')" class="btn" style="font-size: 14px; padding: 8px 16px; width: auto; margin: 0;">
            + Schedule
        </button>
    </div>
</div>
                
                ${upcomingEvents.length > 0 ? `
    <div style="margin-bottom: 10px;">
        <h4 style="margin: 0 0 8px 0; font-size: 14px; color: #666; font-weight: 600;">Upcoming</h4>
        ${upcomingEvents.map(event => {
            const date = new Date(event.scheduled_date);
            const dateStr = date.toLocaleDateString('en-US', { 
                weekday: 'short', 
                month: 'short', 
                day: 'numeric'
            });
            
            return `
                <div class="event-item" style="padding: 10px; margin-bottom: 6px; background: #f5f5f5; border-radius: 6px; border-left: 4px solid #4CAF50;">
                    <div style="display: flex; justify-content: space-between; align-items: center; gap: 10px;">
                        <div style="flex: 1;">
                            <div style="font-weight: 500; margin-bottom: 2px;">📅 ${dateStr}</div>
                            ${event.location ? `<div style="color: #666; font-size: 13px;">📍 ${event.location}</div>` : ''}
                        </div>
                        <button onclick="event.stopPropagation(); openEventChat('${event.id}');" class="btn btn-secondary" style="font-size: 13px; padding: 6px 12px; width: auto; margin: 0; white-space: nowrap;">
                            💬 Event Chat
                        </button>
                    </div>
                </div>
            `;
        }).join('')}
    </div>
` : `
                    <div style="padding: 15px; background: #f9f9f9; border-radius: 6px; text-align: center; color: #666; font-size: 14px; border: 1px dashed #ddd;">
                        💬 No events scheduled yet - schedule something!
                    </div>
                `}
                
                ${pastEvents.length > 0 ? `
                    <details style="margin-top: 10px;">
                        <summary style="cursor: pointer; color: #666; font-size: 14px;">Past Events (${pastEvents.length})</summary>
                        <div style="margin-top: 8px;">
                            ${pastEvents.map(event => {
                                const date = new Date(event.scheduled_date);
                                const dateStr = date.toLocaleDateString('en-US', { 
                                    month: 'short', 
                                    day: 'numeric'
                                });
                                const statusEmoji = event.status === 'completed' ? '✅' : event.status === 'cancelled' ? '❌' : '📅';
                                
                                return `
    <div class="event-item" style="padding: 8px; margin-bottom: 4px; background: #fafafa; border-radius: 4px; opacity: 0.7; font-size: 13px; display: flex; justify-content: space-between; align-items: center;">
        <div>
            ${statusEmoji} ${dateStr}${event.location ? ` · ${event.location}` : ''}
        </div>
        <button onclick="openEventChat('${event.id}')" class="btn btn-secondary" style="font-size: 12px; padding: 4px 8px; width: auto; margin: 0; opacity: 1;">
            Chat
        </button>
    </div>
`;
                            }).join('')}
                        </div>
                    </details>
                ` : ''}
            </div>
        `;
    }).join('');

    document.querySelectorAll('.event-item').forEach(item => {
        item.addEventListener('mouseenter', function() {
            this.style.background = '#e8e8e8';
        });
        item.addEventListener('mouseleave', function() {
            if (this.style.opacity === '0.7') {
                this.style.background = '#fafafa';
            } else {
                this.style.background = '#f5f5f5';
            }
        });
    });
}
        
async function sendMessageToSupabase(matchId, content, type = 'text', extraData = {}) {
    try {
        const { data, error } = await supabase
            .from('messages')
            .insert([{
                match_id: matchId,
                sender_id: currentUser.id,
                content: content,
                type: type,
                lat: extraData.lat || null,
                lng: extraData.lng || null
            }])
            .select(`
                *,
                profiles(id, name, avatar)
            `)
            .single();

        if (error) throw error;
        return data;
    } catch (error) {
        console.error('Error sending message:', error);
        return null;
    }
}

// Load messages from Supabase for a match
async function loadMessagesFromSupabase(matchId) {
    try {
        const { data, error } = await supabase
            .from('messages')
            .select(`
                *,
                profiles(id, name, avatar)
            `)
            .eq('match_id', matchId)
            .order('created_at', { ascending: true });

        if (error) throw error;
        return data || [];
    } catch (error) {
        console.error('Error loading messages:', error);
        return [];
    }
}

        // Chat System
        window.openChat = async function(match) {
    currentChatMatch = matches.find(m => m.id === match.id);
    if(currentChatMatch) currentChatMatch.isRead = true;
    
    // Set chat header for group or individual chat
    const chatName = currentChatMatch.isGroupChat ? 
        `${currentChatMatch.activity.name} Group` : 
        currentChatMatch.users[0].name;
    
    const chatAvatar = currentChatMatch.isGroupChat ? 
        currentChatMatch.activity.emoji : 
        currentChatMatch.users[0].avatar;
    
    document.getElementById('chat-name').textContent = chatName;
    document.getElementById('chat-avatar').textContent = chatAvatar;
    
    // Update subtitle for group chats
    const subtitle = currentChatMatch.isGroupChat ? 
        `${currentChatMatch.users.length + 1} members: You, ${currentChatMatch.users.map(u => u.name).join(', ')}` :
        currentChatMatch.activity.name;
    
    document.getElementById('chat-activity').textContent = subtitle;

    // Load messages from Supabase
    const supabaseMessages = await loadMessagesFromSupabase(currentChatMatch.id);
    
    // Convert Supabase messages to your existing format
messages[currentChatMatch.id] = supabaseMessages.map(msg => ({
    id: msg.id,
    sender: msg.profiles.name,
    sender_id: msg.sender_id,  // ADD THIS LINE
    content: msg.content,
    type: msg.type,
    lat: msg.lat,
    lng: msg.lng,
    created_at: msg.created_at,
    isRead: true
}));

    renderChatMessages(); 
    showPage('chat');
    
    // Set up real-time subscription for this chat
    setupRealtimeMessages(currentChatMatch.id);
    
    localStorage.setItem('friendle_matches', JSON.stringify(matches));
    localStorage.setItem('friendle_messages', JSON.stringify(messages));
    localStorage.setItem('friendle_current_chat', JSON.stringify(currentChatMatch));    
updateNotificationBadge();
}

window.leaveChat = async function() {
    // Clean up real-time subscription
    cleanupRealtimeMessages();
    localStorage.removeItem('friendle_current_chat');
    
    if (!confirm('Change of plans? You can rejoin by reselecting this activity.')) {
        return;
    }
    
    try {
        // Remove user from match participants
        const { error: deleteError } = await supabase
            .from('match_participants')
            .delete()
            .eq('match_id', currentChatMatch.id)
            .eq('profile_id', currentUser.id);
        
        if (deleteError) throw deleteError;
        
        // Also remove this activity from user's preferences
        const { error: prefError } = await supabase
            .from('preferences')
            .delete()
            .eq('profile_id', currentUser.id)
            .eq('circle_id', currentChatMatch.circleId)
            .eq('activity_id', currentChatMatch.activity.id);
        
        if (prefError) throw prefError;
        
        // Update local activities array to remove this activity
        const activityIndex = activities.findIndex(a => a.id === currentChatMatch.activity.id);
        if (activityIndex > -1) {
            activities.splice(activityIndex, 1);
        }
        
        // Remove from local matches array
        const matchIndex = matches.findIndex(m => m.id === currentChatMatch.id);
        if (matchIndex > -1) {
            matches.splice(matchIndex, 1);
            localStorage.setItem('friendle_matches', JSON.stringify(matches));
        }
        
        showNotification('You left the chat');
        showPage('matches');
        renderMatches();
        
    } catch (error) {
        console.error('Error leaving chat:', error);
        showNotification('Error leaving chat', 'error');
    }
}
        function renderChatMessages() {
    console.log('🎬 renderChatMessages called');
    const chatMessages = document.getElementById('chat-messages');
    console.log('Chat container:', chatMessages);
    console.log('Messages to render:', messages[currentChatMatch.id]);
    chatMessages.innerHTML = '';
    (messages[currentChatMatch.id] || []).forEach(msg => {
        const div = document.createElement('div');
        
        // Determine if this message is from current user by comparing IDs
        const isOwnMessage = msg.sender_id === currentUser.id;
        
        div.className = `message ${isOwnMessage ? 'own' : ''} ${msg.type === 'system' ? 'system' : ''}`;
        let bubble = '';
        if (msg.type === 'photo') bubble = `<img src="${msg.content}" class="message-photo" onclick="openImageModal('${msg.content}')">`;
        else if (msg.type === 'location') bubble = `<div class="message-location" onclick="openMap(${msg.lat}, ${msg.lng})">📍 Location Shared</div>`;
        else if (msg.type === 'text') bubble = `<div class="message-bubble">${msg.content}</div>`;
        else { div.textContent = msg.content; }
        
        if (msg.type !== 'system') {
            const senderName = isOwnMessage ? 'You' : msg.sender;
            const avatar = isOwnMessage ? currentUser.avatar : (currentChatMatch.users.find(u => u.name === msg.sender)?.avatar || '👤');
            
            const timestamp = msg.created_at ? 
                new Date(msg.created_at + 'Z').toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';

            div.innerHTML = `
                <div class="message-avatar">${avatar}</div>
                <div class="message-content">
                    <div class="message-sender">${senderName}${timestamp ? '<span class="message-timestamp">' + timestamp + '</span>' : ''}</div>
                    ${bubble}
                </div>`;
            
            // Add message actions using DOM manipulation for own messages
            if (isOwnMessage) {
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'message-actions';
                
                const actionsBtn = document.createElement('button');
                actionsBtn.className = 'message-actions-btn';
                actionsBtn.textContent = '...';
                actionsBtn.onclick = () => toggleMessageActions(msg.id);
                
                const actionsMenu = document.createElement('div');
                actionsMenu.className = 'message-actions-menu';
                actionsMenu.id = `menu-${msg.id}`;
                
                const editBtn = document.createElement('button');
                editBtn.textContent = 'Edit';
                editBtn.onclick = () => editMessage(msg.id);
                
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.onclick = () => deleteMessage(msg.id);
                
                actionsMenu.appendChild(editBtn);
                actionsMenu.appendChild(deleteBtn);
                actionsDiv.appendChild(actionsBtn);
                actionsDiv.appendChild(actionsMenu);
                div.appendChild(actionsDiv);
            }
        }
        chatMessages.appendChild(div);
    });
    // Force scroll after DOM updates
setTimeout(() => {
    chatMessages.scrollTop = chatMessages.scrollHeight;
}, 100);
    const banner = document.getElementById('scheduled-event-banner-container');
    banner.innerHTML = currentChatMatch.scheduledDate ? `<div class="scheduled-event-banner">🗓️ Event scheduled for ${new Date(currentChatMatch.scheduledDate).toLocaleDateString()}</div>` : '';
}
        window.sendMessage = async function() {
    const input = document.getElementById('message-input');
    if (!input.value.trim()) return;
    
    // Check if we're in an event chat or old-style match chat
    if (currentEvent) {
        // Use event message function
        const fakeEvent = { preventDefault: () => {} };
        await sendEventMessage(fakeEvent);
    } else if (currentChatMatch) {
        // Old match chat logic (keep for backward compatibility)
        console.log('Sending message, current user:', currentUser);
        
        const savedMessage = await sendMessageToSupabase(currentChatMatch.id, input.value.trim(), 'text');
        
        if (savedMessage) {
            const message = {
                id: savedMessage.id,
                sender: currentUser.name,
                sender_id: currentUser.id,
                content: savedMessage.content,
                type: savedMessage.type,
                lat: savedMessage.lat,
                lng: savedMessage.lng,
                created_at: savedMessage.created_at,
                isRead: true
            };
            
            if (!messages[currentChatMatch.id]) messages[currentChatMatch.id] = [];
            messages[currentChatMatch.id].push(message);
            
            const channel = supabase.channel(`match_${currentChatMatch.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'new_message',
                payload: {
                    id: savedMessage.id,
                    sender_id: currentUser.id,
                    sender_name: currentUser.name,
                    content: savedMessage.content,
                    type: savedMessage.type,
                    lat: savedMessage.lat,
                    lng: savedMessage.lng,
                    created_at: savedMessage.created_at
                }
            });
            
            localStorage.setItem('friendle_messages', JSON.stringify(messages));
            renderChatMessages();
        }
        
        input.value = '';
    }
}
        async function addMessage(content, type, extraData = {}) {
    // Send to Supabase
    const savedMessage = await sendMessageToSupabase(currentChatMatch.id, content, type, extraData);
    
    if (savedMessage) {
        // Add to local messages for immediate display
        const message = {
            id: savedMessage.id,
            sender: currentUser.name,
            content: savedMessage.content,
            type: savedMessage.type,
            lat: savedMessage.lat,
            lng: savedMessage.lng,
            isRead: true
        };
        
        if (!messages[currentChatMatch.id]) messages[currentChatMatch.id] = [];
        messages[currentChatMatch.id].push(message);
        
        localStorage.setItem('friendle_messages', JSON.stringify(messages));
        renderChatMessages();
    }
}
        function simulateResponse() {
            const otherUsers = currentChatMatch.users.filter(u => u.name !== currentUser.name);
            const randomUser = otherUsers[Math.floor(Math.random() * otherUsers.length)];
            const response = { id: Date.now(), sender: randomUser.name, content: "Sounds good! 👍", isRead: false, type: 'text' };
            if (!messages[currentChatMatch.id]) messages[currentChatMatch.id] = [];
            messages[currentChatMatch.id].push(response);
            localStorage.setItem('friendle_messages', JSON.stringify(messages));
            if (document.getElementById('chat').classList.contains('active')) renderChatMessages();
            updateNotificationBadge();
        }
        window.handleMessageKeyPress = e => { if (e.key === 'Enter') sendMessage(); };
        window.openDateModal = () => document.getElementById('date-modal-overlay').style.display = 'flex';
        window.closeDateModal = () => document.getElementById('date-modal-overlay').style.display = 'none';
        window.saveEvent = async function() {
    const date = document.getElementById('event-date').value;
    if (!date) return;
    const eventDate = new Date(date.replace(/-/g, '/'));
    
    try {
        // Save to Supabase
        const { error } = await supabase
            .from('matches')
            .update({ scheduled_date: eventDate.toISOString() })
            .eq('id', currentChatMatch.id);

        if (error) throw error;

        // Update local data
        currentChatMatch.scheduledDate = eventDate;
        const matchIndex = matches.findIndex(m => m.id === currentChatMatch.id);
        if (matchIndex > -1) {
            matches[matchIndex].scheduledDate = eventDate;
        }
        
        localStorage.setItem('friendle_matches', JSON.stringify(matches));
        addMessage(`📅 ${currentUser.name} scheduled this for ${eventDate.toLocaleDateString()}`, 'system');
        closeDateModal();
    } catch (error) {
        console.error('Error saving event:', error);
        showNotification('Error saving event', 'error');
    }
}
        window.toggleMessageActions = function(msgId) {
            const menu = document.getElementById(`menu-${msgId}`);
            menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
        }
window.toggleEventMessageActions = function(msgId) {
    const menu = document.getElementById(`event-menu-${msgId}`);
    if (menu) {
        menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
    }
    
    // Close other open menus
    document.querySelectorAll('.message-actions-menu').forEach(m => {
        if (m.id !== `event-menu-${msgId}`) {
            m.style.display = 'none';
        }
    });
}

window.editEventMessage = async function(msgId, currentContent) {
    // Close the menu
    const menu = document.getElementById(`event-menu-${msgId}`);
    if (menu) menu.style.display = 'none';
    
    // Check if this is a special message type (photo, location, search link)
    if (currentContent.includes('<img') || currentContent.includes('<a')) {
        showNotification('Photos and links cannot be edited, only deleted', 'error');
        return;
    }
    
    const newContent = prompt('Edit your message:', currentContent);
    
    if (!newContent || newContent.trim() === currentContent.trim()) return;
    
    try {
        if (currentMatchChat) {
            const { error } = await supabase
                .from('match_messages')
                .update({ content: newContent.trim() })
                .eq('id', msgId)
                .eq('sender_id', currentUser.id);
            
            if (error) throw error;
            
            const channel = supabase.channel(`match_chat_${currentMatchChat.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'message_edited',
                payload: {
                    id: msgId,
                    content: newContent.trim()
                }
            });
            
            await loadMatchMessages(currentMatchChat.id);
        } else if (currentEvent) {
            const { error } = await supabase
                .from('event_messages')
                .update({ content: newContent.trim() })
                .eq('id', msgId)
                .eq('sender_id', currentUser.id);
            
            if (error) throw error;
            
            const channel = supabase.channel(`event_${currentEvent.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'message_edited',
                payload: {
                    id: msgId,
                    content: newContent.trim()
                }
            });
            
            await loadEventMessages(currentEvent.id, currentEvent.created_at);
        }
        
        showNotification('Message updated');
        
    } catch (error) {
        console.error('Error editing message:', error);
        showNotification('Failed to edit message', 'error');
    }
}

window.deleteEventMessage = async function(msgId) {
    const menu = document.getElementById(`event-menu-${msgId}`);
    if (menu) menu.style.display = 'none';
    
    if (!confirm('Delete this message?')) return;
    
    try {
        if (currentMatchChat) {
            const { error } = await supabase
                .from('match_messages')
                .delete()
                .eq('id', msgId)
                .eq('sender_id', currentUser.id);
            
            if (error) throw error;
            
            const channel = supabase.channel(`match_chat_${currentMatchChat.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'message_deleted',
                payload: {
                    id: msgId
                }
            });
            
            await loadMatchMessages(currentMatchChat.id);
        } else if (currentEvent) {
            const { error } = await supabase
                .from('event_messages')
                .delete()
                .eq('id', msgId)
                .eq('sender_id', currentUser.id);
            
            if (error) throw error;
            
            const channel = supabase.channel(`event_${currentEvent.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'message_deleted',
                payload: {
                    id: msgId
                }
            });
            
            await loadEventMessages(currentEvent.id, currentEvent.created_at);
        }
        
        showNotification('Message deleted');
        
    } catch (error) {
        console.error('Error deleting message:', error);
        showNotification('Failed to delete message', 'error');
    }
}
        window.editMessage = async function(msgId) {
    const message = messages[currentChatMatch.id].find(m => m.id === msgId);
    const newContent = prompt('Edit your message:', message.content);
    if (newContent) {
        try {
            const { error } = await supabase
                .from('messages')
                .update({ content: newContent })
                .eq('id', msgId)
                .eq('sender_id', currentUser.id); // Only allow editing own messages

            if (error) throw error;

            // Update local message
            message.content = newContent;
            localStorage.setItem('friendle_messages', JSON.stringify(messages));
            renderChatMessages();
        } catch (error) {
            console.error('Error editing message:', error);
            showNotification('Error editing message', 'error');
        }
    }
}
        window.deleteMessage = async function(msgId) {
    if (!confirm('Delete this message?')) return;
    
    try {
        const { error } = await supabase
            .from('messages')
            .delete()
            .eq('id', msgId)
            .eq('sender_id', currentUser.id); // Only allow deleting own messages

        if (error) throw error;

        // Remove from local messages
        const index = messages[currentChatMatch.id].findIndex(m => m.id === msgId);
        if (index > -1) {
            messages[currentChatMatch.id].splice(index, 1);
            localStorage.setItem('friendle_messages', JSON.stringify(messages));
            renderChatMessages();
        }
    } catch (error) {
        console.error('Error deleting message:', error);
        showNotification('Error deleting message', 'error');
    }
}

// Global variable to track current event
let currentEvent = null;
let eventMessageSubscription = null;

// Open modal to create new event
function openCreateEventModal(matchId) {
    const match = matches.find(m => m.id === matchId);
    if (!match) return;
    
    document.getElementById('new-event-match-id').value = matchId;
    document.getElementById('create-event-form').reset();
    
    // Set min date to today
    const today = new Date();
    document.getElementById('new-event-date').min = today.toISOString().slice(0, 10);
    
    document.getElementById('create-event-modal').style.display = 'flex';
}

function closeCreateEventModal() {
    document.getElementById('create-event-modal').style.display = 'none';
}

// Create new event
async function createEvent(e) {
    e.preventDefault();
    
    const matchId = document.getElementById('new-event-match-id').value;
    const match = matches.find(m => m.id === matchId);
    
    try {
        // Create the event
        const { data: newEvent, error: eventError } = await supabase
            .from('events')
            .insert({
                match_id: matchId,
                activity_id: match.activity_id,
                circle_id: match.circle_id,
                scheduled_date: document.getElementById('new-event-date').value,
                location: document.getElementById('new-event-location').value || null,
                notes: document.getElementById('new-event-notes').value || null,
                created_by: currentUser.id,
                status: 'scheduled'
            })
            .select()
            .single();
        
        if (eventError) throw eventError;
        
        // Get ALL current match participants (not just at creation time)
        const { data: matchParticipants, error: participantsError } = await supabase
            .from('match_participants')
            .select('profile_id')
            .eq('match_id', matchId);
        
        if (participantsError) throw participantsError;
        
        const eventParticipants = matchParticipants.map(p => ({
            event_id: newEvent.id,
            profile_id: p.profile_id,
            status: 'accepted'
        }));
        
        const { error: insertError } = await supabase
            .from('event_participants')
            .insert(eventParticipants);
        
        if (insertError) throw insertError;
        
        closeCreateEventModal();
        
        // Refresh matches to show new event
        await loadMatches();
        
        // Open the new event chat
        openEventChat(newEvent.id);
        
    } catch (error) {
        console.error('Error creating event:', error);
        alert('Failed to create event. Please try again.');
    }
}

// Auto-add new users to upcoming events when they join a match
async function autoAddToUpcomingEvents(matchId, newUserId) {
    try {
        // Check auth status
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        console.log('=== AUTH CHECK ===');
        console.log('Auth error:', authError);
        console.log('Authenticated user ID:', user?.id);
        console.log('Target user ID:', newUserId);
        console.log('Match?', user?.id === newUserId);
        
        if (!user) {
            console.error('No authenticated user - RLS will block all queries');
            return;
        }
        
        console.log('=== AUTO-ADD TO UPCOMING EVENTS ===');
        console.log('Match ID:', matchId);
        console.log('New User ID:', newUserId);
        
        // Find all upcoming events for this match
// Use current date in UTC for comparison
const now = new Date();
const todayUTC = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));

console.log('Querying with match_id:', matchId);
console.log('Querying with date >=', todayUTC.toISOString());

// Try the simplest possible query first
const { data: testQuery, error: testError } = await supabase
    .from('events')
    .select('*')
    .eq('match_id', matchId);

console.log('TEST - Simple query for all events in match:');
console.log('Error:', testError);
console.log('Result:', testQuery);

// Now try with filters
const { data: upcomingEvents, error: eventsError } = await supabase
    .from('events')
    .select('id, scheduled_date, location, status')
    .eq('match_id', matchId)
    .eq('status', 'scheduled')
    .gte('scheduled_date', todayUTC.toISOString());

console.log('Query error:', eventsError);
console.log('Query result:', upcomingEvents);

if (eventsError) throw eventsError;

console.log('Comparison date (today UTC):', todayUTC.toISOString());
console.log('Found upcoming events:', upcomingEvents?.length || 0);

// Also check ALL events for this match to see what exists
const { data: allEvents } = await supabase
    .from('events')
    .select('id, scheduled_date, status')
    .eq('match_id', matchId);

console.log('All events for this match:', allEvents);        
        if (upcomingEvents && upcomingEvents.length > 0) {
            // Add user to all upcoming events
            const participantRecords = upcomingEvents.map(event => ({
                event_id: event.id,
                profile_id: newUserId,
                status: 'accepted'
            }));
            
            const { error: insertError } = await supabase
                .from('event_participants')
                .insert(participantRecords);
            
            if (insertError && insertError.code !== '23505') { // Ignore duplicate key errors
                throw insertError;
            }
            
            console.log(`✓ Added user to ${upcomingEvents.length} upcoming event(s)`);
            
            // Notify user they were added to events
            if (upcomingEvents.length === 1) {
                showNotification(`You've been added to an upcoming event!`);
            } else {
                showNotification(`You've been added to ${upcomingEvents.length} upcoming events!`);
            }
        }
    } catch (error) {
        console.error('Error auto-adding to upcoming events:', error);
    }
}

// Open event chat
async function openEventChat(eventId) {
    try {
        // Cleanup previous subscription
        if (eventMessageSubscription) {
            await supabase.removeChannel(eventMessageSubscription);
            eventMessageSubscription = null;
        }
        
        // Load event details
        const { data: event, error: eventError } = await supabase
            .from('events')
            .select(`
                *,
                event_participants(
                    profile_id,
                    status,
                    profiles(id, name, avatar)
                )
            `)
            .eq('id', eventId)
            .single();
        
        if (eventError) throw eventError;
        
        currentEvent = event;
        
        // Get activity details
        const activity = activities.find(a => a.id === event.activity_id);
        
        // Update header
        document.getElementById('event-activity-name').textContent = 
            `${activity ? activity.emoji : '🎯'} ${activity ? activity.name : 'Unknown Activity'}`;
        
        const participantNames = event.event_participants
            .map(p => p.profiles.name)
            .join(', ');
        document.getElementById('event-participants').textContent = participantNames;
        
        // Format and display event details
const eventDate = new Date(event.scheduled_date);
const dateStr = eventDate.toLocaleDateString('en-US', { 
    weekday: 'long',
    month: 'long', 
    day: 'numeric',
    year: 'numeric'
});
        
        document.getElementById('event-date').textContent = `📅 ${dateStr}`;
        document.getElementById('event-location').textContent = 
            event.location ? `📍 ${event.location}` : '';
        document.getElementById('event-notes').textContent = 
            event.notes ? `📝 ${event.notes}` : '';
        
        // Load messages (with archive support)
await loadEventMessages(eventId, event.created_at);
        
        // Set up broadcast subscription for new messages
eventMessageSubscription = supabase
    .channel(`event_${eventId}`)
    .on('broadcast', { event: 'new_message' }, (payload) => {
        console.log('📩 Broadcast message received:', payload);
        
        // Don't duplicate messages we sent ourselves
        if (payload.payload.sender_id === currentUser.id) {
            console.log('⏭️ Skipping own message');
            return;
        }
        
        console.log('🔥 Processing message from another user');
        
        // Create message object with sender info from broadcast
        const message = {
            id: payload.payload.id,
            sender_id: payload.payload.sender_id,
            content: payload.payload.content,
            created_at: payload.payload.created_at,
            sender: {
                id: payload.payload.sender_id,
                name: payload.payload.sender_name,
                avatar: payload.payload.sender_avatar
            }
        };
        
        console.log('Appending message to chat:', message);
        appendMessage(message);
    })
    .on('broadcast', { event: 'message_edited' }, (payload) => {
        console.log('✏️ Message edited:', payload);
        loadEventMessages(currentEvent.id, currentEvent.created_at);
    })
    .on('broadcast', { event: 'message_deleted' }, (payload) => {
        console.log('🗑️ Message deleted:', payload);
        loadEventMessages(currentEvent.id, currentEvent.created_at);
    })
    .subscribe((status) => {
        console.log('Event chat subscription status:', status);
    });
        
        showPage('chat');
        
    } catch (error) {
        console.error('Error loading event chat:', error);
        alert('Failed to load event chat');
    }
}

// Load messages for current event
async function loadEventMessages(eventId, eventCreatedAt) {
    try {
        const { data: messages, error } = await supabase
            .from('event_messages')
            .select(`
                *,
                sender:profiles(id, name, avatar)
            `)
            .eq('event_id', eventId)
            .order('created_at', { ascending: true });
        
        if (error) throw error;
        
        const messagesContainer = document.getElementById('chat-messages');
        messagesContainer.innerHTML = '';
        
        // Split messages into archived (before event) and current (after event)
        const eventCreatedDate = new Date(eventCreatedAt);
        const archivedMessages = messages.filter(m => new Date(m.created_at) < eventCreatedDate);
        const currentMessages = messages.filter(m => new Date(m.created_at) >= eventCreatedDate);
        
        // Show archived messages toggle if any exist
        if (archivedMessages.length > 0) {
            const archiveToggle = document.createElement('div');
            archiveToggle.style.cssText = `
                padding: 10px;
                background: #f0f0f0;
                border-radius: 8px;
                text-align: center;
                margin-bottom: 15px;
                cursor: pointer;
                color: #666;
                font-size: 14px;
                user-select: none;
            `;
            archiveToggle.innerHTML = `
                <span id="archive-toggle-text">📜 Show ${archivedMessages.length} older message${archivedMessages.length > 1 ? 's' : ''} (before event was created)</span>
            `;
            archiveToggle.onclick = () => toggleArchivedMessages(eventId, eventCreatedAt);
            messagesContainer.appendChild(archiveToggle);
            
            // Container for archived messages (hidden by default)
            const archivedContainer = document.createElement('div');
            archivedContainer.id = 'archived-messages';
            archivedContainer.style.display = 'none';
            archivedContainer.style.cssText = `
                border-left: 3px solid #ddd;
                padding-left: 10px;
                margin-bottom: 20px;
                opacity: 0.7;
            `;
            messagesContainer.appendChild(archivedContainer);
            
            // Add archived messages to container
            archivedMessages.forEach(message => {
                appendMessageToContainer(message, archivedContainer);
            });
            
            // Divider
            const divider = document.createElement('div');
            divider.style.cssText = `
                border-top: 2px solid #ddd;
                margin: 20px 0;
                padding-top: 10px;
                text-align: center;
                color: #999;
                font-size: 13px;
            `;
            divider.innerHTML = '📅 Event Created';
            archivedContainer.appendChild(divider);
        }
        
        // Show current messages
        if (currentMessages.length === 0 && archivedMessages.length === 0) {
            messagesContainer.innerHTML += '<p style="text-align: center; color: #999; padding: 20px;">No messages yet. Start the conversation!</p>';
        } else if (currentMessages.length === 0) {
            const placeholder = document.createElement('p');
            placeholder.style.cssText = 'text-align: center; color: #999; padding: 20px;';
            placeholder.textContent = 'No messages since event was created. Say something!';
            messagesContainer.appendChild(placeholder);
        } else {
            currentMessages.forEach(message => appendMessage(message));
        }
        
        // Scroll to bottom
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        
    } catch (error) {
        console.error('Error loading messages:', error);
    }
}

function toggleArchivedMessages(eventId, eventCreatedAt) {
    const archivedContainer = document.getElementById('archived-messages');
    const toggleText = document.getElementById('archive-toggle-text');
    
    showingArchivedMessages = !showingArchivedMessages;
    
    if (showingArchivedMessages) {
        archivedContainer.style.display = 'block';
        toggleText.textContent = '🔼 Hide older messages';
    } else {
        archivedContainer.style.display = 'none';
        const archivedCount = archivedContainer.querySelectorAll('.message').length - 1; // -1 for divider
        toggleText.textContent = `📜 Show ${archivedCount} older message${archivedCount > 1 ? 's' : ''} (before event was created)`;
    }
}

// Helper to append message to specific container
function appendMessageToContainer(message, container) {
    const isOwnMessage = message.sender_id === currentUser.id;
    const messageTime = new Date(message.created_at).toLocaleTimeString('en-US', { 
        hour: 'numeric', 
        minute: '2-digit' 
    });
    
    const messageDiv = document.createElement('div');
    messageDiv.className = 'message';
    messageDiv.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: ${isOwnMessage ? 'flex-end' : 'flex-start'};
        margin-bottom: 15px;
    `;
    
    let onClick = '';
    let content = message.content;
    
    messageDiv.innerHTML = `
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; ${isOwnMessage ? 'flex-direction: row-reverse;' : ''}">
            <div style="width: 32px; height: 32px; border-radius: 50%; background: #e0e0e0; display: flex; align-items: center; justify-content: center; font-size: 18px;">
                ${message.sender.avatar || '👤'}
            </div>
            <span style="font-size: 13px; color: #666; font-weight: 500;">
                ${isOwnMessage ? 'You' : message.sender.name}
            </span>
            <span style="font-size: 11px; color: #999;">
                ${messageTime}
            </span>
        </div>
        <div style="display: flex; gap: 8px; align-items: flex-start; ${isOwnMessage ? 'flex-direction: row-reverse;' : ''}">
            <div ${onClick} style="
    background: ${isOwnMessage ? '#4CAF50' : '#f0f0f0'};
    color: ${isOwnMessage ? 'white' : 'black'};
    padding: 10px 14px;
    border-radius: 12px;
    max-width: 70%;
    word-wrap: break-word;
    overflow-wrap: break-word;
    word-break: normal;
    min-width: fit-content;
">
                ${content}
            </div>
        </div>
    `;
    
    // Add edit/delete for own messages (archived messages are read-only for simplicity)
    
    container.appendChild(messageDiv);
}

function appendMessage(message) {
    const messagesContainer = document.getElementById('chat-messages');
    
    if (messagesContainer.querySelector('p')) {
        messagesContainer.innerHTML = '';
    }
    
    const isOwnMessage = message.sender_id === currentUser.id;
    const messageTime = new Date(message.created_at).toLocaleTimeString('en-US', { 
        hour: 'numeric', 
        minute: '2-digit' 
    });
    
    const messageDiv = document.createElement('div');
    messageDiv.style.cssText = `
        display: flex;
        flex-direction: column;
        align-items: ${isOwnMessage ? 'flex-end' : 'flex-start'};
        margin-bottom: 15px;
    `;
    
    messageDiv.innerHTML = `
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px; ${isOwnMessage ? 'flex-direction: row-reverse;' : ''}">
            <div style="width: 32px; height: 32px; border-radius: 50%; background: #e0e0e0; display: flex; align-items: center; justify-content: center; font-size: 18px;">
                ${message.sender.avatar || '👤'}
            </div>
            <span style="font-size: 13px; color: #666; font-weight: 500;">
                ${isOwnMessage ? 'You' : message.sender.name}
            </span>
            <span style="font-size: 11px; color: #999;">
                ${messageTime}
            </span>
        </div>
        <div style="display: flex; gap: 8px; align-items: flex-start; ${isOwnMessage ? 'flex-direction: row-reverse;' : ''}">
            <div style="
    background: ${isOwnMessage ? '#4CAF50' : '#f0f0f0'};
    color: ${isOwnMessage ? 'white' : 'black'};
    padding: 10px 14px;
    border-radius: 12px;
    max-width: 70%;
    word-wrap: break-word;
    overflow-wrap: break-word;
    word-break: normal;
    min-width: fit-content;
">
    ${message.content}
</div>
            ${isOwnMessage ? `
    <div class="message-actions" style="position: relative;">
        <button onclick="toggleEventMessageActions('${message.id}')" style="background: none; border: none; color: #aaa; cursor: pointer; font-size: 1.2em; padding: 5px;">⋯</button>
        <div id="event-menu-${message.id}" class="message-actions-menu" style="position: absolute; bottom: 25px; right: 0; background: white; border: 1px solid #ddd; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); display: none; width: 100px; z-index: 10;">
            ${!message.content.includes('<img') && !message.content.includes('<a') ? `<button onclick="editEventMessage('${message.id}', \`${message.content.replace(/`/g, '\\`').replace(/\$/g, '\\$')}\`)" style="display: block; width: 100%; padding: 10px; background: none; border: none; text-align: left; cursor: pointer;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='none'">Edit</button>` : ''}
            <button onclick="deleteEventMessage('${message.id}')" style="display: block; width: 100%; padding: 10px; background: none; border: none; text-align: left; cursor: pointer;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='none'">Delete</button>
        </div>
    </div>
` : ''}
        </div>
    `;
    
    messagesContainer.appendChild(messageDiv);
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

// Send message
async function sendEventMessage(e) {
    e.preventDefault();
    
    const input = document.getElementById('message-input');
    const content = input.value.trim();
    
    if (!content) return;
    
    try {
        // Check if we're in match chat or event chat
        if (currentMatchChat) {
            // Match chat
            const { data, error } = await supabase
                .from('match_messages')
                .insert({
                    match_id: currentMatchChat.id,
                    sender_id: currentUser.id,
                    content: content
                })
                .select(`
                    *,
                    sender:profiles(id, name, avatar)
                `)
                .single();
            
            if (error) throw error;
            
            appendMessage(data);
            
            const channel = supabase.channel(`match_chat_${currentMatchChat.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'new_message',
                payload: {
                    id: data.id,
                    sender_id: currentUser.id,
                    sender_name: currentUser.name,
                    sender_avatar: currentUser.avatar,
                    content: data.content,
                    created_at: data.created_at
                }
            });
            
        } else if (currentEvent) {
            // Event chat
            const { data, error } = await supabase
                .from('event_messages')
                .insert({
                    event_id: currentEvent.id,
                    sender_id: currentUser.id,
                    content: content
                })
                .select(`
                    *,
                    sender:profiles(id, name, avatar)
                `)
                .single();
            
            if (error) throw error;
            
            appendMessage(data);
            
            const channel = supabase.channel(`event_${currentEvent.id}`);
            await channel.send({
                type: 'broadcast',
                event: 'new_message',
                payload: {
                    id: data.id,
                    sender_id: currentUser.id,
                    sender_name: currentUser.name,
                    sender_avatar: currentUser.avatar,
                    content: data.content,
                    created_at: data.created_at
                }
            });
        }
        
        input.value = '';
        
    } catch (error) {
        console.error('Error sending message:', error);
        showNotification('Failed to send message', 'error');
    }
}

// Event options functions
function openEventOptionsModal() {
    document.getElementById('event-options-modal').style.display = 'flex';
}

function closeEventOptionsModal() {
    document.getElementById('event-options-modal').style.display = 'none';
}

function editCurrentEvent() {
    closeEventOptionsModal();
    
    // Populate edit form
    const date = new Date(currentEvent.scheduled_date);
    document.getElementById('edit-event-date').value = date.toISOString().slice(0, 10);
    document.getElementById('edit-event-location').value = currentEvent.location || '';
    document.getElementById('edit-event-notes').value = currentEvent.notes || '';
    
    document.getElementById('edit-event-modal').style.display = 'flex';
}

function closeEditEventModal() {
    document.getElementById('edit-event-modal').style.display = 'none';
}

async function saveEventEdits(e) {
    e.preventDefault();
    
    try {
        const { error } = await supabase
            .from('events')
            .update({
                scheduled_date: document.getElementById('edit-event-date').value,
                location: document.getElementById('edit-event-location').value || null,
                notes: document.getElementById('edit-event-notes').value || null
            })
            .eq('id', currentEvent.id);
        
        if (error) throw error;
        
        closeEditEventModal();
        
        // Reload the event
        openEventChat(currentEvent.id);
        
    } catch (error) {
        console.error('Error updating event:', error);
        alert('Failed to update event');
    }
}

async function markEventCompleted() {
    if (!confirm('Mark this event as completed?')) return;
    
    try {
        const { error } = await supabase
            .from('events')
            .update({ status: 'completed' })
            .eq('id', currentEvent.id);
        
        if (error) throw error;
        
        closeEventOptionsModal();
        showPage('matches');
        await loadMatches();
        
    } catch (error) {
        console.error('Error marking event as completed:', error);
        alert('Failed to mark event as completed');
    }
}

async function cancelEvent() {
    if (!confirm('Cancel this event? This will notify all participants.')) return;
    
    try {
        const { error } = await supabase
            .from('events')
            .update({ status: 'cancelled' })
            .eq('id', currentEvent.id);
        
        if (error) throw error;
        
        // Send a system message
        await supabase
            .from('event_messages')
            .insert({
                event_id: currentEvent.id,
                sender_id: currentUser.id,
                content: '❌ This event has been cancelled'
            });
        
        closeEventOptionsModal();
        showPage('matches');
        await loadMatches();
        
    } catch (error) {
        console.error('Error cancelling event:', error);
        alert('Failed to cancel event');
    }
}

async function leaveEvent() {
    if (!confirm('Leave this event? You won\'t receive any more messages.')) return;
    
    try {
        const { error } = await supabase
            .from('event_participants')
            .delete()
            .eq('event_id', currentEvent.id)
            .eq('profile_id', currentUser.id);
        
        if (error) throw error;
        
        closeEventOptionsModal();
        showPage('matches');
        await loadMatches();
        
    } catch (error) {
        console.error('Error leaving event:', error);
        alert('Failed to leave event');
    }
}

async function deleteEvent() {
    if (!confirm('Delete this event permanently? This will remove it for all participants and cannot be undone.')) return;
    
    // Only event creator can delete
    if (currentEvent.created_by !== currentUser.id) {
        alert('Only the event creator can delete this event');
        return;
    }
    
    try {
        const { error } = await supabase
            .from('events')
            .delete()
            .eq('id', currentEvent.id);
        
        if (error) throw error;
        
        closeEventOptionsModal();
        showPage('matches');
        await loadMatches();
        
    } catch (error) {
        console.error('Error deleting event:', error);
        alert('Failed to delete event');
    }
}

// Match Chat Functions
window.openMatchChat = async function(matchId) {
    try {
        // Cleanup previous subscription
        if (matchMessageSubscription) {
            await supabase.removeChannel(matchMessageSubscription);
            matchMessageSubscription = null;
        }
        
        // Find the match
        const match = matches.find(m => m.id === matchId);
        if (!match) {
            showNotification('Match not found', 'error');
            return;
        }
        
        currentMatchChat = match;
        
        // Get activity details
        const activity = activities.find(a => a.id === match.activity_id);
        
        // Get all participants
        const { data: participants, error: participantsError } = await supabase
            .from('match_participants')
            .select('profile_id, profiles(id, name, avatar)')
            .eq('match_id', matchId);
        
        if (participantsError) throw participantsError;
        
        // Update header
        document.getElementById('event-activity-name').textContent = 
            `${activity ? activity.emoji : '🎯'} ${activity ? activity.name : 'Unknown Activity'}`;
        
        const participantNames = participants
            .map(p => p.profiles.name)
            .join(', ');
        document.getElementById('event-participants').textContent = participantNames;
        
        // Hide event details section for match chat
        document.getElementById('event-details').style.display = 'none';
        
        // Load messages
        await loadMatchMessages(matchId);
        
        // Set up broadcast subscription
        matchMessageSubscription = supabase
            .channel(`match_chat_${matchId}`)
            .on('broadcast', { event: 'new_message' }, (payload) => {
                if (payload.payload.sender_id === currentUser.id) return;
                
                const message = {
                    id: payload.payload.id,
                    sender_id: payload.payload.sender_id,
                    content: payload.payload.content,
                    created_at: payload.payload.created_at,
                    sender: {
                        id: payload.payload.sender_id,
                        name: payload.payload.sender_name,
                        avatar: payload.payload.sender_avatar
                    }
                };
                
                appendMessage(message);
            })
            .on('broadcast', { event: 'message_edited' }, (payload) => {
                loadMatchMessages(currentMatchChat.id);
            })
            .on('broadcast', { event: 'message_deleted' }, (payload) => {
                loadMatchMessages(currentMatchChat.id);
            })
            .subscribe();
        
        showPage('chat');
        
    } catch (error) {
        console.error('Error loading match chat:', error);
        showNotification('Failed to load chat', 'error');
    }
}

async function loadMatchMessages(matchId) {
    try {
        const { data: messages, error } = await supabase
            .from('match_messages')
            .select(`
                *,
                sender:profiles(id, name, avatar)
            `)
            .eq('match_id', matchId)
            .order('created_at', { ascending: true });
        
        if (error) throw error;
        
        const messagesContainer = document.getElementById('chat-messages');
        messagesContainer.innerHTML = '';
        
        if (messages.length === 0) {
            messagesContainer.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">No messages yet. Start planning your activity!</p>';
        } else {
            messages.forEach(message => appendMessage(message));
        }
        
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        
    } catch (error) {
        console.error('Error loading match messages:', error);
    }
}
        
        // Attachments & Modals
        window.sharePhoto = function() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.capture = 'environment'; // Rear camera
    
    input.onchange = async function(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        // Validate file size (max 5MB)
        if (file.size > 5 * 1024 * 1024) {
            return showNotification('Photo too large. Maximum size is 5MB.', 'error');
        }
        
        showNotification('Uploading photo...');
        
        try {
            // Generate unique filename
            const fileExt = file.name.split('.').pop();
            const fileName = `${currentUser.id}/${Date.now()}.${fileExt}`;
            
            // Upload to Supabase Storage
            const { data, error } = await supabase.storage
                .from('chat-photos')
                .upload(fileName, file, {
                    cacheControl: '3600',
                    upsert: false
                });
            
            if (error) throw error;
            
            // Get public URL
            const { data: urlData } = supabase.storage
                .from('chat-photos')
                .getPublicUrl(fileName);
            
            const photoUrl = urlData.publicUrl;
            
            // Send photo message based on chat type
            if (currentMatchChat) {
                // Match chat
                const { data: messageData, error: messageError } = await supabase
                    .from('match_messages')
                    .insert({
                        match_id: currentMatchChat.id,
                        sender_id: currentUser.id,
                        content: `<img src="${photoUrl}" style="max-width: 200px; border-radius: 10px; cursor: pointer;" onclick="openImageModal('${photoUrl}')">`
                    })
                    .select(`
                        *,
                        sender:profiles(id, name, avatar)
                    `)
                    .single();
                
                if (messageError) throw messageError;
                
                appendMessage(messageData);
                
                const channel = supabase.channel(`match_chat_${currentMatchChat.id}`);
                await channel.send({
                    type: 'broadcast',
                    event: 'new_message',
                    payload: {
                        id: messageData.id,
                        sender_id: currentUser.id,
                        sender_name: currentUser.name,
                        sender_avatar: currentUser.avatar,
                        content: messageData.content,
                        created_at: messageData.created_at
                    }
                });
                
            } else if (currentEvent) {
                // Event chat system
                const { data: messageData, error: messageError } = await supabase
                    .from('event_messages')
                    .insert({
                        event_id: currentEvent.id,
                        sender_id: currentUser.id,
                        content: `<img src="${photoUrl}" style="max-width: 200px; border-radius: 10px; cursor: pointer;" onclick="openImageModal('${photoUrl}')">`
                    })
                    .select(`
                        *,
                        sender:profiles(id, name, avatar)
                    `)
                    .single();
                
                if (messageError) throw messageError;
                
                // Append to UI
                appendMessage(messageData);
                
                // Broadcast to other users
                const channel = supabase.channel(`event_${currentEvent.id}`);
                await channel.send({
                    type: 'broadcast',
                    event: 'new_message',
                    payload: {
                        id: messageData.id,
                        sender_id: currentUser.id,
                        sender_name: currentUser.name,
                        sender_avatar: currentUser.avatar,
                        content: messageData.content,
                        created_at: messageData.created_at
                    }
                });
                
            } else if (currentChatMatch) {
                // Old match chat system
                addMessage(photoUrl, 'photo');
            }
            
            showNotification('Photo shared!');
            
        } catch (error) {
            console.error('Error uploading photo:', error);
            showNotification('Failed to upload photo. Please try again.', 'error');
        }
    };
    
    input.click();
}
        window.shareLocation = async function() {
    if (!navigator.geolocation) {
        return showNotification('Geolocation not supported', 'error');
    }
    
    navigator.geolocation.getCurrentPosition(
        async (pos) => {
            const lat = pos.coords.latitude;
            const lng = pos.coords.longitude;
            
            const mapsUrl = `https://www.google.com/maps?q=${lat},${lng}`;
            
            try {
                // Check if we're in match chat, event chat, or old match chat
                if (currentMatchChat) {
                    // Match chat
                    const { data, error } = await supabase
                        .from('match_messages')
                        .insert({
                            match_id: currentMatchChat.id,
                            sender_id: currentUser.id,
                            content: `📍 <a href="${mapsUrl}" target="_blank" rel="noopener noreferrer" style="color: #4CAF50; text-decoration: underline; font-weight: 500;">View Location on Map</a>`
                        })
                        .select(`
                            *,
                            sender:profiles(id, name, avatar)
                        `)
                        .single();
                    
                    if (error) throw error;
                    
                    appendMessage(data);
                    
                    const channel = supabase.channel(`match_chat_${currentMatchChat.id}`);
                    await channel.send({
                        type: 'broadcast',
                        event: 'new_message',
                        payload: {
                            id: data.id,
                            sender_id: currentUser.id,
                            sender_name: currentUser.name,
                            sender_avatar: currentUser.avatar,
                            content: data.content,
                            created_at: data.created_at
                        }
                    });
                    
                    showNotification('Location shared!');
                    
                } else if (currentEvent) {
                    // Event chat system
                    const { data, error } = await supabase
                        .from('event_messages')
                        .insert({
                            event_id: currentEvent.id,
                            sender_id: currentUser.id,
                            content: `📍 <a href="${mapsUrl}" target="_blank" rel="noopener noreferrer" style="color: #4CAF50; text-decoration: underline; font-weight: 500;">View Location on Map</a>`
                        })
                        .select(`
                            *,
                            sender:profiles(id, name, avatar)
                        `)
                        .single();
                    
                    if (error) throw error;
                    
                    appendMessage(data);
                    
                    const channel = supabase.channel(`event_${currentEvent.id}`);
                    await channel.send({
                        type: 'broadcast',
                        event: 'new_message',
                        payload: {
                            id: data.id,
                            sender_id: currentUser.id,
                            sender_name: currentUser.name,
                            sender_avatar: currentUser.avatar,
                            content: data.content,
                            created_at: data.created_at
                        }
                    });
                    
                    showNotification('Location shared!');
                    
                } else if (currentChatMatch) {
                    // Old match chat system
                    addMessage('Location Shared', 'location', { lat, lng });
                    showNotification('Location shared!');
                }
                
            } catch (error) {
                console.error('Error sharing location:', error);
                showNotification('Failed to share location. Please try again.', 'error');
            }
        },
        () => showNotification('Could not get location', 'error')
    );
}
        window.openImageModal = src => { document.getElementById('modal-image').src = src; document.getElementById('image-modal-overlay').style.display = 'flex'; };
        window.closeImageModal = () => document.getElementById('image-modal-overlay').style.display = 'none';
        window.openMap = (lat, lng) => window.open(`https://www.google.com/maps?q=${lat},${lng}`, '_blank');
window.findNearbyPlaces = async function() {
            if (!navigator.geolocation) {
                return showNotification('Geolocation not supported on this device', 'error');
            }
            
            if (!currentEvent && !currentMatchChat) {
    return showNotification('This feature is only available in chats', 'error');
}
            
            showNotification('Finding nearby places...');
            
            navigator.geolocation.getCurrentPosition(
                async (pos) => {
                    const lat = pos.coords.latitude;
                    const lng = pos.coords.longitude;
                    
                    const activity = activities.find(a => a.id === (currentEvent?.activity_id || currentMatchChat?.activity_id));
                    const activityName = activity ? activity.name : 'restaurants';
                    
                    const searchUrl = `https://www.google.com/maps/search/${encodeURIComponent(activityName)}/@${lat},${lng},15z`;
                    
                    try {
    if (currentMatchChat) {
        const { data, error } = await supabase
            .from('match_messages')
            .insert({
                match_id: currentMatchChat.id,
                sender_id: currentUser.id,
                content: `🔍 <a href="${searchUrl}" target="_blank" rel="noopener noreferrer" style="color: #667eea; text-decoration: underline; font-weight: 500;">Find nearby ${activityName} spots</a>`
            })
            .select(`*, sender:profiles(id, name, avatar)`)
            .single();
        
        if (error) throw error;
        
        appendMessage(data);
        
        const channel = supabase.channel(`match_chat_${currentMatchChat.id}`);
        await channel.send({
            type: 'broadcast',
            event: 'new_message',
            payload: {
                id: data.id,
                sender_id: currentUser.id,
                sender_name: currentUser.name,
                sender_avatar: currentUser.avatar,
                content: data.content,
                created_at: data.created_at
            }
        });
        
        showNotification('Search link shared!');
        
    } else if (currentEvent) {
        const { data, error } = await supabase
            .from('event_messages')
            .insert({
                event_id: currentEvent.id,
                sender_id: currentUser.id,
                content: `🔍 <a href="${searchUrl}" target="_blank" rel="noopener noreferrer" style="color: #667eea; text-decoration: underline; font-weight: 500;">Find nearby ${activityName} spots</a>`
            })
            .select(`*, sender:profiles(id, name, avatar)`)
            .single();
        
        if (error) throw error;
        
        appendMessage(data);
        
        const channel = supabase.channel(`event_${currentEvent.id}`);
        await channel.send({
            type: 'broadcast',
            event: 'new_message',
            payload: {
                id: data.id,
                sender_id: currentUser.id,
                sender_name: currentUser.name,
                sender_avatar: currentUser.avatar,
                content: data.content,
                created_at: data.created_at
            }
        });
        
        showNotification('Search link shared!');
    }
} catch (error) {
                        console.error('Error sharing nearby places:', error);
                        showNotification('Failed to share search. Please try again.', 'error');
                    }
                },
                (error) => {
                    let errorMessage = 'Could not get location';
                    if (error.code === error.PERMISSION_DENIED) {
                        errorMessage = 'Location permission denied. Please enable location access in your browser settings.';
                    } else if (error.code === error.POSITION_UNAVAILABLE) {
                        errorMessage = 'Location information unavailable. Please try again.';
                    } else if (error.code === error.TIMEOUT) {
                        errorMessage = 'Location request timed out. Please try again.';
                    }
                    showNotification(errorMessage, 'error');
                },
                { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
            );
        }
        function updateNotificationBadge() {
            const hasUnread = matches.some(m => !m.isRead) || Object.values(messages).flat().some(msg => !msg.isRead && msg.sender !== currentUser.name);
            document.querySelector('#matches-nav-item .notification-badge').style.display = hasUnread ? 'block' : 'none';
        }
        window.showPage = async function(pageId) {
    // Clean up subscriptions when leaving chat
if (pageId !== 'chat') {
    if (eventMessageSubscription) {
        supabase.removeChannel(eventMessageSubscription);
        eventMessageSubscription = null;
        currentEvent = null;
    }
    if (matchMessageSubscription) {
        supabase.removeChannel(matchMessageSubscription);
        matchMessageSubscription = null;
        currentMatchChat = null;
    }
    // Show event details again for next chat
    document.getElementById('event-details').style.display = 'block';
}
    
    // Clear current chat match when leaving chat page
    if (pageId !== 'chat') {
        currentChatMatch = null;
        localStorage.removeItem('friendle_current_chat');
    }
    
    localStorage.setItem('friendle_current_page', pageId);
    document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
    document.getElementById(pageId).classList.add('active');
    document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
    document.querySelector(`.nav-item[onclick="showPage('${pageId}')"]`)?.classList.add('active');
    
    if (pageId === 'circles') renderCircles();
if (pageId === 'activities' && selectedCircle) {
    // Reset activities array from saved preferences when returning to Activities page
    const savedActivityIds = await loadUserPreferences(selectedCircle.id);
    const allActivities = await loadActivities(selectedCircle.id);
    activities = allActivities.filter(activity => savedActivityIds.includes(activity.id));
    renderActivities();
}
if (pageId === 'matches') {
    await loadMatches();
}
}
        window.resetApp = () => { if (confirm('Are you sure?')) { localStorage.clear(); location.reload(); } };
        
        // Invite System
        window.showInviteModal = function(circleId) {
            const baseUrl = window.location.href.split('?')[0];
            const inviteToken = `invite_${circleId}_${Date.now()}`;
            const inviteLink = `${baseUrl}?invite_token=${inviteToken}`;
            document.getElementById('invite-link').value = inviteLink;
            document.getElementById('invite-modal-overlay').style.display = 'flex';
        }
        window.closeInviteModal = () => document.getElementById('invite-modal-overlay').style.display = 'none';
        window.copyInviteLink = function() {
            const linkInput = document.getElementById('invite-link');
            linkInput.select();
            document.execCommand('copy');
            showNotification('Link copied to clipboard!');
        }
        function processInvite() {
            const token = sessionStorage.getItem('pending_invite');
            if (token && currentUser) {
                const allCircles = JSON.parse(localStorage.getItem('friendle_circles') || '[]');
                const circleId = parseInt(token.split('_')[1]);
                const circle = allCircles.find(c => c.id === circleId);
                if (circle && !circle.members.some(m => m.id === currentUser.id)) {
                    circle.members.push(currentUser);
                    localStorage.setItem('friendle_circles', JSON.stringify(allCircles));
                    circles = allCircles; // Make sure our in-memory list is updated
                    showNotification(`Invite accepted! You've joined "${circle.name}".`);
                }
                sessionStorage.removeItem('pending_invite');
                renderCircles(); // Re-render to show the new circle membership
            }
}

        async function initApp() {
await loadDefaultActivities();
    const urlParams = new URLSearchParams(window.location.search);
    const inviteCode = urlParams.get('invite_code');
    
    // Store invite code for after authentication
    if (inviteCode) {
        sessionStorage.setItem('pending_invite_code', inviteCode);
        // Clean up URL
        window.history.replaceState({}, document.title, window.location.pathname);
    }

    // Check for existing Supabase auth session
    const { data: { session } } = await supabase.auth.getSession();
    
    if (session) {
        // User is authenticated, load their profile
        try {
            const { data: profileData, error } = await supabase
                .from('profiles')
                .select('*')
                .eq('id', session.user.id)
                .single();
            
            if (error) throw error;
            
            currentUser = profileData;
// Request notification permission
if ('Notification' in window && Notification.permission === 'default') {
    Notification.requestPermission();
}
        localStorage.setItem('friendle_user', JSON.stringify(currentUser));
        
        // Load circles first
        await renderCircles();
        
        // Then load matches from all circles
        await loadMatches();
        
        // Restore last page or default to circles
const lastPage = localStorage.getItem('friendle_current_page') || 'circles';

// Try to restore chat if we were on chat page
if (lastPage === 'chat') {
    const savedChat = localStorage.getItem('friendle_current_chat');
    if (savedChat) {
        try {
            const chatMatch = JSON.parse(savedChat);
            // Find the match in our loaded matches
            const foundMatch = matches.find(m => m.id === chatMatch.id);
            if (foundMatch) {
                await openChat(foundMatch);
            } else {
                showPage('circles');
            }
        } catch (e) {
            console.error('Error restoring chat:', e);
            showPage('circles');
        }
    } else {
        showPage('circles');
    }
} else if (lastPage === 'activities' && !selectedCircle) {
    showPage('circles');
} else {
    showPage(lastPage);
}
        
        updateProfile();
        
        // Process invite code if present
        await processInviteCode();
            
        } catch (error) {
            console.error('Error loading profile:', error);
            await supabase.auth.signOut();
            showPage('welcome');
        }
    } else {
        // No authenticated session, show login
        currentUser = null;
        localStorage.removeItem('friendle_user');
        showPage('welcome');
    }
}

// ✅ Run after DOM is ready
document.addEventListener("DOMContentLoaded", () => {
  console.log("DOM ready, attaching avatar clicks...");

  const avatars = document.querySelectorAll(".avatar-option");
  console.log("Found avatars:", avatars.length);

    avatars.forEach(option => {
    option.addEventListener("click", () => {
      console.log("Avatar clicked:", option.dataset.avatar);
      avatars.forEach(o => o.classList.remove("selected"));
      option.classList.add("selected");
    });
  });

const toggle = document.getElementById('show-past-events');
  if (toggle) {
    toggle.addEventListener('change', function() {
      console.log('Toggle changed to:', this.checked);
      renderMatches();
    });
  }

// Create event form submission
document.getElementById('create-event-form').addEventListener('submit', createEvent);

// Edit event form submission
document.getElementById('edit-event-form').addEventListener('submit', saveEventEdits);

window.openManageActivitiesModal = async function() {
    if (!selectedCircle) return;
    
    try {
        // Get circle-level visibility settings
const { data: circleActivities, error: visibilityError } = await supabase
    .from('circle_activities')
    .select('activity_id, is_visible')
    .eq('circle_id', selectedCircle.id);

if (visibilityError) throw visibilityError;

// Build visibility map - activities not in map use defaults (core=visible, extended=hidden)
const visibilityMap = {};
circleActivities?.forEach(ca => {
    visibilityMap[ca.activity_id] = ca.is_visible;
});
        
        const grid = document.getElementById('manage-activities-grid');
        
        // Create sections for core and extended activities
        grid.innerHTML = `
    <div style="margin-bottom: 30px;">
        <h3 style="margin-bottom: 15px; color: #555; font-size: 1.1em; font-weight: 600; border-bottom: 1px solid #f0f0f0; padding-bottom: 5px;">Core Activities</h3>
        <div class="activities-grid" id="core-activities-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;"></div>
    </div>
    <div>
        <h3 style="margin-bottom: 15px; color: #555; font-size: 1.1em; font-weight: 600; border-bottom: 1px solid #f0f0f0; padding-bottom: 5px;">Additional Activities</h3>
        <div class="activities-grid" id="extended-activities-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px;"></div>
    </div>
`;
        
        const coreGrid = document.getElementById('core-activities-grid');
const extendedGrid = document.getElementById('extended-activities-grid');

// Get core activities from defaultActivities array
const coreActivitiesArray = defaultActivities.filter(a => coreActivityIds.includes(a.id));

// Populate core activities
// Populate core activities
coreActivitiesArray.forEach(activity => {
    const card = document.createElement('div');
    // Core activities visible by default unless explicitly set otherwise
    const isVisible = visibilityMap.hasOwnProperty(activity.id) 
        ? visibilityMap[activity.id] 
        : true;
    card.className = `activity-card ${isVisible ? 'selected' : ''}`;
    card.onclick = () => toggleActivityVisibility(card, activity.id);
    card.dataset.activityId = activity.id;
    card.innerHTML = `
        <div class="activity-emoji">${activity.emoji}</div>
        <div class="activity-name">${activity.name}</div>
    `;
    coreGrid.appendChild(card);
});

// Get extended activities from defaultActivities array
const extendedActivitiesArray = defaultActivities.filter(a => extendedActivityIds.includes(a.id));

// Populate extended activities
extendedActivitiesArray.forEach(activity => {
    const card = document.createElement('div');
    // Extended activities hidden by default unless explicitly set otherwise
    const isVisible = visibilityMap.hasOwnProperty(activity.id) 
        ? visibilityMap[activity.id] 
        : false;
    card.className = `activity-card ${isVisible ? 'selected' : ''}`;
    card.onclick = () => toggleActivityVisibility(card, activity.id);
    card.dataset.activityId = activity.id;
    card.innerHTML = `
        <div class="activity-emoji">${activity.emoji}</div>
        <div class="activity-name">${activity.name}</div>
    `;
    extendedGrid.appendChild(card);
});
        
        document.getElementById('manage-activities-modal-overlay').style.display = 'flex';
        
    } catch (error) {
        console.error('Error loading manage activities modal:', error);
    }
}

window.closeManageActivitiesModal = () => {
    document.getElementById('manage-activities-modal-overlay').style.display = 'none';
}

window.toggleActivityVisibility = function(card, activityId) {
    card.classList.toggle('selected');
    console.log('Toggled activity:', activityId, 'Selected:', card.classList.contains('selected'));
}

window.saveActivityVisibility = async function() {
    try {
        // Get selected activities from modal
        const selectedCards = document.querySelectorAll('#manage-activities-grid .activity-card.selected');
        const selectedIds = Array.from(selectedCards).map(card => card.dataset.activityId);
        
        // Get all activity IDs
        const allActivityIds = [...coreActivityIds, ...extendedActivityIds];
        
        // Prepare upsert data for all activities
        const visibilityData = allActivityIds.map(activityId => ({
            circle_id: selectedCircle.id,
            activity_id: activityId,
            is_visible: selectedIds.includes(activityId)
        }));
        
        // Upsert to circle_activities table
        const { error } = await supabase
            .from('circle_activities')
            .upsert(visibilityData, { 
                onConflict: 'circle_id,activity_id'
            });
        
        if (error) throw error;
        
        showNotification('Activity preferences updated for all circle members!');
        closeManageActivitiesModal();
        renderActivities();
    } catch (error) {
        console.error('Error saving activity visibility:', error);
        showNotification('Error saving changes', 'error');
    }
}
  initApp(); // start the app
});   // ✅ only one of these, closes document.addEventListener

function showNotificationAlert(title, body) {
    console.log('=== NOTIFICATION DEBUG ===');
    console.log('Title:', title);
    console.log('Body:', body);
    console.log('Notification in window:', 'Notification' in window);
    console.log('Permission:', Notification?.permission);
    console.log('Document hidden:', document.hidden);
    console.log('Document visibility:', document.visibilityState);
    
    if (!('Notification' in window)) {
        console.log('Browser does not support notifications');
        return;
    }
    
    if (Notification.permission !== 'granted') {
        console.log('Notification permission not granted');
        return;
    }
    
    try {
        const notification = new Notification(title, {
            body: body,
            tag: 'friendle-message', // Prevents duplicate notifications
            requireInteraction: false,
            silent: false
        });
        
        console.log('Notification created successfully');
        
        // Handle notification click
        notification.onclick = function() {
            window.focus();
            notification.close();
        };
        
    } catch (error) {
        console.error('Error creating notification:', error);
    }
}

// Real-time messaging subscription
let messageSubscription = null;

function setupRealtimeMessages(matchId) {
    console.log('=== SETTING UP REALTIME ===');
    console.log('Match ID:', matchId);
    
    // Clean up existing subscription
    if (messageSubscription) {
        console.log('Cleaning up old subscription');
        supabase.removeChannel(messageSubscription);
    }
    
    // Use Realtime Presence/Broadcast instead of postgres_changes
    messageSubscription = supabase
        .channel(`match_${matchId}`)
        .on('broadcast', { event: 'new_message' }, (payload) => {
            console.log('🔔 NEW MESSAGE RECEIVED:', payload);
            
            // Don't duplicate messages we sent ourselves
            if (payload.payload.sender_id === currentUser.id) {
                console.log('⏭️ Skipping own message');
                return;
            }
            
            console.log('📥 Processing message from another user');
            
            // Add to local messages array
            const newMessage = {
                id: payload.payload.id,
                sender: payload.payload.sender_name,
                sender_id: payload.payload.sender_id,
                content: payload.payload.content,
                type: payload.payload.type,
                lat: payload.payload.lat,
                lng: payload.payload.lng,
                created_at: payload.payload.created_at,
                isRead: true
            };
            
            if (!messages[matchId]) messages[matchId] = [];
            messages[matchId].push(newMessage);
            
            console.log('✅ Message added to local array');
            
            // Always attempt notification for new messages
            showNotificationAlert(
                `New message from ${newMessage.sender}`,
                newMessage.content
            );
            
            // Update UI if we're viewing this chat
            if (currentChatMatch && currentChatMatch.id === matchId) {
                console.log('🎨 Updating UI');
                renderChatMessages();
            }
            
            // Update localStorage
            localStorage.setItem('friendle_messages', JSON.stringify(messages));
        })
        .subscribe((status) => {
            console.log('Subscription status:', status);
        });
    
    console.log('✅ Subscription created');
}

function cleanupRealtimeMessages() {
    if (messageSubscription) {
        supabase.removeChannel(messageSubscription);
        messageSubscription = null;
        console.log('Unsubscribed from messages');
    }
}

// Register service worker for PWA
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/service-worker.js')
      .then(registration => {
        console.log('ServiceWorker registered:', registration);
      })
      .catch(error => {
        console.log('ServiceWorker registration failed:', error);
      });
  });
}

</script>
</body>
</html>